/*! \file pg-scenarioParse.cpp
 *
 * 
 * 
 *     File pg-scenarioParse.cpp
 * 
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free
 * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 */
#include "pg-all_include.h"

/*! \name Group constants
 *  \brief Enumerated constants
 */
// \{


//////////////////////////////////////////////////////////////////////////////////////////////////////
// GLOBAL VARS
//////////////////////////////////////////////////////////////////////////////////////////////////////

vector<Scene>			 pg_Scenario[PG_MAX_SCENARIOS];
						// table of PG_MAX_SCENARIOS booleans tables indicating whether a var (from the full scenario) 
						// is active for the current configuration and scenario
bool					 pg_FullScenarioActiveVars[PG_MAX_SCENARIOS][_MaxInterpVarIDs] = { {false} };

string					 pg_csv_logFile_name;
string					 pg_snapshots_dir_path_prefix;
string					 pg_snapshots_dir_path_name;

pg_WindowData            *pg_Window;

// PNG capture
pg_Png_Capture pg_Png_Capture_param;

// JPG capture
pg_Jpg_Capture pg_Jpg_Capture_param;

// SVG path capture
pg_Svg_Capture pg_Svg_Capture_param;

// scenario file names
string *pg_ScenarioFileNames = NULL;

// shader file names
string  ** pg_Shader_File_Names;
GLenum *** pg_Shader_Stages;
int     ** pg_Shader_nbStages;

// ++++++++++++++++++++++ PATHS, IDs FROM CONFIGURATION FILE ++++++++++++++++++++ 
string pg_scripts_directory;
string pg_videos_directory;
string pg_soundtracks_directory;
string pg_cliparts_directory;
string pg_diaporamas_directory;
string pg_meshes_directory;
string pg_messages_directory;
string pg_SVGpaths_directory;
string pg_textures_directory;
string pg_clips_directory;
string pg_shaders_directory;

// initial values in the scenario (before first scene)
ScenarioValue pg_InitialValuesInterpVar[PG_MAX_SCENARIOS][_MaxInterpVarIDs];
// rank of the scenario variable in the list of variables generated by python
int pg_ConfigScenarioVarRank[PG_MAX_SCENARIOS][_MaxInterpVarIDs];
// var IDs in scenarios in the order in which they appear in the scenario
string pg_ConfigScenarioVarIDs[PG_MAX_SCENARIOS][_MaxInterpVarIDs];
// number of vars in the scenario file
int pg_ScenarioVarNb[PG_MAX_SCENARIOS] = { 0 };
// last value shipped to the GUI (PD)
ScenarioValue pg_LastGUIShippedValuesInterpVar[PG_MAX_SCENARIOS][_MaxInterpVarIDs];

// current working directory
std::string pg_cwd;

/////////////////////////////////////////////////////
// Default values for global variables
/////////////////////////////////////////////////////
pg_WindowData::pg_WindowData( void ) {
  glutID = -1;
}

pg_WindowData::~pg_WindowData(void) {
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
// DATA TYPE CONVERSION
//////////////////////////////////////////////////////////////////////////////////////////////////////

float pg_stof(string str) {
	float f = 0.f;
	try {
		f = std::stof(str);
	}
	catch (const std::invalid_argument&) {
		sprintf(pg_errorStr, "Error: float argument is invalid (%s)\n", str.c_str()); pg_ReportError(pg_errorStr); throw 50;
	}
	catch (const std::out_of_range&) {
		sprintf(pg_errorStr, "Error: float argument is out of range (%s)\n", str.c_str()); pg_ReportError(pg_errorStr); throw 50;
	}
	catch (const std::exception& e) {
		sprintf(pg_errorStr, "Error: float argument is incorrect (%s): %s\n", str.c_str(), e.what()); pg_ReportError(pg_errorStr); throw 50;
	}
	return f;
}

int pg_stoi(string str) {
	int i = 0;
	try {
		i = std::stoi(str);
	}
	catch (const std::invalid_argument&) {
		sprintf(pg_errorStr, "Error: int argument is invalid (%s)\n", str.c_str()); pg_ReportError(pg_errorStr); throw 50;
	}
	catch (const std::out_of_range&) {
		sprintf(pg_errorStr, "Error: int argument is out of range (%s)\n", str.c_str()); pg_ReportError(pg_errorStr); throw 50;
	}
	catch (const std::exception& e) {
		sprintf(pg_errorStr, "Error: int argument is incorrect (%s): %s\n", str.c_str(), e.what()); pg_ReportError(pg_errorStr); throw 50;
	}
	return i;
}

double pg_stod(string str) {
	double d = 0.;
	try {
		d = std::stod(str);
	}
	catch (const std::invalid_argument&) {
		sprintf(pg_errorStr, "Error: double argument is invalid (%s)\n", str.c_str()); pg_ReportError(pg_errorStr); throw 50;
	}
	catch (const std::out_of_range&) {
		sprintf(pg_errorStr, "Error: double argument is out of range (%s)\n", str.c_str()); pg_ReportError(pg_errorStr); throw 50;
	}
	catch (const std::exception& e) {
		sprintf(pg_errorStr, "Error: double argument is incorrect (%s): %s\n", str.c_str(), e.what()); pg_ReportError(pg_errorStr); throw 50;
	}
	return d;
}

void pg_stringstreamStoreLine(std::stringstream *sstream, std::string *line) {
	(*sstream).clear();
	if ((*line).find('\t') == std::string::npos) {
		std::replace((*line).begin(), (*line).end(), ',', ' ');
	}
	//printf("%s\n", (* line).c_str());
	(*sstream).str((*line));
}

double pg_stringToDuration(string percentOrAbsoluteDuration, double full_length, int ind_scene, int ind_var) {
	double returnedPercent = 0.f;
	if (percentOrAbsoluteDuration.back() == 's') {
		percentOrAbsoluteDuration.resize(size_t(percentOrAbsoluteDuration.size() - 1));
		returnedPercent = pg_stof(percentOrAbsoluteDuration);
		if (returnedPercent < 0 || returnedPercent > full_length) {
			sprintf(pg_errorStr, "Error: in scene %d var %d absolute duration %s negative or greater than full scene duration %.2f\n", ind_scene, ind_var, (percentOrAbsoluteDuration + "s").c_str(), full_length); pg_ReportError(pg_errorStr); throw 50;
		}
		if (full_length != 0.f) {
			returnedPercent /= full_length;
		}
	}
	else {
		returnedPercent = pg_stof(percentOrAbsoluteDuration);
		if (returnedPercent < 0 || returnedPercent > 1.f) {
			sprintf(pg_errorStr, "Error: in scene %d var %d relative duration %s negative or greater than 1.\n", ind_scene, ind_var, percentOrAbsoluteDuration.c_str()); pg_ReportError(pg_errorStr); throw 50;
		}
	}
	return min(max(float(returnedPercent), 0.f), 1.f);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////
// PATH COMPLETION
//////////////////////////////////////////////////////////////////////////////////////////////////////

bool pg_isFullPath(string dir_or_filename) {
	if (dir_or_filename.length() > 0
		&& (dir_or_filename.find(':') != std::string::npos
			|| dir_or_filename[0] == '/')) {
		return true;
	}
	else {
		return false;
	}
}
void pg_completeToFullPath(string &dir_or_filename) {
	if (!pg_isFullPath(dir_or_filename)) {
		if (pg_cwd[pg_cwd.length() - 1] == '/') {
			dir_or_filename = pg_cwd + dir_or_filename;
		}
		else {
			dir_or_filename = pg_cwd + "/" + dir_or_filename;
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
// WORKING WINDOW SIZE CALCULATION
//////////////////////////////////////////////////////////////////////////////////////////////////////

// WINDTH/HEIGHT TO WORKING DIMENSIONS OF MAIN WINDOW
void pg_setWindowDimensions(void) {
	if (double_window && (PG_WINDOW_WIDTH > 1920)) {
		if (wide_screen) {
			pg_workingWindow_width = PG_WINDOW_WIDTH * 3 / 7;
		}
		else {
			pg_workingWindow_width = PG_WINDOW_WIDTH / 2;
		}
		pg_rightWindowVMargin = (PG_WINDOW_WIDTH - 2 * pg_workingWindow_width) / 2;
	}
	else {
		pg_workingWindow_width = PG_WINDOW_WIDTH;
		pg_rightWindowVMargin = 0;
	}
	// looks for the smallest powers of 2 for width and height
	pg_workingWindow_width_powerOf2 = 1;
	while (pg_workingWindow_width_powerOf2 < pg_workingWindow_width)
		pg_workingWindow_width_powerOf2 *= 2;
	pg_window_height_powerOf2 = 1;
	while (pg_window_height_powerOf2 < PG_WINDOW_HEIGHT)
		pg_window_height_powerOf2 *= 2;
	pg_window_width_powerOf2 = 1;
	while (pg_window_width_powerOf2 < PG_WINDOW_WIDTH)
		pg_window_width_powerOf2 *= 2;
	pg_workingWindow_width_powerOf2_ratio =
		float(pg_workingWindow_width) / float(pg_workingWindow_width_powerOf2);
	pg_window_height_powerOf2_ratio =
		float(PG_WINDOW_HEIGHT) / float(pg_window_height_powerOf2);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////
// SCENARIO PARSING
//////////////////////////////////////////////////////////////////////////////////////////////////////

// UTIL: VAR ID TO RANK
int pg_varID_to_rank(string var_ID, int indConfig) {
	for (int indP = 0; indP < _MaxInterpVarIDs; indP++) {
		if (pg_FullScenarioVarStrings[indP] == var_ID) {
			return indP;
		}
	}
	sprintf(pg_errorStr, "Error: scenario variable %s of configuration %d not found in the variable string list generated by python generator\n", var_ID.c_str(), indConfig); pg_ReportError(pg_errorStr); throw 50;
	return -1;
}

////// COLOR PALETTES
void pg_parseScenarioColorPalettes(std::ifstream& scenarioFin, int indScenario) {
	std::stringstream  sstream;
	string line;
	string ID;
	string temp;

	////////////////////////////
	// palettes markup
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	sstream >> ID; // string palette_colors
	if (ID.compare("palette_colors") != 0) {
		sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"palette_colors\" not found! (instead \"%s\")\n", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
	}

	// palettes parsing
	while (true) {
		std::getline(scenarioFin, line);
		pg_stringstreamStoreLine(&sstream, &line);
		sstream >> ID; // string texture
		if (ID.compare("/palette_colors") == 0) {
			break;
		}
		else if (ID.compare("palette") != 0) {
			sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"palette\" not found! (instead \"%s\")\n", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
		}

		array<float, 9> paletteData;
		sstream >> ID; // palette ID
		for (int indColorBandpass = 0; indColorBandpass < 3; indColorBandpass++) {
			for (int indColorChannel = 0; indColorChannel < 3; indColorChannel++) {
				sstream >> paletteData[indColorBandpass * 3 + indColorChannel];
				paletteData[indColorBandpass * 3 + indColorChannel] /= 255.f;
			}
		}
		Palette apalette(ID, paletteData);
		pg_Palettes[indScenario].push_back(apalette);
		// std::cout << "palettes : " << indPalette << " " <<  pen_palettes_names[indPalette] << " " << pen_palettes_values[indPalette] << "\n";
	}
	// std::cout << "line: " << line << "\n";
	// std::cout << "Nb palettes : " << pg_Palettes[indScenario].size() <<  "\n";
}

////// COLOR PRESETS
void pg_parseScenarioColorPresets(std::ifstream& scenarioFin, int indScenario) {
	std::stringstream  sstream;
	string line;
	string ID;
	string temp;

	////////////////////////////
	// Number of presets
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	sstream >> ID; // string color_presets
	if (ID.compare("color_presets") != 0) {
		sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"color_presets\" not found! (instead \"%s\")\n", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
	}

	while(true) {
		std::getline(scenarioFin, line);
		pg_stringstreamStoreLine(&sstream, &line);
		sstream >> ID; // string texture
		if (ID.compare("/color_presets") == 0) {
			break;
		}
		else if (ID.compare("preset") != 0) {
			sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"preset\" not found! (instead \"%s\")\n", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
		}

		Color presetColor;
		sstream >> ID; // preset ID
		sstream >> presetColor.color;           // hue
		sstream >> presetColor.grey;            // color to white interpolation
		sstream >> presetColor.alpha;           // transparency, translated into to black interpolation for RGB conversion wo transparency
		ColorPreset preset(ID, presetColor);
		pg_ColorPresets[indScenario].push_back(preset);
		//std::cout << "palettes : " << indPalette << " " <<  pen_colorPresets_names[indPalette] << " " << pg_colorPreset_values[indPalette] << "\n";
	}
	// std::cout << "line: " << line << "\n";
	// std::cout << "Nb palettes : " << pg_ColorPresets[indScenario].size() <<  "\n";
}

////// RENDERING FILES (VIDEP, PNG, JPG, ClipArt...)
void pg_parseScenarioRenderingFiles(std::ifstream& scenarioFin, int indScenario) {
	std::stringstream  sstream;
	string line;
	string ID;
	string temp;

	// rendering_files
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	sstream >> ID;
	if (ID.compare("rendering_files") != 0) {
		sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"rendering_files\" not found! (instead \"%s\")", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
	}

	// TYPE
	std::getline(scenarioFin, line);
	// ID	begin	end	step	id	shots
	std::getline(scenarioFin, line);

	// storing the Video capture values
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	sstream >> ID;
	if (ID.compare("VIDEO") != 0) {
		sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"VIDEO\" not found! (instead \"%s\")", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
	}
	// not used currently (instead video capture by external program)

	// storing the Svg capture values
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	sstream >> ID;
	if (ID.compare("SVG") != 0) {
		sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"SVG\" not found! (instead \"%s\")", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
	}
	if (indScenario == 0) {
		sstream >> pg_Svg_Capture_param.beginSvg;
		sstream >> pg_Svg_Capture_param.endSvg;
		sstream >> temp;
		if (temp.back() == 's') {
			temp.resize(size_t(temp.size() - 1));
			pg_Svg_Capture_param.stepSvgInSeconds = pg_stof(temp);
			pg_Svg_Capture_param.nextSvgCapture = -1.;
			pg_Svg_Capture_param.stepSvgInFrames = -1;
		}
		else {
			pg_Svg_Capture_param.stepSvgInFrames = pg_stoi(temp);
			pg_Svg_Capture_param.stepSvgInSeconds = -1.;
		}
		sstream >> pg_Svg_Capture_param.Svg_file_name;
		pg_Svg_Capture_param.outputSvg = !pg_Svg_Capture_param.Svg_file_name.empty();
		pg_Svg_Capture_param.indSvgSnapshot = 0;
	}

	// storing the Png capture values
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	sstream >> ID;
	if (ID.compare("PNG") != 0) {
		sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"PNG\" not found! (instead \"%s\")", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
	}
	if (indScenario == 0) {
		sstream >> pg_Png_Capture_param.beginPng;
		sstream >> pg_Png_Capture_param.endPng;
		sstream >> temp;
		if (temp.back() == 's') {
			temp.resize(size_t(temp.size() - 1));
			pg_Png_Capture_param.stepPngInSeconds = pg_stof(temp);
			pg_Png_Capture_param.nextPngCapture = -1.;
			pg_Png_Capture_param.stepPngInFrames = -1;
		}
		else {
			pg_Png_Capture_param.stepPngInFrames = pg_stoi(temp);
			pg_Png_Capture_param.stepPngInSeconds = -1.;
		}
		sstream >> pg_Png_Capture_param.Png_file_name;
		pg_Png_Capture_param.outputPng = !pg_Png_Capture_param.Png_file_name.empty();
		pg_Png_Capture_param.indPngSnapshot = 0;
	}

	// storing the Jpg capture values
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	sstream >> ID;
	if (ID.compare("JPG") != 0) {
		sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"JPG\" not found! (instead \"%s\")", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
	}
	if (indScenario == 0) {
		sstream >> pg_Jpg_Capture_param.beginJpg;
		sstream >> pg_Jpg_Capture_param.endJpg;
		sstream >> temp;
		if (temp.back() == 's') {
			temp.resize(size_t(temp.size() - 1));
			pg_Jpg_Capture_param.stepJpgInSeconds = pg_stof(temp);
			pg_Jpg_Capture_param.nextJpgCapture = -1.;
			pg_Jpg_Capture_param.stepJpgInFrames = -1;
		}
		else {
			pg_Jpg_Capture_param.stepJpgInFrames = pg_stoi(temp);
			pg_Jpg_Capture_param.stepJpgInSeconds = -1.;
		}

		sstream >> pg_Jpg_Capture_param.Jpg_file_name;
		pg_Jpg_Capture_param.outputJpg = !pg_Jpg_Capture_param.Jpg_file_name.empty();
		pg_Jpg_Capture_param.indJpgSnapshot = 0;
	}

	// /rendering_files
	std::getline(scenarioFin, line);
}

////// DIRECTORIES
void pg_parseScenarioDirectories(std::ifstream& scenarioFin, int indScenario) {
	std::stringstream  sstream;
	string line;
	string ID;
	string temp;

	// directories
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	sstream >> ID;
	if (ID.compare("directories") != 0) {
		sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"directories\" not found! (instead \"%s\")", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
	}
	// default value
	pg_scripts_directory = "./Data/core-data/scripts/";
	pg_videos_directory = "./Data/core-data/videos/";
	pg_soundtracks_directory = "./Data/core-data/soundtracks/";
	pg_cliparts_directory = "./Data/core-data/ClipArts/";
	pg_diaporamas_directory = "./Data/core-data/images/";
	pg_meshes_directory = "./Data/core-data/meshes/";
	pg_messages_directory = "./Data/core-data/messages/";
	pg_SVGpaths_directory = "./Data/core-data/SVGs/";
	pg_textures_directory = "./Data/core-data/textures/";
	pg_shaders_directory = "./Projects/shaders/";
	while (true) {
		std::getline(scenarioFin, line);
		pg_stringstreamStoreLine(&sstream, &line);
		sstream >> ID; // string "client" or end with "/udp_remote_client"
		if (ID.compare("/directories") == 0) {
			break;
		}
		else if (ID.compare("snapshots") == 0) {
			if (indScenario == 0) {
				sstream >> pg_snapshots_dir_path_prefix; // string of the snapshots and log file directory
			}
		}
		else if (ID.compare("screen_font") == 0) {
			if (indScenario == 0) {
				sstream >> pg_texDataScreenFont.texture_fileName;
				pg_completeToFullPath(pg_texDataScreenFont.texture_fileName);
			}
		}
		else if (ID.compare("scripts") == 0) {
			if (indScenario == 0) {
				sstream >> pg_scripts_directory;
				pg_completeToFullPath(pg_scripts_directory);
			}
		}
		else if (ID.compare("videos") == 0) {
			if (indScenario == 0) {
				sstream >> pg_videos_directory;
				pg_completeToFullPath(pg_videos_directory);
			}
		}
		else if (ID.compare("soundtracks") == 0) {
			if (indScenario == 0) {
				sstream >> pg_soundtracks_directory;
				pg_completeToFullPath(pg_soundtracks_directory);
			}
		}
		else if (ID.compare("cliparts") == 0) {
			if (indScenario == 0) {
				sstream >> pg_cliparts_directory;
				pg_completeToFullPath(pg_cliparts_directory);
			}
		}
		else if (ID.compare("diaporamas") == 0) {
			if (indScenario == 0) {
				sstream >> pg_diaporamas_directory;
				pg_completeToFullPath(pg_diaporamas_directory);
			}
		}
		else if (ID.compare("meshes") == 0) {
			if (indScenario == 0) {
				sstream >> pg_meshes_directory;
				pg_completeToFullPath(pg_meshes_directory);
			}
		}
		else if (ID.compare("messages") == 0) {
			if (indScenario == 0) {
				sstream >> pg_messages_directory;
				pg_completeToFullPath(pg_messages_directory);
			}
		}
		else if (ID.compare("SVGpaths") == 0) {
			if (indScenario == 0) {
				sstream >> pg_SVGpaths_directory;
				pg_completeToFullPath(pg_SVGpaths_directory);
			}
		}
		else if (ID.compare("textures") == 0) {
			if (indScenario == 0) {
				sstream >> pg_textures_directory;
				pg_completeToFullPath(pg_textures_directory);
			}
		}
		else if (ID.compare("clips") == 0) {
			if (indScenario == 0) {
				sstream >> pg_clips_directory;
				pg_completeToFullPath(pg_clips_directory);
			}
		}
		else if (ID.compare("shaders") == 0) {
			if (indScenario == 0) {
				sstream >> pg_shaders_directory;
				pg_completeToFullPath(pg_shaders_directory);
			}
		}
		else {
			sprintf(pg_errorStr, "Error: incorrect configuration \"%s\" is an unknown directory path type in configuration file (directories)", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
// FULL SCENARIO PARSING
//////////////////////////////////////////////////////////////////////////////////////////////////////  

// to be called once after parsing
void pg_saveInitialTimesAndDurations(int indScenario) {
	for (Scene& scene : pg_Scenario[indScenario]) {
		scene.scene_originalDuration = scene.scene_duration;
		scene.scene_originalInitial_time = scene.scene_initial_time;
		scene.scene_originalFinal_time = scene.scene_final_time;
	}
}

void pg_parseScenarioFile(std::ifstream& scenarioFin, int indScenario) {

	////////////////////////////
	////// CONFIGURATION VARIABLE INITIALIZATION
	string line;
	string ID;
	string temp;
	string temp2;
	string temp3;
	std::stringstream  sstream;

	int indVar;

	//////////////////////////////////////////////////////////
	// READS SCENARIO FILE

	// RANK
	std::getline(scenarioFin, line);
	// VERBATIM
	std::getline(scenarioFin, line);
	// TYPE
	std::getline(scenarioFin, line);
	// ID
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	int nb_vars = 0;
	// initializations for scenario variables: value arrray and active vars
	for (int indP = 0; indP < _MaxInterpVarIDs; indP++) {
		pg_FullScenarioActiveVars[indScenario][indP] = false;
		if (pg_FullScenarioVarIndiceRanges[indP][0] == -1) {
			pg_InitialValuesInterpVar[indScenario][indP].init_ScenarioValue(0., "", NULL, 0);
			pg_LastGUIShippedValuesInterpVar[indScenario][indP].init_ScenarioValue(0., "", NULL, 0);
		}
		else {
			pg_InitialValuesInterpVar[indScenario][indP].init_ScenarioValue(0., "", NULL, pg_FullScenarioVarIndiceRanges[indP][1]);
			pg_LastGUIShippedValuesInterpVar[indScenario][indP].init_ScenarioValue(0., "", NULL, pg_FullScenarioVarIndiceRanges[indP][1]);
		}
	}

	// loop over all the variables of the full scenario, but only the active variables for the current configuration are used, 
	// the other ones keep a constant initial value of the full scenario
	for (int indP = 0; indP < _MaxInterpVarIDs; indP++) {
		if (sstream.eof()) {
			break;
			//sprintf(pg_errorStr, "Error: scenario (index %d) of configuration %d missing fewer variables in scenario files than expected\n", indP, indScenario); pg_ReportError(pg_errorStr); throw 50;
		}
		sstream >> temp;
		// first item is "ID"
		if (indP > 0) {
			// the index of the current scenario var into the global list of variables cumulated from all the scenarios
			indVar = pg_varID_to_rank(temp, indScenario);
			pg_ConfigScenarioVarRank[indScenario][indP - 1] = indVar;
			pg_ConfigScenarioVarIDs[indScenario][indP - 1] = temp;
			if (indVar == -1) {
				sprintf(pg_errorStr, "Error: scenario variable %s (index %d) of configuration %d not found in the variable list generated by python generator\n", temp.c_str(), indP, indScenario); pg_ReportError(pg_errorStr); throw 50;
			}
			pg_FullScenarioActiveVars[indScenario][indVar] = true;
			nb_vars++;
		}
	}

	// stores the number of scenario variabes
	pg_ScenarioVarNb[indScenario] = nb_vars;
	//std::cout << "configuration #" << indScenario << " nb vars " << pg_ScenarioVarNb[indScenario] << "\n";
	//printf("Loading scenario %s with %d variables\n", pg_ScenarioFileNames[indScenario].c_str(), pg_ScenarioVarNb[indScenario]);

	// CALLBACKS
	std::getline(scenarioFin, line);
	// GUI
	std::getline(scenarioFin, line);
	// SHADER
	std::getline(scenarioFin, line);
	// PULSE
	std::getline(scenarioFin, line);

	// initial_values
	std::getline(scenarioFin, line);
	// storing the initial values
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	for (int indP = 0; indP < pg_ScenarioVarNb[indScenario]; indP++) {
		indVar = pg_ConfigScenarioVarRank[indScenario][indP];
		if (pg_FullScenarioActiveVars[indScenario][indVar]) {
			pg_ConfigScenarioVarRank[indScenario][indVar];
			if (sstream.eof()) {
				sprintf(pg_errorStr, "Error: missing initial value %s %d\n", temp.c_str(), indVar); pg_ReportError(pg_errorStr); throw 50;
			}
			sstream >> temp;
			if (pg_FullScenarioVarTypes[indVar] != _pg_string) {
				// dimension 1 variable: number
				if (pg_FullScenarioVarIndiceRanges[indVar][0] == -1) {
					bool has_only_digits = (temp.find_first_not_of("0123456789-.E") == string::npos);
					if (!has_only_digits) {
						sprintf(pg_errorStr, "Error: non numeric variable initial value for var %d (%s)\n", indVar, pg_FullScenarioVarStrings[indVar].c_str()); pg_ReportError(pg_errorStr); throw 50;
					}
					pg_InitialValuesInterpVar[indScenario][indVar].val_num = pg_stod(temp);
				}
				// array
				else {
					unsigned int size_of_array = pg_FullScenarioVarIndiceRanges[indVar][1] - pg_FullScenarioVarIndiceRanges[indVar][0];
					vector<string> values = pg_split_string(temp, '/');
					if (values.size() != size_of_array) {
						sprintf(pg_errorStr, "Error: numeric array variable expects %d initial value not %d (%s[%d..%d])\n", size_of_array, values.size(), pg_FullScenarioVarStrings[indVar].c_str(), pg_FullScenarioVarIndiceRanges[indVar][0], pg_FullScenarioVarIndiceRanges[indVar][1]); pg_ReportError(pg_errorStr); throw 50;
					}
					int indVect = 0;
					for (int index = pg_FullScenarioVarIndiceRanges[indVar][0]; index < pg_FullScenarioVarIndiceRanges[indVar][1]; index++) {
						pg_InitialValuesInterpVar[indScenario][indVar].val_array[index] = pg_stod(values[indVect]);
						indVect++;
					}
				}
			}
			else {
				pg_InitialValuesInterpVar[indScenario][indVar].val_string = temp;
			}
			//std::cout << indP << " " << pg_InitialValuesInterpVar[indScenario][indP] << " \n";
			pg_LastGUIShippedValuesInterpVar[indScenario][indVar].const_value(MAXFLOAT);
		}
	}
	// checks that the number of variables is what is expected
	//sstream >> ID;
	if (!sstream.eof()) {
		sprintf(pg_errorStr, "Error: too many initial variable values %s: expected %d\n", sstream.str().c_str(), pg_ScenarioVarNb[indScenario]); pg_ReportError(pg_errorStr); throw 50;
	}

	//std::cout << "\n";
	// /initial_values
	std::getline(scenarioFin, line);


	////////////////////////////
	////// SCENARIO
	// Number of scenes
	std::getline(scenarioFin, line);
	pg_stringstreamStoreLine(&sstream, &line);
	sstream >> ID; // string scenario

	pg_InterpolationScene.init_scene();
	pg_variable_param_input_type = new pg_Parameter_Input_Type[_MaxInterpVarIDs];
	for (int indP = 0; indP < pg_ScenarioVarNb[indScenario]; indP++) {
		indVar = pg_ConfigScenarioVarRank[indScenario][indP];
		if (pg_FullScenarioActiveVars[indScenario][indVar]) {
			pg_variable_param_input_type[indVar] = pg_enum_PG_SCENARIO;
		}
	}

	printf("Loading scenario %s with %d variables\n", pg_ScenarioFileNames[indScenario].c_str(), pg_ScenarioVarNb[indScenario]);
	int nbScenesInScenario = 0;
	while(true) {
		std::getline(scenarioFin, line);
		pg_stringstreamStoreLine(&sstream, &line);
		sstream >> ID; // string scene
		if (ID.compare("/scenario") == 0) {
			break;
		}
		else if (ID.compare("scene") != 0) {
			sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"scene\" not found! (instead \"%s\")\n", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
		}
		
		Scene newScene;

		newScene.init_scene();

		sstream >> newScene.scene_IDs;
		std::cout << "scene: " << newScene.scene_IDs << "\n";
		sstream >> newScene.scene_duration;
		sstream >> temp;  // change_when_ends or prolong_when_ends
		if (temp.compare("change_when_ends") == 0) {
			newScene.scene_change_when_ends = true;
		}
		else if (temp.compare("prolong_when_ends") == 0) {
			newScene.scene_change_when_ends = false;
		}
		else {
			newScene.scene_change_when_ends = true;
			sprintf(pg_errorStr, "Error: one of strings expected as scene ending mode: \"change_when_ends\" or \"prolong_when_ends\" not \"%s\" for scene %d %s\n", temp.c_str(), nbScenesInScenario, newScene.scene_IDs.c_str()); pg_ReportError(pg_errorStr); throw 50;
		}
		// second and third comments possibly displayed on the interface to help the user
		if (!sstream.eof()) {
			sstream >> newScene.scene_Msg1;
		}
		else {
			newScene.scene_Msg1 = "";
		}
		if (!sstream.eof()) {
			sstream >> newScene.scene_Msg2;
		}
		else {
			newScene.scene_Msg2 = "";
		}

		//std::cout << "duration : " << 
		//  newScene.scene_duration << " sc #" << nbScenesInScenario << "\n";

		if (newScene.scene_duration <= 0.0) {
			sprintf(pg_errorStr, "Error: null scene #%d duration [%f]!", nbScenesInScenario + 1, newScene.scene_duration); pg_ReportError(pg_errorStr); throw 50;
		}
		if (nbScenesInScenario > 0) {
			newScene.scene_initial_time = pg_Scenario[indScenario][nbScenesInScenario - 1].scene_final_time;
		}
		else {
			newScene.scene_initial_time = 0.0;
		}
		newScene.scene_final_time
			= newScene.scene_initial_time + newScene.scene_duration;

		// verbatim
		std::getline(scenarioFin, line);
		// var comment
		std::getline(scenarioFin, line);
		// std::cout << "var comment: " << line << "\n";

		// storing the initial values
		std::getline(scenarioFin, line);
		pg_stringstreamStoreLine(&sstream, &line);
		//std::cout << "line :" << line;
		//std::cout << "\ninitial values :\n";
		for (int indP = 0; indP < pg_ScenarioVarNb[indScenario]; indP++) {
			indVar = pg_ConfigScenarioVarRank[indScenario][indP];
			if (pg_FullScenarioActiveVars[indScenario][indVar]) {
				if (sstream.eof()) {
					sprintf(pg_errorStr, "Error: missing initial value in scene %d var %d (%s)\n",
						nbScenesInScenario + 1, indVar, pg_FullScenarioVarMessages[indVar].c_str()); pg_ReportError(pg_errorStr); throw 50;
				}
				sstream >> temp;
				if (pg_FullScenarioVarTypes[indVar] == _pg_string) {
					newScene.scene_initial_parameters[indVar].val_string = temp;
				}
				else {
					// dimension 1 variable: number
					if (pg_FullScenarioVarIndiceRanges[indVar][0] == -1) {
						bool has_only_digits = (temp.find_first_not_of("0123456789-.E") == string::npos);
						if (!has_only_digits) {
							sprintf(pg_errorStr, "Error: non numeric variable initial value in scene %d var %d (%s) type %d\n",
								nbScenesInScenario + 1, indVar, pg_FullScenarioVarStrings[indVar].c_str(), pg_FullScenarioVarTypes[indVar]); pg_ReportError(pg_errorStr); throw 50;
						}
						else {
							newScene.scene_initial_parameters[indVar].val_num = pg_stod(temp);
						}
					}
					// array
					else {
						unsigned int size_of_array = pg_FullScenarioVarIndiceRanges[indVar][1] - pg_FullScenarioVarIndiceRanges[indVar][0];
						vector<string> values = pg_split_string(temp, '/');
						if (values.size() != size_of_array) {
							sprintf(pg_errorStr, "Error: numeric array variable expects %d scene initial values not %d (%s[%d..%d])\n", size_of_array, values.size(), pg_FullScenarioVarStrings[indVar].c_str(), pg_FullScenarioVarIndiceRanges[indVar][0], pg_FullScenarioVarIndiceRanges[indVar][1]); pg_ReportError(pg_errorStr); throw 50;
						}
						int indVect = 0;
						for (int index = pg_FullScenarioVarIndiceRanges[indVar][0]; index < pg_FullScenarioVarIndiceRanges[indVar][1]; index++) {
							newScene.scene_initial_parameters[indVar].val_array[index] = pg_stod(values[indVect]);
							indVect++;
						}
					}
				}
			}
		}
		// checks that the number of variables is what is expected
		//sstream >> ID;
		if (!sstream.eof()) {
			sprintf(pg_errorStr, "Error: too many initial variable values in scene %d (%s)\n", nbScenesInScenario + 1, sstream.str().c_str()); pg_ReportError(pg_errorStr); throw 50;
		}

		// storing the final values
		std::getline(scenarioFin, line);
		pg_stringstreamStoreLine(&sstream, &line);
		//std::cout << "line :" << line;
		//std::cout << "\nfinal values :\n";

		for (int indP = 0; indP < pg_ScenarioVarNb[indScenario]; indP++) {
			indVar = pg_ConfigScenarioVarRank[indScenario][indP];
			if (pg_FullScenarioActiveVars[indScenario][indVar]) {
				if (sstream.eof()) {
					sprintf(pg_errorStr, "Error: missing final value in scene %d var %d (%s)\n", nbScenesInScenario + 1, indVar, temp.c_str()); pg_ReportError(pg_errorStr); throw 50;
				}
				sstream >> temp;
				if (pg_FullScenarioVarTypes[indVar] == _pg_string) {
					newScene.scene_final_parameters[indVar].val_string = temp;
				}
				else {
					// dimension 1 variable: number
					if (pg_FullScenarioVarIndiceRanges[indVar][0] == -1) {
						bool has_only_digits = (temp.find_first_not_of("0123456789-.E") == string::npos);
						if (!has_only_digits) {
							sprintf(pg_errorStr, "Error: non numeric variable initial value in scene %d var %d (%s) type %d\n",
								nbScenesInScenario + 1, indVar, pg_FullScenarioVarStrings[indVar].c_str(), pg_FullScenarioVarTypes[indVar]); pg_ReportError(pg_errorStr); throw 50;
						}
						else {
							newScene.scene_final_parameters[indVar].val_num = pg_stod(temp);
						}
					}
					// array
					else {
						unsigned int size_of_array = pg_FullScenarioVarIndiceRanges[indVar][1] - pg_FullScenarioVarIndiceRanges[indVar][0];
						vector<string> values = pg_split_string(temp, '/');
						if (values.size() != size_of_array) {
							sprintf(pg_errorStr, "Error: numeric array variable expects %d scene initial values not %d (%s[%d..%d])\n", size_of_array, values.size(), pg_FullScenarioVarStrings[indVar].c_str(), pg_FullScenarioVarIndiceRanges[indVar][0], pg_FullScenarioVarIndiceRanges[indVar][1]); pg_ReportError(pg_errorStr); throw 50;
						}
						int indVect = 0;
						for (int index = pg_FullScenarioVarIndiceRanges[indVar][0]; index < pg_FullScenarioVarIndiceRanges[indVar][1]; index++) {
							newScene.scene_final_parameters[indVar].val_array[index] = pg_stod(values[indVect]);
							indVect++;
						}
					}
				}
			}
			// std::cout << scene_final_parameters[nbScenesInScenario][indVar].val_num << " ";
		}
		// checks that the number of variables is what is expected
		//sstream >> ID;
		if (!sstream.eof()) {
			sprintf(pg_errorStr, "Error: too many final variable values in scene %d\n", nbScenesInScenario + 1); pg_ReportError(pg_errorStr); throw 50;
		}

		std::getline(scenarioFin, line);
		pg_stringstreamStoreLine(&sstream, &line);
		//printf("line interp %s\n", line.c_str());

		// storing the interpolation mode
		for (int indP = 0; indP < pg_ScenarioVarNb[indScenario]; indP++) {
			indVar = pg_ConfigScenarioVarRank[indScenario][indP];
			if (pg_FullScenarioActiveVars[indScenario][indVar]) {
				char valCh = 0;
				char valCh2 = 0;
				string vals, val2s;
				float val3;

				newScene.scene_interpolations[indVar].offSet = 0.0;
				newScene.scene_interpolations[indVar].duration = 1.0;
				if (pg_FullScenarioVarIndiceRanges[indVar][0] == -1) {
					newScene.scene_interpolations[indVar].midTermValue
						= 0.5 * (newScene.scene_initial_parameters[indVar].val_num
							+ newScene.scene_final_parameters[indVar].val_num);
				}
				else {
					for (int index = pg_FullScenarioVarIndiceRanges[indVar][0]; index < pg_FullScenarioVarIndiceRanges[indVar][1]; index++) {
						newScene.scene_interpolations[indVar].midTermValueArray[index]
							= 0.5 * (newScene.scene_initial_parameters[indVar].val_array[index]
								+ newScene.scene_final_parameters[indVar].val_array[index]);
					}
				}

				if (sstream.eof()) {
					sprintf(pg_errorStr, "Error: missing interpolation value in scene %d (%s) var %d (%s)\n",
						nbScenesInScenario + 1, newScene.scene_IDs.c_str(), indVar + 1, pg_FullScenarioVarMessages[indVar].c_str()); pg_ReportError(pg_errorStr); throw 50;
				}
				sstream >> std::skipws >> temp;
				valCh = temp.at(0);
				//printf("valch %d %c temp %s\n", (int)valCh, valCh, temp.c_str());
				if (temp.length() > 1) {
					valCh2 = temp.at(1);
					if (valCh2 != 'k') {
						sprintf(pg_errorStr, "Error: only k modifier is allowed on interpolation mode, not %c for %c interpolation in scene %d var %d\n", 
							valCh2, valCh, nbScenesInScenario + 1, indVar + 1); pg_ReportError(pg_errorStr); throw 50;
					}
				}
				else {
					valCh2 = ' ';
				}

				// l: value interpolates linearly between initial and final value from 0.0% to 1.0%
				// L: value is initial from 0.0% until offset, 
				// interpolates linearly between initial and final value from offset to offset + duration
				// is final value between offset + duration and 1.0%
				if (valCh == 'l' || valCh == 'L') {
					newScene.scene_interpolations[indVar].interpolation_mode = pg_enum_linear_interpolation;
					if (valCh2 == ' ') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_enum_scenario_initial;
					}
					else if (valCh2 == 'k') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_current_value;
					}
					if (valCh == 'L') {
						sstream >> vals;
						sstream >> val2s;
						double val = pg_stringToDuration(vals, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						double val2 = pg_stringToDuration(val2s, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						if (val < 0.0 || val2 < 0.0) {
							sprintf(pg_errorStr, "Error: one of values of L(inear) in scene %d var %d lower than 0.0: %.3f %.3f\n", nbScenesInScenario + 1, indVar + 1, val, val2); pg_ReportError(pg_errorStr); throw 50;
						}
						if (val <= 1.0) {
							newScene.scene_interpolations[indVar].offSet = val;
							if (float(val + val2) <= 1.00001f) {
								// deals with approximate values that can summ above 1.0
								if (float(val + val2) > 1.0f) {
									val2 = 1.0f - val;
								}
								newScene.scene_interpolations[indVar].duration = val2;
								if (newScene.scene_interpolations[indVar].duration <= 0.0) {
									sprintf(pg_errorStr, "Error: null L(inear) in scene %d var %d duration [%f]!", nbScenesInScenario + 1, indVar + 1, newScene.scene_interpolations[indVar].duration); pg_ReportError(pg_errorStr); throw 50;
								}
							}
							else {
								sprintf(pg_errorStr, "Error: total duration of L(inear) in scene %d var %d greater than 1.0: %.3f + %.3f\n", nbScenesInScenario + 1, indVar + 1, val, val2); pg_ReportError(pg_errorStr); throw 50;
							}
						}
						else {
							sprintf(pg_errorStr, "Error: offset value L(inear) in scene %d var %d greater than 1.0: %.3f\n", nbScenesInScenario + 1, indVar + 1, val); pg_ReportError(pg_errorStr); throw 50;
						}
						// std::cout << "L " << val << " " << val2 << " ";

					}

				}
				// c: value interpolates cosinely between initial and final value from 0.0% to 1.0%
				// C: value is initial from 0.0% until offset, 
				// interpolates cosinely between initial and final value from offset to offset + duration
				// is final value between offset + duration and 1.0%
				// COSINE INTERPOLATION
				else if (valCh == 'c' || valCh == 'C') {
					newScene.scene_interpolations[indVar].interpolation_mode = pg_enum_cosine_interpolation;
					if (valCh2 == ' ') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_enum_scenario_initial;
					}
					else if (valCh2 == 'k') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_current_value;
					}
					if (valCh == 'C') {
						sstream >> vals;
						sstream >> val2s;
						double val = pg_stringToDuration(vals, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						double val2 = pg_stringToDuration(val2s, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						if (val < 0.0 || val2 < 0.0) {
							sprintf(pg_errorStr, "Error: one of values of C(osine) in scene %d var %d lower than 0.0: %.3f %.3f\n", nbScenesInScenario + 1, indVar + 1, val, val2); pg_ReportError(pg_errorStr); throw 50;
						}
						if (val <= 1.0) {
							newScene.scene_interpolations[indVar].offSet = val;
							// deals with approximate values that can summ above 1.0
							if (float(val + val2) <= 1.00001f) {
								if (float(val + val2) > 1.0f) {
									val2 = 1.0f - val;
								}
								newScene.scene_interpolations[indVar].duration = val2;
								if (newScene.scene_interpolations[indVar].duration <= 0.0) {
									sprintf(pg_errorStr, "Error: null C(osine) in scene %d var %d duration [%f]!", nbScenesInScenario + 1, indVar + 1, newScene.scene_interpolations[indVar].duration); pg_ReportError(pg_errorStr); throw 50;
								}
							}
							else {
								sprintf(pg_errorStr, "Error: total duration of C(osine) in scene %d var %d greater than 1.0: %.3f + %.3f\n", nbScenesInScenario + 1, indVar + 1, val, val2); pg_ReportError(pg_errorStr); throw 50;
							}
						}
						else {
							sprintf(pg_errorStr, "Error: offset value C(osine) in scene %d var %d greater than 1.0: %.3f\n", nbScenesInScenario + 1, indVar + 1, val); pg_ReportError(pg_errorStr); throw 50;
						}
					}
				}
				// z: value interpolates cosinely between initial and final value from 0.0% to 1.0%
				// Z: value is initial from 0.0% until offset, 
				// Beizer approximated with a cosine and a non linear input 3x^2-2x^3
				// BEZIER INTERPOLATION
				else if (valCh == 'z' || valCh == 'Z') {
					newScene.scene_interpolations[indVar].interpolation_mode = pg_enum_bezier_interpolation;
					if (valCh2 == ' ') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_enum_scenario_initial;
					}
					else if (valCh2 == 'k') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_current_value;
					}
					if (valCh == 'Z') {
						sstream >> vals;
						sstream >> val2s;
						double val = pg_stringToDuration(vals, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						double val2 = pg_stringToDuration(val2s, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						if (val < 0.0 || val2 < 0.0) {
							sprintf(pg_errorStr, "Error: one of values of Z(Bezier) in scene %d var %d lower than 0.0: %.3f %.3f\n", nbScenesInScenario + 1, indVar + 1, val, val2); pg_ReportError(pg_errorStr); throw 50;
						}
						if (val <= 1.0) {
							newScene.scene_interpolations[indVar].offSet = double(val);
							// deals with approximate values that can summ above 1.0
							if (float(double(val) + double(val2)) <= 1.00001) {
								if (float(double(val) + double(val2)) > 1.0) {
									val2 = 1.0f - val;
								}
								newScene.scene_interpolations[indVar].duration = val2;
								if (newScene.scene_interpolations[indVar].duration <= 0.0) {
									sprintf(pg_errorStr, "Error: null Z(Bezier) in scene %d var %d duration [%f]!", nbScenesInScenario + 1, indVar + 1, newScene.scene_interpolations[indVar].duration); pg_ReportError(pg_errorStr); throw 50;
								}
							}
							else {
								sprintf(pg_errorStr, "Error: total duration of Z(Bezier) in scene %d var %d greater than 1.0: %.3f + %.3f\n", nbScenesInScenario + 1, indVar + 1, val, val2); pg_ReportError(pg_errorStr); throw 50;
							}
						}
						else {
							sprintf(pg_errorStr, "Error: offset value Z(Bezier) in scene %d var %d greater than 1.0: %.3f\n", nbScenesInScenario + 1, indVar + 1, val); pg_ReportError(pg_errorStr); throw 50;
						}
					}
				}
				// e: value interpolates exponentially between initial and final value from 0.0% to 1.0%
				// E: value is initial from 0.0% until offset, 
				// exponential interpolation: alpha ^ exponent
				// EXPONENTIAL INTERPOLATION
				else if (valCh == 'e' || valCh == 'E') {
					newScene.scene_interpolations[indVar].interpolation_mode = pg_enum_exponential_interpolation;
					if (valCh2 == ' ') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_enum_scenario_initial;
					}
					else if (valCh2 == 'k') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_current_value;
					}
					sstream >> val3;
					newScene.scene_interpolations[indVar].exponent = val3;
					if (valCh == 'E') {
						sstream >> vals;
						sstream >> val2s;
						double val = pg_stringToDuration(vals, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						double val2 = pg_stringToDuration(val2s, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						if (val < 0.0 || val2 < 0.0) {
							sprintf(pg_errorStr, "Error: one of values of E(exponential) in scene %d var %d lower than 0.0: %.3f %.3f\n", nbScenesInScenario + 1, indVar + 1, val, val2); pg_ReportError(pg_errorStr); throw 50;
						}
						if (val <= 1.0) {
							newScene.scene_interpolations[indVar].offSet = val;
							// deals with approximate values that can summ above 1.0
							if (float(double(val) + double(val2)) <= 1.00001) {
								if (float(double(val) + double(val2)) > 1.0) {
									val2 = 1.0f - val;
								}
								newScene.scene_interpolations[indVar].duration = val2;
								if (newScene.scene_interpolations[indVar].duration <= 0.0) {
									sprintf(pg_errorStr, "Error: null Z(Bezier) in scene %d var %d duration [%f]!", nbScenesInScenario + 1, indVar + 1, newScene.scene_interpolations[indVar].duration); pg_ReportError(pg_errorStr); throw 50;
								}
							}
							else {
								sprintf(pg_errorStr, "Error: total duration of Z(Bezier) in scene %d var %d greater than 1.0: %.3f + %.3f\n", nbScenesInScenario + 1, indVar + 1, val, val2); pg_ReportError(pg_errorStr); throw 50;
							}
						}
						else {
							sprintf(pg_errorStr, "Error: offset value Z(Bezier) in scene %d var %d greater than 1.0: %.3f\n", nbScenesInScenario + 1, indVar + 1, val); pg_ReportError(pg_errorStr); throw 50;
						}
					}
				}
				// b: bell curve interpolation between initial, median and final value from (0,0,0)% to (0,1,0)% at mid time to (0,0,1)% at the end
				// BELL INTERPOLATION
				else if (valCh == 'b' || valCh == 'B') {
					newScene.scene_interpolations[indVar].interpolation_mode = pg_enum_bell_interpolation;
					if (valCh2 == ' ') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_enum_scenario_initial;
					}
					else if (valCh2 == 'k') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_current_value;
					}
					sstream >> newScene.scene_interpolations[indVar].midTermValue;
					if (pg_FullScenarioVarIndiceRanges[indVar][0] != -1) {
						if (newScene.scene_interpolations[indVar].midTermValueArray != NULL) {
							for (int index = pg_FullScenarioVarIndiceRanges[indVar][0]; index < pg_FullScenarioVarIndiceRanges[indVar][1]; index++) {
								newScene.scene_interpolations[indVar].midTermValueArray[index] = newScene.scene_interpolations[indVar].midTermValue;
							}
						}
						else {
							sprintf(pg_errorStr, "Unexpected null array for bell interpolation %d (%s)!", indVar, pg_FullScenarioVarMessages[indVar].c_str()); pg_ReportError(pg_errorStr); throw 100;
						}
					}
					//printf("Bell interpolation mode in scene %d (%s) parameter %d [%d] [%c] mid term value %.2f!\n",
					//	nbScenesInScenario + 1, newScene.scene_IDs.c_str(), indVar + 1, int(valCh), valCh, 
					//	newScene.scene_interpolations[indVar].midTermValue);
					if (valCh == 'B') {
						sstream >> vals;
						sstream >> val2s;
						double val = pg_stringToDuration(vals, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						double val2 = pg_stringToDuration(val2s, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						if (val < 0.0 || val2 < 0.0) {
							sprintf(pg_errorStr, "Error: one of values of B(ell) in scene %d var %d lower than 0.0: %.3f %.3f\n", nbScenesInScenario + 1, indVar + 1, val, val2); pg_ReportError(pg_errorStr); throw 50;
						}
						if (val <= 1.0) {
							newScene.scene_interpolations[indVar].offSet = val;
							if (float(val + val2) <= 1.00001f) {
								// deals with approximate values that can summ above 1.0
								if (float(val + val2) > 1.0f) {
									val2 = 1.0f - val;
								}
								newScene.scene_interpolations[indVar].duration = val2;
								if (newScene.scene_interpolations[indVar].duration <= 0.0) {
									sprintf(pg_errorStr, "Error: null B(ell) in scene %d var %d duration [%f]!", nbScenesInScenario + 1, indVar + 1, newScene.scene_interpolations[indVar].duration); pg_ReportError(pg_errorStr); throw 50;
								}
							}
							else {
								sprintf(pg_errorStr, "Error: total duration of B(ell) in scene %d var %d greater than 1.0: %.3f + %.3f\n", nbScenesInScenario + 1, indVar + 1, val, val2); pg_ReportError(pg_errorStr); throw 50;
							}
						}
						else {
							sprintf(pg_errorStr, "Error: offset value L(inear) in scene %d var %d greater than 1.0: %.3f\n", nbScenesInScenario + 1, indVar + 1, val); pg_ReportError(pg_errorStr); throw 50;
						}
						// std::cout << "L " << val << " " << val2 << " ";

					}
				}
				// b: saw tooth linear interpolation between initial, median and final value from (0,0,0)% to (0,1,0)% at mid time to (0,0,1)% at the end
				// SAW TOOTH INTERPOLATION
				else if (valCh == 't') {
					newScene.scene_interpolations[indVar].interpolation_mode = pg_enum_sawtooth_interpolation;
					if (valCh2 == ' ') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_enum_scenario_initial;
					}
					else if (valCh2 == 'k') {
						newScene.scene_interpolations[indVar].initialization_mode = pg_current_value;
					}
					sstream >> newScene.scene_interpolations[indVar].midTermValue;
					if (pg_FullScenarioVarIndiceRanges[indVar][0] != -1) {
						for (int index = pg_FullScenarioVarIndiceRanges[indVar][0]; index < pg_FullScenarioVarIndiceRanges[indVar][1]; index++) {
							newScene.scene_interpolations[indVar].midTermValueArray[index] = newScene.scene_interpolations[indVar].midTermValue;
						}
					}
				}
				// STEPWISE VALUE WITHOUT INTERPOLATION
				else if (valCh == 's' || valCh == 'S') {
					newScene.scene_interpolations[indVar].interpolation_mode = pg_enum_stepwise_interpolation;
					newScene.scene_interpolations[indVar].initialization_mode = pg_enum_scenario_initial;
					newScene.scene_interpolations[indVar].offSet = 0.0;
					newScene.scene_interpolations[indVar].duration = 1.0;
					if (valCh == 'S') {
						sstream >> vals;
						double val = pg_stringToDuration(vals, newScene.scene_duration, nbScenesInScenario + 1, indVar + 1);
						if (val < 0.0) {
							sprintf(pg_errorStr, "Error: offset values of S(tepwise) in scene %d (%s) var %d lower than 0.0: %.3f\n", nbScenesInScenario + 1, newScene.scene_IDs.c_str(), indVar + 1, val); pg_ReportError(pg_errorStr); throw 50;
						}
						if (val <= 1.0) {
							newScene.scene_interpolations[indVar].offSet = val;
							newScene.scene_interpolations[indVar].duration = 1.0 - double(val);
						}
						else {
							sprintf(pg_errorStr, "Error: offset value of S(tepwise) in scene %d (%s) var %d greater than 1.0: %.3f\n", nbScenesInScenario + 1, newScene.scene_IDs.c_str(), indVar + 1, val); pg_ReportError(pg_errorStr); throw 50;
						}
					}
					else {
						if (pg_FullScenarioVarTypes[indVar] == _pg_string
							&& newScene.scene_initial_parameters[indVar].val_string
							!= newScene.scene_final_parameters[indVar].val_string) {
							sprintf(pg_errorStr, "Error: S(tepwise) interpolation should have same initial and final values %s/%s in scene %d (%s) var %d (%s)\n",
								newScene.scene_initial_parameters[indVar].val_string.c_str(), newScene.scene_final_parameters[indVar].val_string.c_str(), 
								nbScenesInScenario + 1, newScene.scene_IDs.c_str(), indVar + 1, pg_FullScenarioVarMessages[indVar].c_str()); pg_ReportError(pg_errorStr); throw 50;
						}
						else if (pg_FullScenarioVarTypes[indVar] != _pg_string) {
							if (pg_FullScenarioVarIndiceRanges[indVar][0] == -1) {
								if (newScene.scene_initial_parameters[indVar].val_num
									!= newScene.scene_final_parameters[indVar].val_num) {
									sprintf(pg_errorStr, "Error: S(tepwise) interpolation should have same initial and final values %.2f/%.2f in scene %d (%s) var %d (%s)\n",
										newScene.scene_initial_parameters[indVar].val_num, newScene.scene_final_parameters[indVar].val_num, nbScenesInScenario + 1,
										newScene.scene_IDs.c_str(), indVar + 1, pg_FullScenarioVarMessages[indVar].c_str()); pg_ReportError(pg_errorStr); throw 50;
								}
							}
							else {
								for (int index = pg_FullScenarioVarIndiceRanges[indVar][0]; index < pg_FullScenarioVarIndiceRanges[indVar][1]; index++) {
									if (newScene.scene_initial_parameters[indVar].val_array[index]
										!= newScene.scene_final_parameters[indVar].val_array[index]) {
										sprintf(pg_errorStr, "Error: S(tepwise) interpolation should have same initial and final values %.2f/%.2f in scene %d (%s) var %d  (%s) index %d\n", 
											newScene.scene_initial_parameters[indVar].val_array[index], newScene.scene_final_parameters[indVar].val_array[index],
											nbScenesInScenario + 1, newScene.scene_IDs.c_str(), indVar + 1, pg_FullScenarioVarMessages[indVar].c_str(), index + 1); pg_ReportError(pg_errorStr); throw 50;
									}
								}
							}
						}
					}
				}
				// KEEP CURRENT VALUE WITHOUT INTERPOLATION
				else if (valCh == 'k' || valCh == 'K') {
					newScene.scene_interpolations[indVar].initialization_mode = pg_current_value;
					newScene.scene_interpolations[indVar].interpolation_mode = pg_enum_keep_value;
				}
				else {					
					printf("indVar %d indP %d\n", indVar, indP);
					sprintf(pg_errorStr, "Error: unknown interpolation mode in scene %d (%s) parameter %d (%d in full) [%d] [%c]!", nbScenesInScenario + 1, newScene.scene_IDs.c_str(), indP + 1, indVar + 1, int(valCh), valCh); pg_ReportError(pg_errorStr); throw 50;
				}

				//if (indVar == _trkDecay && nbScenesInScenario == 12) {
				//	printf("Decay Scene %d Interpolation mode %d offset %.2f dur %.2f init %.2f fin %.2f\n", nbScenesInScenario, newScene.scene_interpolations[indVar].interpolation_mode,
				//		newScene.scene_interpolations[indVar].offSet,
				//		newScene.scene_interpolations[indVar].duration,
				//		newScene.scene_initial_parameters[indVar],
				//		newScene.scene_final_parameters[indVar]);
				//}
			}
		}

		// /scene
		std::getline(scenarioFin, line);
		pg_stringstreamStoreLine(&sstream, &line);
		sstream >> ID; // string /scene
		if (ID.compare("/scene") != 0) {
			sprintf(pg_errorStr, "Error: incorrect configuration file expected string \"/scene\" not found! (instead \"%s\")", ID.c_str()); pg_ReportError(pg_errorStr); throw 100;
		}

		pg_Scenario[indScenario].push_back(newScene);
		nbScenesInScenario++;
	}

	pg_parseScenarioRenderingFiles(scenarioFin, indScenario);

	pg_parseScenario_UDP(scenarioFin, indScenario);

	pg_parseScenario_Cameras(scenarioFin, indScenario);

	pg_parseScenarioShaders(scenarioFin, indScenario);

	pg_parseScenarioDirectories(scenarioFin, indScenario);

	pg_parseScenario_Videos(scenarioFin, indScenario);

	pg_parseScenario_ClipsAndPhotos(scenarioFin, indScenario);

	pg_parseScenario_soundTracks(scenarioFin, indScenario);

	pg_parseScenario_SVGPaths(scenarioFin, indScenario);

	pg_parseScenario_ClipArt(scenarioFin, indScenario);

	pg_parseScenario_Meshes(scenarioFin, indScenario);

	pg_parseScenario_Textures(scenarioFin, indScenario);

	pg_parseScenarioColorPalettes(scenarioFin, indScenario);

	pg_parseScenarioColorPresets(scenarioFin, indScenario);

	pg_parseScenario_Lights(scenarioFin, indScenario);

	// saves the original durations
	pg_saveInitialTimesAndDurations(indScenario);

	// intialization of texture data for screen messages
	pg_init_texDataScreenFont();

	// log file opening
	pg_snapshots_dir_path_name = pg_snapshots_dir_path_prefix + "/pic_" + project_name + "_" + pg_date_stringStream.str() + "/";
	pg_csv_logFile_name = pg_snapshots_dir_path_name + "porphyrograph-" + project_name + "-" + pg_date_stringStream.str() + ".csv";

	int nError = 0;
#if defined(_WIN32)
	nError = CreateDirectoryA(pg_snapshots_dir_path_name.c_str(), NULL); // can be used on Windows
#else 
	nError = mkdir(pg_snapshots_dir_path_name.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH); // can be used on non-Windows
#endif
	if (nError != 0) {
		// handle your error here
	}

	// defines glut window
	pg_setWindowDimensions();

	if (indScenario == 0) {
		printf("Window %dx%d working window width:%d working window doubling (1/0) %d Margin:%d TopLeft %dx%d\n",
			PG_WINDOW_WIDTH, PG_WINDOW_HEIGHT, pg_workingWindow_width, double_window,
			pg_rightWindowVMargin, window_x, window_y);
	}

}	

// loads the full scenario
void pg_LoadScenarioFile(const char* scenarioFileName, int indScenario) {
	//printf("Loading %s\n", scenarioFileName);

	std::ifstream scenarioFin(scenarioFileName);
	if (!scenarioFin) {
		sprintf(pg_errorStr, "Error: file [%s] not found!", scenarioFileName); pg_ReportError(pg_errorStr); throw 11;
	}
	pg_parseScenarioFile(scenarioFin, indScenario);
	scenarioFin.close();
}

