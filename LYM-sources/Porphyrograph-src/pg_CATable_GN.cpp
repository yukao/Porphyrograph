void pg_CATable_values(GLuint textureID, GLubyte * data_table, int width, int height) {
	GLubyte *ptr = data_table;

	//vec4 GOL_params[9]
	//=vec4[9](vec4(0,0,0,0),vec4(3,3,2,3),
	//  vec4(3,6,2,3),vec4(1,1,1,2),
	//  vec4(1,2,3,4),vec4(1,2,4,6),
	//  vec4(2,10,4,6),vec4(2,6,5,6),
	//  vec4(2,7,5,7));

	////////////////////////////////////////////
	// GAME OF LIFE FAMILY: 1 neutral + 8 variants
	GLubyte transition_tableGOL[9 * 2 * 10] = {
		0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,

		0,0,0,1,0,0,0,0,0,0, 0,0,1,1,0,0,0,0,0,0,
		0,0,0,1,1,1,1,0,0,0, 0,0,1,1,0,0,0,0,0,0,
		0,1,0,0,0,0,0,0,0,0, 0,1,1,0,0,0,0,0,0,0,
		0,1,1,0,0,0,0,0,0,0, 0,0,0,1,1,0,0,0,0,0,

		0,1,1,0,0,0,0,0,0,0, 0,0,0,0,1,1,1,0,0,0,
		0,0,1,1,1,1,1,1,1,1, 0,0,0,0,1,1,1,0,0,0,
		0,0,1,1,1,1,1,0,0,0, 0,0,0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,1,1,0,0, 0,0,0,0,0,1,1,1,0,0,

	};
	for (int indGOL = 0; indGOL < 9; indGOL++) {
		ptr[0] = 2;
		for (int ind = 1; ind < std::min(width, 2 * 10 + 1); ind++) {
			ptr[ind * 4] = transition_tableGOL[indGOL * 2 * 10 + ind - 1];
		}
		ptr += 4 * width;
	}

	////////////////////////////////////////////
	// TOTALISTIC FAMILY: 1 neutral + 8 variants
	// SubType 0: neutral
	ptr[0] = 16;
	for (int ind = 1; ind < std::min(width, 16 * 10 + 1); ind++) {
		ptr[ind * 4] = 0;
	}
	ptr += 4 * width;

	// SubType 1: CARS
	GLubyte transition_tableCARS[16 * 10] = {
		0,2,15,6,8,2,4,6,8,0, 0,0,0,0,0,0,0,0,0,0, 4,4,4,4,4,4,4,4,4,0, 0,0,0,0,0,0,0,0,0,0,
		0,6,6,6,6,6,6,6,6,0, 0,0,0,0,0,0,0,0,0,0, 8,8,8,8,8,8,8,8,8,0, 0,0,0,0,0,0,0,0,0,0,
		10,10,10,10,10,10,10,10,10,0, 0,0,0,0,0,0,0,0,0,0, 12,12,12,12,12,12,12,12,12,0, 0,0,0,0,0,0,0,0,0,0,
		14,14,14,14,14,14,14,14,14,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 16;
	for (int ind = 1; ind < std::min(width, 16 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableCARS[ind - 1];
	}
	ptr += 4 * width;

	// SubType 2: EcoLiBra
	GLubyte transition_tableEcoLiBra[16 * 10] = {
		0,0,7,0,0,0,15,15,0,0, 0,0,0,0,0,0,0,0,0,0, 15,15,15,15,15,2,2,15,15,0,
		0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0, 12,12,12,12,12,12,12,12,12,0, 0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
		15,0,15,15,15,2,15,15,15,0
	};
	ptr[0] = 16;
	for (int ind = 1; ind < std::min(width, 16 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableEcoLiBra[ind - 1];
	}
	ptr += 4 * width;

	// SubType 3: Ladders
	GLubyte transition_tableLadders[16 * 10] = {
		0,6,5,0,0,2,15,5,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,8,7,15,0,15,0,0,
		0,0,6,0,0,0,0,0,3,0, 0,0,0,0,0,0,0,0,0,0, 8,0,0,0,0,0,0,0,0,0,
		8,4,2,5,6,0,0,0,0,0, 4,0,11,0,0,0,0,0,0,0, 0,0,0,0,0,0,15,4,0,0,
		0,8,0,15,5,0,0,0,0,0, 4,10,0,0,4,5,0,0,4,0, 0,8,8,0,0,12,4,6,0,0,
		0,0,0,10,2,10,6,6,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,9,0,11,3,0,0, 9,0,0,0,14,0,0,6
	};
	ptr[0] = 16;
	for (int ind = 1; ind < std::min(width, 16 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableLadders[ind - 1];
	}
	ptr += 4 * width;

	// SubType 4: Wire World
	GLubyte transition_tableWire[4 * 10] = {
		0,0,0,0,0,0,0,0,0,0, 2,2,2,2,2,2,2,2,2,0, 3,3,3,3,3,3,3,3,3,0, 3,1,1,3,3,3,3,3,3,3,
	};
	ptr[0] = 4;
	for (int ind = 1; ind < std::min(width, 4 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableWire[ind - 1];
	}
	ptr += 4 * width;

	// SubType 5: Busy Brain
	GLubyte transition_tableBusyBrain[3 * 10] = {
		0,0,1,2,0,2,2,2,2,0, 2,2,2,1,0,2,2,2,2, 0,0,0,0,0,1,2,2,1,2,
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 3 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableBusyBrain[ind - 1];
	}
	ptr += 4 * width;

	// SubType 6: Balloons
	GLubyte transition_tableBalloons[16 * 10] = {
		0,0,15,0,0,0,5,0,0,0,  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0, 4,4,8,4,4,4,4,4,4,0,  5,5,5,5,5,7,7,9,11,
		0,2,2,2,2,2,2,2,2,2,  0,5,5,5,5,5,13,13,9,11, 0,8,8,10,8,8,8,8,8,8,0,
		2,2,2,2,2,9,13,9,11,0, 10,10,0,10,10,10,10,10,10,0,  4,14,14,14,14,14,14,14,11,0, 2,12,4,12,12,12,12,12,12,0,
		6,6,6,6,13,13,13,9,11,0, 14,14,14,12,14,14,14,14,14,0,  2,2,2,2,2,2,2,2,2
	};
	ptr[0] = 16;
	for (int ind = 1; ind < std::min(width, 16 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableBalloons[ind - 1];
	}
	ptr += 4 * width;

	// SubType 7: Ran Brain
	GLubyte transition_tableRanBrain[16 * 10] = {
		0,0,5,10,0,0,5,10,0,0, 0,0,5,10,0,0,0,0,15,0,
		0,0,0,0,0,15,15,0,0,0, 0,0,14,0,0,0,0,0,0,0, 0,0,4,0,0,0,0,0,0,0,
		2,6,2,6,2,6,2,6,2,0, 2,6,2,6,2,6,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
		0,0,12,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,12,0,0,
		0,2,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,14,7
	};
	ptr[0] = 16;
	for (int ind = 1; ind < std::min(width, 16 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableRanBrain[ind - 1];
	}
	ptr += 4 * width;

	// SubType 8: Brian's Brain
	GLubyte transition_tableBriansBrain[3 * 10] = {
		0,0,1,0,0,0,0,0,0,0, 2,2,2,2,2,2,2,2,2,2, 0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 3 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableBriansBrain[ind - 1];
	}
	ptr += 4 * width;

	////////////////////////////////////////////
	// GENERATION FAMILY: 1 neutral + 19 variants
	// SubType 0: neutral
#define nbStatesNeutral 8
	ptr[0] = nbStatesNeutral;
	for (int ind = 1; ind < std::min(width, nbStatesNeutral * 10 + 1); ind++) {
		ptr[ind * 4] = 0;
	}
	ptr += 4 * width;

	// SubType 1: TwoStates
#define nbStatesTwoStates 2
	GLubyte TwoStates[nbStatesTwoStates * 10] = {
		0,0,1,0,1,0,0,1,1,0, // TwoStates
		0,0,0,0,0,0,0,0,0,0, // TwoStates
	}; // TwoStates
	ptr[0] = nbStatesTwoStates;
	for (int ind = 1; ind < std::min(width, nbStatesTwoStates * 10 + 1); ind++) {
		ptr[ind * 4] = TwoStates[ind - 1];
	}
	ptr += 4 * width;

	// SubType 2: Caterpillars
#define nbStatesCaterpillars 4
	GLubyte Caterpillars[nbStatesCaterpillars * 10] = {
		0,0,0,1,0,0,0,1,1,0, // Caterpillars
		2,1,1,2,1,1,1,1,2,2, // Caterpillars
		3,1,1,3,1,1,1,1,3,3, // Caterpillars
		0,1,1,0,1,1,1,1,0,0,
	}; // Caterpillars
	ptr[0] = nbStatesCaterpillars;
	for (int ind = 1; ind < std::min(width, nbStatesCaterpillars * 10 + 1); ind++) {
		ptr[ind * 4] = Caterpillars[ind - 1];
	}
	ptr += 4 * width;

	// SubType 3: SoftFreeze
#define nbStatesSoftFreeze 6
	GLubyte SoftFreeze[nbStatesSoftFreeze * 10] = {
		0,0,0,1,0,0,0,0,1,0, // SoftFreeze
		2,1,2,1,1,1,2,2,1,2, // SoftFreeze
		3,1,3,1,1,1,3,3,1,3, // SoftFreeze
		4,1,4,1,1,1,4,4,1,4, // SoftFreeze
		5,1,5,1,1,1,5,5,1,5, // SoftFreeze
		0,1,0,1,1,1,0,0,1,0,
	}; // SoftFreeze
	ptr[0] = nbStatesSoftFreeze;
	for (int ind = 1; ind < std::min(width, nbStatesSoftFreeze * 10 + 1); ind++) {
		ptr[ind * 4] = SoftFreeze[ind - 1];
	}
	ptr += 4 * width;

	// SubType 4: LOTE
#define nbStatesLOTE 6
	GLubyte LOTE[nbStatesLOTE * 10] = {
		0,0,0,1,0,0,0,0,0,0, // LOTE
		2,2,2,1,1,1,2,2,2,2, // LOTE
		3,3,3,1,1,1,3,3,3,3, // LOTE
		4,4,4,1,1,1,4,4,4,4, // LOTE
		5,5,5,1,1,1,5,5,5,5, // LOTE
		0,0,0,1,1,1,0,0,0,0,
	}; // LOTE
	ptr[0] = nbStatesLOTE;
	for (int ind = 1; ind < std::min(width, nbStatesLOTE * 10 + 1); ind++) {
		ptr[ind * 4] = LOTE[ind - 1];
	}
	ptr += 4 * width;


	// SubType 5: MeterGuns
#define nbStatesMeterGuns 8
	GLubyte MeterGuns[nbStatesMeterGuns * 10] = {
		0,0,0,1,0,0,0,0,0,0, // MeterGuns
		1,1,1,2,1,1,1,1,1,2, // MeterGuns
		1,1,1,3,1,1,1,1,1,3, // MeterGuns
		1,1,1,4,1,1,1,1,1,4, // MeterGuns
		1,1,1,5,1,1,1,1,1,5, // MeterGuns
		1,1,1,6,1,1,1,1,1,6, // MeterGuns
		1,1,1,7,1,1,1,1,1,7, // MeterGuns
		1,1,1,0,1,1,1,1,1,0,
	}; // MeterGuns
	ptr[0] = nbStatesMeterGuns;
	for (int ind = 1; ind < std::min(width, nbStatesMeterGuns * 10 + 1); ind++) {
		ptr[ind * 4] = MeterGuns[ind - 1];
	}
	ptr += 4 * width;


	// SubType 6: EbbFlow
#define nbStatesEbbFlow 18
	GLubyte EbbFlow[nbStatesEbbFlow * 10] = {
		0,0,0,1,0,0,1,0,0,0, // EbbFlow
		1,1,1,2,1,2,2,1,1,2, // EbbFlow
		1,1,1,3,1,3,3,1,1,3, // EbbFlow
		1,1,1,4,1,4,4,1,1,4, // EbbFlow
		1,1,1,5,1,5,5,1,1,5, // EbbFlow
		1,1,1,6,1,6,6,1,1,6, // EbbFlow
		1,1,1,7,1,7,7,1,1,7, // EbbFlow
		1,1,1,8,1,8,8,1,1,8, // EbbFlow
		1,1,1,9,1,9,9,1,1,9, // EbbFlow
		1,1,1,10,1,10,10,1,1,10, // EbbFlow
		1,1,1,11,1,11,11,1,1,11, // EbbFlow
		1,1,1,12,1,12,12,1,1,12, // EbbFlow
		1,1,1,13,1,13,13,1,1,13, // EbbFlow
		1,1,1,14,1,14,14,1,1,14, // EbbFlow
		1,1,1,15,1,15,15,1,1,15, // EbbFlow
		1,1,1,16,1,16,16,1,1,16, // EbbFlow
		1,1,1,17,1,17,17,1,1,17, // EbbFlow
		1,1,1,0,1,0,0,1,1,0,
	}; // EbbFlow
	ptr[0] = nbStatesEbbFlow;
	for (int ind = 1; ind < std::min(width, nbStatesEbbFlow * 10 + 1); ind++) {
		ptr[ind * 4] = EbbFlow[ind - 1];
	}
	ptr += 4 * width;


	// SubType 7: EbbFlow2
#define nbStatesEbbFlow2 18
	GLubyte EbbFlow2[nbStatesEbbFlow2 * 10] = {
		0,0,0,1,0,0,0,1,0,0, // EbbFlow2
		1,1,1,2,1,2,1,2,1,2, // EbbFlow2
		1,1,1,3,1,3,1,3,1,3, // EbbFlow2
		1,1,1,4,1,4,1,4,1,4, // EbbFlow2
		1,1,1,5,1,5,1,5,1,5, // EbbFlow2
		1,1,1,6,1,6,1,6,1,6, // EbbFlow2
		1,1,1,7,1,7,1,7,1,7, // EbbFlow2
		1,1,1,8,1,8,1,8,1,8, // EbbFlow2
		1,1,1,9,1,9,1,9,1,9, // EbbFlow2
		1,1,1,10,1,10,1,10,1,10, // EbbFlow2
		1,1,1,11,1,11,1,11,1,11, // EbbFlow2
		1,1,1,12,1,12,1,12,1,12, // EbbFlow2
		1,1,1,13,1,13,1,13,1,13, // EbbFlow2
		1,1,1,14,1,14,1,14,1,14, // EbbFlow2
		1,1,1,15,1,15,1,15,1,15, // EbbFlow2
		1,1,1,16,1,16,1,16,1,16, // EbbFlow2
		1,1,1,17,1,17,1,17,1,17, // EbbFlow2
		1,1,1,0,1,0,1,0,1,0, // EbbFlow2
	}; // EbbFlow2
	ptr[0] = nbStatesEbbFlow2;
	for (int ind = 1; ind < std::min(width, nbStatesEbbFlow2 * 10 + 1); ind++) {
		ptr[ind * 4] = EbbFlow2[ind - 1];
	}
	ptr += 4 * width;


	// SubType 8: SediMental
#define nbStatesSediMental 4
	GLubyte SediMental[nbStatesSediMental * 10] = {
		0,0,1,0,0,1,1,1,1,0, // SediMental
		2,2,2,2,1,1,1,1,1,2, // SediMental
		3,3,3,3,1,1,1,1,1,3, // SediMental
		0,0,0,0,1,1,1,1,1,0,
	}; // SediMental
	ptr[0] = nbStatesSediMental;
	for (int ind = 1; ind < std::min(width, nbStatesSediMental * 10 + 1); ind++) {
		ptr[ind * 4] = SediMental[ind - 1];
	}
	ptr += 4 * width;


	// SubType 9: Brain6
#define nbStatesBrain6 3
	GLubyte Brain6[nbStatesBrain6 * 10] = {
		0,0,1,0,1,0,1,0,0,0, // Brain6
		2,2,2,2,2,2,1,2,2,2, // Brain6
		0,0,0,0,0,0,1,0,0,0, // Brain6
	}; // Brain64
	ptr[0] = nbStatesBrain6;
	for (int ind = 1; ind < std::min(width, nbStatesBrain6 * 10 + 1); ind++) {
		ptr[ind * 4] = Brain6[ind - 1];
	}
	ptr += 4 * width;


	// SubType 10: OrthoGo
#define nbStatesOrthoGo 4
	GLubyte OrthoGo[nbStatesOrthoGo * 10] = {
		0,0,1,0,0,0,0,0,0,0, // OrthoGo
		2,2,2,1,2,2,2,2,2,2, // OrthoGo
		3,3,3,1,3,3,3,3,3,3, // OrthoGo
	}; // OrthoGo
	ptr[0] = nbStatesOrthoGo;
	for (int ind = 1; ind < std::min(width, nbStatesOrthoGo * 10 + 1); ind++) {
		ptr[ind * 4] = OrthoGo[ind - 1];
	}
	ptr += 4 * width;


	// SubType 11: StarWars
#define nbStatesStarWars 4
	GLubyte StarWars[nbStatesStarWars * 10] = {
		0,0,1,0,0,0,0,0,0,0, // StarWars
		2,2,2,1,1,1,2,2,2,2, // StarWars
		3,3,3,1,1,1,3,3,3,3, // StarWars
		0,0,0,1,1,1,0,0,0,0,
	}; // StarWars
	ptr[0] = nbStatesStarWars;
	for (int ind = 1; ind < std::min(width, nbStatesStarWars * 10 + 1); ind++) {
		ptr[ind * 4] = StarWars[ind - 1];
	}
	ptr += 4 * width;


	// SubType 12: Transers
#define nbStatesTransers 5
	GLubyte Transers[nbStatesTransers * 10] = {
		0,0,1,0,0,0,1,0,0,0, // Transers
		2,2,2,1,1,1,2,2,2,2, // Transers
		3,3,3,1,1,1,3,3,3,3, // Transers
		4,4,4,1,1,1,4,4,4,4, // Transers
		0,0,0,1,1,1,0,0,0,0,
	}; // Transers
	ptr[0] = nbStatesTransers;
	for (int ind = 1; ind < std::min(width, nbStatesTransers * 10 + 1); ind++) {
		ptr[ind * 4] = Transers[ind - 1];
	}
	ptr += 4 * width;


	// SubType 13: Snake
#define nbStatesSnake 6
	GLubyte Snake[nbStatesSnake * 10] = {
		0,0,1,0,0,1,0,0,0,0, // Snake
		1,2,2,1,1,2,1,1,2,2, // Snake
		1,3,3,1,1,3,1,1,3,3, // Snake
		1,4,4,1,1,4,1,1,4,4, // Snake
		1,5,5,1,1,5,1,1,5,5, // Snake
		1,0,0,1,1,0,1,1,0,0,
	}; // Snake
	ptr[0] = nbStatesSnake;
	for (int ind = 1; ind < std::min(width, nbStatesSnake * 10 + 1); ind++) {
		ptr[ind * 4] = Snake[ind - 1];
	}
	ptr += 4 * width;


	// SubType 14: Sticks
#define nbStatesSticks 6
	GLubyte Sticks[nbStatesSticks * 10] = {
		0,0,1,0,0,0,0,0,0,0, // Sticks
		2,2,2,1,1,1,1,2,2,2, // Sticks
		3,3,3,1,1,1,1,3,3,3, // Sticks
		4,4,4,1,1,1,1,4,4,4, // Sticks
		5,5,5,1,1,1,1,5,5,5, // Sticks
		0,0,0,1,1,1,1,0,0,0,
	}; // Sticks
	ptr[0] = nbStatesSticks;
	for (int ind = 1; ind < std::min(width, nbStatesSticks * 10 + 1); ind++) {
		ptr[ind * 4] = Sticks[ind - 1];
	}
	ptr += 4 * width;


	// SubType 15: Transers2
#define nbStatesTransers2 6
	GLubyte Transers2[nbStatesTransers2 * 10] = {
		0,0,1,0,0,0,1,0,0,0, // Transers2
		1,2,2,1,1,1,2,2,2,2, // Transers2
		1,3,3,1,1,1,3,3,3,3, // Transers2
		1,4,4,1,1,1,4,4,4,4, // Transers2
		1,5,5,1,1,1,5,5,5,5, // Transers2
		1,0,0,1,1,1,0,0,0,0, // Transers2
	}; // Transers2
	ptr[0] = nbStatesTransers2;
	for (int ind = 1; ind < std::min(width, nbStatesTransers2 * 10 + 1); ind++) {
		ptr[ind * 4] = Transers2[ind - 1];
	}
	ptr += 4 * width;


	// SubType 16: Worms
#define nbStatesWorms 6
	GLubyte Worms[nbStatesWorms * 10] = {
		0,0,1,0,0,1,0,0,0,0, // Worms
		2,2,2,1,1,2,1,1,2,2, // Worms
		3,3,3,1,1,3,1,1,3,3, // Worms
		4,4,4,1,1,4,1,1,4,4, // Worms
		5,5,5,1,1,5,1,1,5,5, // Worms
		0,0,0,1,1,0,1,1,0,0,
	}; // Worms
	ptr[0] = nbStatesWorms;
	for (int ind = 1; ind < std::min(width, nbStatesWorms * 10 + 1); ind++) {
		ptr[ind * 4] = Worms[ind - 1];
	}
	ptr += 4 * width;


	// SubType 17: Cooties
#define nbStatesCooties 9
	GLubyte Cooties[nbStatesCooties * 10] = {
		0,0,1,0,0,0,0,0,0,0, // Cooties
		2,2,1,1,2,2,2,2,2,2, // Cooties
		3,3,1,1,3,3,3,3,3,3, // Cooties
		4,4,1,1,4,4,4,4,4,4, // Cooties
		5,5,1,1,5,5,5,5,5,5, // Cooties
		6,6,1,1,6,6,6,6,6,6, // Cooties
		7,7,1,1,7,7,7,7,7,7, // Cooties
		8,8,1,1,8,8,8,8,8,8, // Cooties
		0,0,1,1,0,0,0,0,0,0,
	}; // Cooties
	ptr[0] = nbStatesCooties;
	for (int ind = 1; ind < std::min(width, nbStatesCooties * 10 + 1); ind++) {
		ptr[ind * 4] = Cooties[ind - 1];
	}
	ptr += 4 * width;



	// SubType 18: Faders
#define nbStatesFaders 25
	GLubyte Faders[nbStatesFaders * 10] = {
		0,0,1,0,0,0,0,0,0,0, // Faders
		2,2,1,2,2,2,2,2,2,2, // Faders
		3,3,1,3,3,3,3,3,3,3, // Faders
		4,4,1,4,4,4,4,4,4,4, // Faders
		5,5,1,5,5,5,5,5,5,5, // Faders
		6,6,1,6,6,6,6,6,6,6, // Faders
		7,7,1,7,7,7,7,7,7,7, // Faders
		8,8,1,8,8,8,8,8,8,8, // Faders
		9,9,1,9,9,9,9,9,9,9, // Faders
		10,10,1,10,10,10,10,10,10,10, // Faders
		11,11,1,11,11,11,11,11,11,11, // Faders
		12,12,1,12,12,12,12,12,12,12, // Faders
		13,13,1,13,13,13,13,13,13,13, // Faders
		14,14,1,14,14,14,14,14,14,14, // Faders
		15,15,1,15,15,15,15,15,15,15, // Faders
		16,16,1,16,16,16,16,16,16,16, // Faders
		17,17,1,17,17,17,17,17,17,17, // Faders
		18,18,1,18,18,18,18,18,18,18, // Faders
		19,19,1,19,19,19,19,19,19,19, // Faders
		20,20,1,20,20,20,20,20,20,20, // Faders
		21,21,1,21,21,21,21,21,21,21, // Faders
		22,22,1,22,22,22,22,22,22,22, // Faders
		23,23,1,23,23,23,23,23,23,23, // Faders
		24,24,1,24,24,24,24,24,24,24, // Faders
		0,0,1,0,0,0,0,0,0,0,
	}; // Faders
	ptr[0] = nbStatesFaders;
	for (int ind = 1; ind < std::min(width, nbStatesFaders * 10 + 1); ind++) {
		ptr[ind * 4] = Faders[ind - 1];
	}
	ptr += 4 * width;


	// SubType 19: Fireworks
#define nbStatesFireworks 21
	GLubyte Fireworks[nbStatesFireworks * 10] = {
		0,1,0,1,0,0,0,0,0,0, // Fireworks
		2,2,1,2,2,2,2,2,2,2, // Fireworks
		3,3,1,3,3,3,3,3,3,3, // Fireworks
		4,4,1,4,4,4,4,4,4,4, // Fireworks
		5,5,1,5,5,5,5,5,5,5, // Fireworks
		6,6,1,6,6,6,6,6,6,6, // Fireworks
		7,7,1,7,7,7,7,7,7,7, // Fireworks
		8,8,1,8,8,8,8,8,8,8, // Fireworks
		9,9,1,9,9,9,9,9,9,9, // Fireworks
		10,10,1,10,10,10,10,10,10,10, // Fireworks
		11,11,1,11,11,11,11,11,11,11, // Fireworks
		12,12,1,12,12,12,12,12,12,12, // Fireworks
		13,13,1,13,13,13,13,13,13,13, // Fireworks
		14,14,1,14,14,14,14,14,14,14, // Fireworks
		15,15,1,15,15,15,15,15,15,15, // Fireworks
		16,16,1,16,16,16,16,16,16,16, // Fireworks
		17,17,1,17,17,17,17,17,17,17, // Fireworks
		18,18,1,18,18,18,18,18,18,18, // Fireworks
		19,19,1,19,19,19,19,19,19,19, // Fireworks
		20,20,1,20,20,20,20,20,20,20, // Fireworks
		0,0,1,0,0,0,0,0,0,0,
	}; // Fireworks
	ptr[0] = nbStatesFireworks;
	for (int ind = 1; ind < std::min(width, nbStatesFireworks * 10 + 1); ind++) {
		ptr[ind * 4] = Fireworks[ind - 1];
	}
	ptr += 4 * width;


	////////////////////////////////////////////
	// GENERAL BINARY FAMILY Moore Neighborhood: 1 neutral + 7 variants
	// Example: Fallski
	// C48,NM,Sb255a,Babb189ab63a
	// 48 states 0-47
	// Moore neihborhood Order N,NE,E,SE,S,SW,W,NW
	// states are encoded: S_N + 2 * S_NE + 4 * S_E + 8 * S_SE ... + 128 * S_NW
	// 00000000 0 neighbor
	// 10000000 N neighbor
	// 01000000 NE neighbor
	// 192 = 00000011 W and NW neighbors
	// Survive b255a survival on no alive neighbors: 
	//                             1 x one    255 x zeros
	// Birth   abb189ab63a birth on a single N or  NE neighbor, or on W and NW neighbors:
	//                             0 1 1   189 x zeros   1   63 x zeros
	// Encoding of Survival and Birth
	// 256 0/1 digits encode 

	// SubType 0: neutral
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = 0;
	}
	ptr += 4 * width;

	// Subtype 1: Fallski
	GLubyte transition_tableFallski[256 * 2] = {
		1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 48;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableFallski[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 2: JustFriends
	GLubyte transition_tableJustFriends[256 * 2] = {
		0,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableJustFriends[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 3: LogicRule
	GLubyte transition_tableLogicRule[256 * 2] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableLogicRule[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 4: Meteorama
	GLubyte transition_tableMeteorama[256 * 2] = {
		0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0,0,
		0,0,0,0,0,1,0,1,1,1,1,1,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,0,0,0,0,0,1,0,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,1,0,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,
	};
	ptr[0] = 24;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableMeteorama[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 5: Slugfest
	GLubyte transition_tableSlugfest[256 * 2] = {
		1,1,1,1,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,1,0,1,0,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,1,1,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,0,1,0,
		0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,1,1,0,
	};
	ptr[0] = 20;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableSlugfest[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 6: Snowflakes
	GLubyte transition_tableSnowflakes[256 * 2] = {
		0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0,0,0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableSnowflakes[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 7: Springski
	GLubyte transition_tableSpringski[256 * 2] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 78;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableSpringski[ind - 1];
	}
	ptr += 4 * width;

	////////////////////////////////////////////
	// GENERAL BINARY FAMILY von Neumann Neighborhood: 1 neutral + 3 variants

	// SubType 0: neutral
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 16 * 2 + 1); ind++) {
		ptr[ind * 4] = 0;
	}
	ptr += 4 * width;

	// Subtype 1: Banks
	GLubyte transition_tableBanks[16 * 2] = {
		1,1,1,0,1,1,0,1,1,0,1,1,0,1,1,1,
		0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 16 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableBanks[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 2: FractalBeads
	GLubyte transition_tableFractalBeads[16 * 2] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 4;
	for (int ind = 1; ind < std::min(width, 16 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableFractalBeads[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 3: Sierpinski
	GLubyte transition_tableSierpinski[16 * 2] = {
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 16 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableSierpinski[ind - 1];
	}
	ptr += 4 * width;


	////////////////////////////////////////////
	// NEUMANNN BINARY FAMILY : 1 neutral + 18 variants
	// Fredkin2 rule has the following definition: 2,01101001100101101001011001101001
	// The first digit, '2', tells the rule has 2 states (it's a 1 bit rule).
	// The second digit, '0', tells a cell in a configuration ME=0,N=0,E=0,S=0,W=0 will get the state 0.
	// The third digit, '1', tells a cell in a configuration ME=0,N=0,E=0,S=0,W=1 will get the state 1.
	// The fourth digit, '1', tells a cell in a configuration ME=0,N=0,E=0,S=1,W=0 will get the state 1.
	// The fifth digit, '0', tells a cell in a configuration ME=0,N=0,E=0,S=1,W=1 will get the state 0.
	// . . .
	// binary rules are extended to ternary for a uniform rule system

	// SubType 0: neutral
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = 0;
	}
	ptr += 4 * width;

	// Subtype 1: Crystal2
	GLubyte transition_tableCrystal2[243] = {
		0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableCrystal2[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 2: Fredkin2
	GLubyte transition_tableFredkin2[243] = {
		0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableFredkin2[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 3: Aggregation
	GLubyte transition_tableAggregation[243] = {
		0,0,2,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,2,0,2,0,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,0,2,1,2,2,2,0,2,0,2,0,1,0,1,0,2,2,2,2,2,1,2,2,2,0,1,2,0,1,2,0,1,0,1,2,2,0,1,1,2,1,1,0,0,0,1,1,1,1,1,1,2,0,2,1,2,2,2,1,2,1,2,1,1,1,1,1,1,1,2,0,2,1,1,1,2,1,1
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableAggregation[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 4: Birds
	GLubyte transition_tableBirds[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,2,2,2,2,0,2,0,2,2,2,0,2,0,1,1,2,1,1,2,2,2,2,1,1,2,1,0,2,2,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,1,0,2,2,2,2,1,0,2,0,0,0,2,0,0,2,2,2,2,0,0,2,0,2,1,0,2,0,0,0,2,0,0,0,0,0,0,1,2,0,2,0,2,0,0,0,2,0,0,0,0,2,2,2,2,0,0,2,0,2,2,0,0,0,2,0,0,0,0,2,0,2,0,0,0,2,0,0,0,2,0,2,2,0,0,0,0,2,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,2,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableBirds[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 5: Colony
	GLubyte transition_tableColony[243] = {
		0,1,0,1,0,2,0,2,0,1,0,2,0,1,1,2,1,0,0,2,0,2,1,0,0,0,0,1,0,2,0,1,1,2,1,0,0,1,1,1,0,2,1,2,0,2,1,0,1,2,0,0,0,0,0,2,0,2,1,0,0,0,0,2,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,2,1,2,1,1,1,1,1,0,1,0,0,2,1,2,1,0,0,2,0,0,1,1,1,1,1,0,1,0,0,1,1,0,1,0,2,0,2,1,1,0,0,0,2,1,0,1,2,2,1,2,1,0,0,2,0,0,1,0,0,0,2,1,0,1,2,2,0,0,0,1,2,0,2,0,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableColony[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 6: Crystal3a
	GLubyte transition_tableCrystal3a[243] = {
		0,1,2,1,0,1,2,2,0,1,0,0,0,1,0,1,0,0,2,1,0,2,0,0,0,0,2,1,0,2,0,1,0,0,0,0,0,1,0,1,2,1,0,1,0,1,0,0,0,1,1,0,0,2,2,1,0,0,0,0,0,0,2,2,0,0,0,1,0,0,1,2,0,0,2,0,0,2,2,2,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,0,1,0,0,1,1,1,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,2,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,1,1,2,2,2,2,2,2,2,2,0,2,2,2,2,0,0,2,0,0,2,2,2,2,0,0,0,0,0,2,2,2,2,0,0,2,0,0,2,0,0,0,2,2,0,2,0,2,0,0,0,2,0,0,0,0,2,2,0,2,0,0,2,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableCrystal3a[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 7: Crystal3b
	GLubyte transition_tableCrystal3b[243] = {
		0,1,2,1,0,0,2,0,0,1,0,0,0,1,1,0,0,2,2,0,0,0,1,2,0,2,0,1,0,0,0,2,0,0,2,1,0,2,1,2,2,1,0,2,1,0,1,2,0,2,0,1,2,2,2,0,0,0,2,1,0,1,0,0,0,2,2,1,2,1,0,2,0,2,0,1,1,2,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,0,0,1,1,0,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,0,0,2,2,2,2,0,0,2,0,0,2,2,2,2,0,0,2,0,0,2,0,0,0,2,2,0,2,2,2,0,0,0,2,0,0,2,0,2,2,2,2,0,0,2,0,0,2,0,0,0,2,2,0,0,0,2,0,0,0,2,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableCrystal3b[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 8: Galaxy
	GLubyte transition_tableGalaxy[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,2,2,2,0,0,2,0,2,2,0,0,0,0,1,1,2,1,1,2,2,2,0,1,1,2,1,1,0,2,0,0,2,2,0,2,0,0,0,0,0,0,2,0,2,2,0,0,0,0,2,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,2,2,2,0,0,2,0,0,0,2,0,0,2,2,2,2,0,0,2,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,2,0,2,0,2,2,2,2,0,0,2,0,0,2,0,0,0,0,2,0,2,0,2,0,0,0,2,0,0,0,2,0,2,0,2,2,0,0,0,0,2,2,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,2,2,0,0,0,0,2,2,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableGalaxy[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 9: Greenberg
	GLubyte transition_tableGreenberg[243] = {
		0,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableGreenberg[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 10: Honeycomb
	GLubyte transition_tableHoneycomb[243] = {
		0,1,0,1,0,2,0,2,0,1,0,2,0,0,2,2,2,2,0,2,0,2,2,2,0,2,0,1,0,2,0,0,2,2,2,2,0,0,2,0,0,2,2,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,0,1,1,2,0,2,0,1,1,2,1,0,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,1,0,0,2,0,2,1,0,0,0,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,0,0,0,0,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,0,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,0,2,2,2,2,0,2,0,2,2,2,0,2,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableHoneycomb[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 11: Knitting
	GLubyte transition_tableKnitting[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,1,1,0,2,0,2,1,1,0,1,1,0,0,0,2,2,0,2,0,0,2,2,2,1,0,2,0,2,0,2,0,2,0,2,0,2,0,0,2,2,2,1,0,2,0,2,2,1,0,1,0,1,0,2,0,1,0,2,0,2,0,1,0,1,0,2,0,2,1,2,0,2,0,2,1,2,1,1,0,1,0,1,0,2,0,2,1,1,0,2,0,0,0,2,0,0,0,2,1,2,0,0,1,0,2,2,0,2,0,2,1,2,1,1,0,2,1,2,0,0,1,0,2,2,1,1,1,0,2,1,2,0,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableKnitting[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 12: Lake
	GLubyte transition_tableLake[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,0,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,1,0,0,2,0,2,1,0,0,0,1,0,0,0,2,2,0,2,0,0,2,2,2,0,0,2,0,2,0,2,0,2,0,2,0,2,0,0,2,2,2,0,0,2,0,2,2,0,0,0,0,0,1,2,1,1,0,2,0,2,1,1,0,1,0,0,0,0,0,2,0,2,0,0,0,2,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,2,0,2,2,0,0,0,0,2,2,0,2,0,2,0,2,0,0,0,2,0,0,0,0,0,0,2,2,0,2,0,2,0,0,0,2,0,0,0,0,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableLake[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 13: Plankton
	GLubyte transition_tablePlankton[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,2,2,2,2,0,2,0,2,2,2,0,2,0,1,1,2,1,1,2,2,2,2,1,1,2,1,0,2,2,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,0,0,0,0,2,0,2,0,0,0,2,0,1,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,1,0,2,0,2,0,1,0,1,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,0,0,0,0,0,2,0,2,2,0,0,0,0,2,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,2,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tablePlankton[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 14: Pond
	GLubyte transition_tablePond[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,2,2,2,2,0,2,0,2,2,2,0,2,0,1,1,2,1,1,2,2,2,2,1,1,2,1,0,2,2,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,0,1,0,2,0,2,0,1,0,2,0,1,0,2,0,2,0,2,0,2,0,2,0,2,0,1,0,2,0,1,0,2,0,2,0,1,0,1,1,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,0,0,0,0,0,2,0,2,2,0,0,0,0,2,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,2,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tablePond[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 15: Strata
	GLubyte transition_tableStrata[243] = {
		0,0,0,0,0,0,2,0,0,1,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableStrata[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 16: Tanks
	GLubyte transition_tableTanks[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,2,2,2,2,0,2,0,2,2,2,0,2,0,1,1,2,1,1,2,2,2,2,1,1,2,1,0,2,2,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,0,1,0,2,0,2,0,1,0,2,0,1,0,2,0,2,0,2,0,2,0,2,0,2,0,1,0,2,0,1,0,2,0,2,0,1,0,1,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,0,0,2,0,2,0,0,0,0,0,2,2,2,2,2,0,2,0,0,2,2,0,2,2,2,0,2,0,2,0,0,0,2,0,0,0,0,0,2,0,2,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableTanks[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 17: Typhoon
	GLubyte transition_tableTyphoon[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,2,2,2,0,0,2,0,2,2,0,0,0,0,1,1,2,1,1,2,2,2,0,1,1,2,1,1,0,2,0,0,2,2,0,2,0,0,0,0,0,0,2,0,2,2,0,0,0,0,2,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,2,2,2,0,0,2,0,0,0,2,0,0,2,2,2,2,0,0,2,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,2,0,2,0,2,2,2,2,0,0,2,0,0,2,0,0,0,0,2,0,2,0,2,0,0,0,2,0,0,0,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableTyphoon[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 18: Wave
	GLubyte transition_tableWave[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,1,1,0,2,0,2,1,1,0,1,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,1,0,2,2,2,2,1,0,2,0,0,0,2,0,0,2,2,2,2,0,0,2,0,2,1,0,2,0,0,0,2,0,0,0,0,0,0,0,2,0,2,0,2,0,0,0,2,0,0,0,0,2,2,2,2,0,0,2,0,2,2,0,0,0,2,0,0,0,0,2,0,2,0,0,0,2,0,0,0,2,0,2,2,0,0,0,0,2,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,2,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableWave[ind - 1];
	}
	ptr += 4 * width;






	glEnable(GL_TEXTURE_RECTANGLE);
	glBindTexture(GL_TEXTURE_RECTANGLE, textureID);
	glTexParameterf(GL_TEXTURE_RECTANGLE, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_RECTANGLE, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_RECTANGLE, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameterf(GL_TEXTURE_RECTANGLE, GL_TEXTURE_WRAP_T, GL_CLAMP);
	glTexImage2D(GL_TEXTURE_RECTANGLE,     // Type of texture
		0,                 // Pyramid level (for mip-mapping) - 0 is the top level
		GL_RGBA8,            // Components: Internal colour format to convert to
		width,          // Image width
		height,          // Image heigh
		0,                 // Border width in pixels (can either be 1 or 0)
		GL_RGBA, // Format: Input image format (i.e. GL_RGB, GL_RGBA, GL_BGR etc.)
		GL_UNSIGNED_BYTE,  // Image data type
		data_table);        // The actual image data itself

	printOglError(4);
}
