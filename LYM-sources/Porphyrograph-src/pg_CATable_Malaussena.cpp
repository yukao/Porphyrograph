void pg_CATable_values(GLuint textureID, GLubyte * data_table, int width, int height) {
	GLubyte *ptr = data_table;

	////////////////////////////////////////////
	// TOTALISTIC FAMILY: 1 neutral + 3 variants
	// #9 line: nbStates/ encoding in sequence of output states the neutral automaton for 
	// each of the nb_states * nb_neighors transitions
	// #10-17 line: encoding in sequence of output states the 8 variants for 
	// each of the nb_states * nb_neighors (16 * 10) transitions

	// SubType 0: neutral
	ptr[0] = 16;
	for (int ind = 1; ind < std::min(width, 16 * 10 + 1); ind++) {
		ptr[ind * 4] = 0;
	}
	ptr += 4 * width;

	// SubType 1: CARS
	GLubyte transition_tableCARS[16 * 10] = {
		0,2,15,6,8,2,4,6,8,0, 0,0,0,0,0,0,0,0,0,0, 4,4,4,4,4,4,4,4,4,0, 0,0,0,0,0,0,0,0,0,0,
		0,6,6,6,6,6,6,6,6,0, 0,0,0,0,0,0,0,0,0,0, 8,8,8,8,8,8,8,8,8,0, 0,0,0,0,0,0,0,0,0,0,
		10,10,10,10,10,10,10,10,10,0, 0,0,0,0,0,0,0,0,0,0, 12,12,12,12,12,12,12,12,12,0, 0,0,0,0,0,0,0,0,0,0,
		14,14,14,14,14,14,14,14,14,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 16;
	for (int ind = 1; ind < std::min(width, 16 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableCARS[ind - 1];
	}
	ptr += 4 * width;

	// SubType 2: EcoLiBra
	GLubyte transition_tableEcoLiBra[16 * 10] = {
		0,0,7,0,0,0,15,15,0,0, 0,0,0,0,0,0,0,0,0,0, 15,15,15,15,15,2,2,15,15,0,
		0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0, 12,12,12,12,12,12,12,12,12,0, 0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
		15,0,15,15,15,2,15,15,15,0
	};
	ptr[0] = 16;
	for (int ind = 1; ind < std::min(width, 16 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableEcoLiBra[ind - 1];
	}
	ptr += 4 * width;

	// SubType 3: Ladders
	GLubyte transition_tableLadders[16 * 10] = {
		0,6,5,0,0,2,15,5,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,8,7,15,0,15,0,0,
		0,0,6,0,0,0,0,0,3,0, 0,0,0,0,0,0,0,0,0,0, 8,0,0,0,0,0,0,0,0,0,
		8,4,2,5,6,0,0,0,0,0, 4,0,11,0,0,0,0,0,0,0, 0,0,0,0,0,0,15,4,0,0,
		0,8,0,15,5,0,0,0,0,0, 4,10,0,0,4,5,0,0,4,0, 0,8,8,0,0,12,4,6,0,0,
		0,0,0,10,2,10,6,6,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,9,0,11,3,0,0, 9,0,0,0,14,0,0,6
	};
	ptr[0] = 16;
	for (int ind = 1; ind < std::min(width, 16 * 10 + 1); ind++) {
		ptr[ind * 4] = transition_tableLadders[ind - 1];
	}
	ptr += 4 * width;


	////////////////////////////////////////////
	// GENERATION FAMILY: 1 neutral + 3 variants -> 1 neutral + 9 variants
	// #18 line: nbStates/ encoding in sequence of output states the neutral automaton for 
	// each of the nb_states * nb_neighors transitions
	// #19-37 line: nbStates/ encoding in sequence of output states the 19 variants for 
	// each of the nb_states * nb_neighors transitions

	// SubType 0: neutral
#define nbStatesNeutral 8
	ptr[0] = nbStatesNeutral;
	for (int ind = 1; ind < std::min(width, nbStatesNeutral * 10 + 1); ind++) {
		ptr[ind * 4] = 0;
	}
	ptr += 4 * width;

	// SubType 1: Caterpillars
#define nbStatesCaterpillars 4
	GLubyte Caterpillars[nbStatesCaterpillars * 10] = {
		0,0,0,1,0,0,0,1,1,0, // Caterpillars
		2,1,1,2,1,1,1,1,2,2, // Caterpillars
		3,1,1,3,1,1,1,1,3,3, // Caterpillars
		0,1,1,0,1,1,1,1,0,0,
	}; // Caterpillars
	ptr[0] = nbStatesCaterpillars;
	for (int ind = 1; ind < std::min(width, nbStatesCaterpillars * 10 + 1); ind++) {
		ptr[ind * 4] = Caterpillars[ind - 1];
	}
	ptr += 4 * width;

	// SubType 2: SediMental
#define nbStatesSediMental 4
	GLubyte SediMental[nbStatesSediMental * 10] = {
		0,0,1,0,0,1,1,1,1,0, // SediMental
		2,2,2,2,1,1,1,1,1,2, // SediMental
		3,3,3,3,1,1,1,1,1,3, // SediMental
		0,0,0,0,1,1,1,1,1,0,
	}; // SediMental
	ptr[0] = nbStatesSediMental;
	for (int ind = 1; ind < std::min(width, nbStatesSediMental * 10 + 1); ind++) {
		ptr[ind * 4] = SediMental[ind - 1];
	}
	ptr += 4 * width;

	// ***************** GENERATIVE NIGHTS
	// SubType 3: Faders
#define nbStatesFaders 25
	GLubyte Faders[nbStatesFaders * 10] = {
		0,0,1,0,0,0,0,0,0,0, // Faders
		2,2,1,2,2,2,2,2,2,2, // Faders
		3,3,1,3,3,3,3,3,3,3, // Faders
		4,4,1,4,4,4,4,4,4,4, // Faders
		5,5,1,5,5,5,5,5,5,5, // Faders
		6,6,1,6,6,6,6,6,6,6, // Faders
		7,7,1,7,7,7,7,7,7,7, // Faders
		8,8,1,8,8,8,8,8,8,8, // Faders
		9,9,1,9,9,9,9,9,9,9, // Faders
		10,10,1,10,10,10,10,10,10,10, // Faders
		11,11,1,11,11,11,11,11,11,11, // Faders
		12,12,1,12,12,12,12,12,12,12, // Faders
		13,13,1,13,13,13,13,13,13,13, // Faders
		14,14,1,14,14,14,14,14,14,14, // Faders
		15,15,1,15,15,15,15,15,15,15, // Faders
		16,16,1,16,16,16,16,16,16,16, // Faders
		17,17,1,17,17,17,17,17,17,17, // Faders
		18,18,1,18,18,18,18,18,18,18, // Faders
		19,19,1,19,19,19,19,19,19,19, // Faders
		20,20,1,20,20,20,20,20,20,20, // Faders
		21,21,1,21,21,21,21,21,21,21, // Faders
		22,22,1,22,22,22,22,22,22,22, // Faders
		23,23,1,23,23,23,23,23,23,23, // Faders
		24,24,1,24,24,24,24,24,24,24, // Faders
		0,0,1,0,0,0,0,0,0,0,
	}; // Faders
	ptr[0] = nbStatesFaders;
	for (int ind = 1; ind < std::min(width, nbStatesFaders * 10 + 1); ind++) {
		ptr[ind * 4] = Faders[ind - 1];
	}
	ptr += 4 * width;

	////////////////////////////////////////////
	// GENERAL BINARY FAMILY Moore Neighborhood: 1 neutral + 8 variants
	// Example: Fallski
	// C48,NM,Sb255a,Babb189ab63a
	// 48 states 0-47
	// Moore neihborhood Order N,NE,E,SE,S,SW,W,NW
	// states are encoded: S_N + 2 * S_NE + 4 * S_E + 8 * S_SE ... + 128 * S_NW
	// 00000000 0 neighbor
	// 10000000 N neighbor
	// 01000000 NE neighbor
	// 192 = 00000011 W and NW neighbors
	// Survive b255a survival on no alive neighbors: 
	//                             1 x one    255 x zeros
	// Birth   abb189ab63a birth on a single N or  NE neighbor, or on W and NW neighbors:
	//                             0 1 1   189 x zeros   1   63 x zeros
	// Encoding of Survival and Birth
	// 256 0/1 digits encode 

	// #38 line: nbStates/ encoding 2 * 256 transitions (encoding of 8 neighbors' directions)
	// #39-45 line: nbStates/ encoding in sequence of output states the 7 variants for 
	// each of the nbStates/ encoding 2 * 256 transitions (encoding of 8 neighbors' directions)

	// SubType 0: neutral
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = 0;
	}
	ptr += 4 * width;

	// Subtype 1: Fallski
	GLubyte transition_tableFallski[256 * 2] = {
		1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 48;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableFallski[ind - 1];
	}
	ptr += 4 * width;

	// ***************** GENERATIVE NIGHTS
	// Subtype 2: LogicRule
	// C0,NM,S256a, B3ababb5abaab4ab3ab23ab16ab14ab15ab32ab62ab63a
	GLubyte transition_tableLogicRule[256 * 2] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		// 0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableLogicRule[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 3: Slugfest
	GLubyte transition_tableSlugfest[256 * 2] = {
		1,1,1,1,0,0,0,1,0,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,1,0,1,0,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,1,1,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,0,1,0,
		0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,1,1,0,
	};
	ptr[0] = 20;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableSlugfest[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 4: Snowflakes
	GLubyte transition_tableSnowflakes[256 * 2] = {
		0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,1,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0,0,0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableSnowflakes[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 5: Springski
	GLubyte transition_tableSpringski[256 * 2] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 78;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableSpringski[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 6: personal oscillator #1
	GLubyte transition_tableCJ1[256 * 2] = {
		// SURVIVAL: NEW STATE (ONLY APPLIES IF CURRENT STATE != 0)
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 16-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 32-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 48-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 64-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 80-: 
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 96-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 112-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 128-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 144-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 160-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 176-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 192-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 208-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 224-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 240-

		// BIRTH: NEW STATE (ONLY APPLIES IF CURRENT STATE == 0)
		0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0, // 0-: 2, 8
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 16-
		1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 32-: 32
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 48-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 64-
		0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0, // 80-: 85
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 96-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 112-
		1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 128-: 128
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 144-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 160-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 176-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 192-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 208-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 224-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 240-
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableCJ1[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 7: personal oscillator #2
	GLubyte transition_tableCJ2[256 * 2] = {
		// SURVIVAL: NEW STATE (ONLY APPLIES IF CURRENT STATE != 0)
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0-
		0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 16-: 17
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 32-: 
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 48-
		0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0, // 64-: 68
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 80-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 96-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 112-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 128-:
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 144-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 160-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 176-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 192-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 208-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 224-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 240-

		// BIRTH: NEW STATE (ONLY APPLIES IF CURRENT STATE == 0)
		0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0, // 0-: 1,4
		2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 16-: 16
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 32-:
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 48-
		2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 64-:64
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 80-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 96-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 112-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 128-tt-tg-tppppppPPPPPPPPPPPPPPPPPPPppcfvg!
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 144-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 160-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 176-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 192-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 208-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 224-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 240-
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableCJ2[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 8: personal oscillator #3
	GLubyte transition_tableCJ3[256 * 2] = {
		// SURVIVAL: NEW STATE (ONLY APPLIES IF CURRENT STATE != 0)
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0-: 4
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 16-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 32-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 48-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 64-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 80-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 96-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 112-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 128-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 144-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 160-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 176-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 192-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 208-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 224-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 240-

		// BIRTH: NEW STATE (ONLY APPLIES IF CURRENT STATE == 0)
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 16-
		32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 32-: 32
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 48-
		32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 64-: 64
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 80-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 96-: 
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 112-
		32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 128-: 128
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 144-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 160-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 176-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 192-
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 208-
		32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 224-: 224
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 240-
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 256 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableCJ3[ind - 1];
	}
	ptr += 4 * width;

	////////////////////////////////////////////
	// GENERAL BINARY FAMILY von Neumann Neighborhood: 1 neutral + 3 variants

	// #46 line: nbStates/ encoding 2 * 16 transitions (encoding of 4 neighbors' directions)
	// #47-49 line: nbStates/ encoding in sequence of output states the 7 variants for 
	// each of the nbStates/ encoding 2 * 16 transitions (encoding of 4 neighbors' directions)

	// SubType 0: neutral
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 16 * 2 + 1); ind++) {
		ptr[ind * 4] = 0;
	}
	ptr += 4 * width;

	// Subtype 1: Banks
	GLubyte transition_tableBanks[16 * 2] = {
		1,1,1,0,1,1,0,1,1,0,1,1,0,1,1,1,
		0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 16 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableBanks[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 2: FractalBeads
	GLubyte transition_tableFractalBeads[16 * 2] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,
	};
	ptr[0] = 4;
	for (int ind = 1; ind < std::min(width, 16 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableFractalBeads[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 3: Sierpinski
	GLubyte transition_tableSierpinski[16 * 2] = {
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,
	};
	ptr[0] = 2;
	for (int ind = 1; ind < std::min(width, 16 * 2 + 1); ind++) {
		ptr[ind * 4] = transition_tableSierpinski[ind - 1];
	}
	ptr += 4 * width;


	////////////////////////////////////////////
	// NEUMANNN BINARY FAMILY : 1 neutral + 9 variants
	// Fredkin2 rule has the following definition: 2,01101001100101101001011001101001
	// The first digit, '2', tells the rule has 2 states (it's a 1 bit rule).
	// The second digit, '0', tells a cell in a configuration ME=0,N=0,E=0,S=0,W=0 will get the state 0.
	// The third digit, '1', tells a cell in a configuration ME=0,N=0,E=0,S=0,W=1 will get the state 1.
	// The fourth digit, '1', tells a cell in a configuration ME=0,N=0,E=0,S=1,W=0 will get the state 1.
	// The fifth digit, '0', tells a cell in a configuration ME=0,N=0,E=0,S=1,W=1 will get the state 0.
	// . . .
	// binary rules are extended to ternary for a uniform rule system

	// #50 line: nbStates/ encoding 3 * 81 transitions (encoding of 4 neighbors' directions with 3 states)
	// #51-68 line: nbStates/ encoding in sequence of output states the 7 variants for 
	// each of the nbStates/ encoding 3 * 81 transitions (encoding of 4 neighbors' directions with 3 states)

	// printf("table offset %d\n" , (int)(ptr - data_table)/(4 * width) );

	// SubType 0: neutral
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = 0;
	}
	ptr += 4 * width;

	// Subtype 1: Fredkin2
	GLubyte transition_tableFredkin2[243] = {
		0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableFredkin2[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 2: Aggregation
	GLubyte transition_tableAggregation[243] = {
		0,0,2,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,2,0,2,0,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,0,2,1,2,2,2,0,2,0,2,0,1,0,1,0,2,2,2,2,2,1,2,2,2,0,1,2,0,1,2,0,1,0,1,2,2,0,1,1,2,1,1,0,0,0,1,1,1,1,1,1,2,0,2,1,2,2,2,1,2,1,2,1,1,1,1,1,1,1,2,0,2,1,1,1,2,1,1
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableAggregation[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 3: Birds
	GLubyte transition_tableBirds[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,2,2,2,2,0,2,0,2,2,2,0,2,0,1,1,2,1,1,2,2,2,2,1,1,2,1,0,2,2,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,1,0,2,2,2,2,1,0,2,0,0,0,2,0,0,2,2,2,2,0,0,2,0,2,1,0,2,0,0,0,2,0,0,0,0,0,0,1,2,0,2,0,2,0,0,0,2,0,0,0,0,2,2,2,2,0,0,2,0,2,2,0,0,0,2,0,0,0,0,2,0,2,0,0,0,2,0,0,0,2,0,2,2,0,0,0,0,2,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,2,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableBirds[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 4: Colony
	GLubyte transition_tableColony[243] = {
		0,1,0,1,0,2,0,2,0,1,0,2,0,1,1,2,1,0,0,2,0,2,1,0,0,0,0,1,0,2,0,1,1,2,1,0,0,1,1,1,0,2,1,2,0,2,1,0,1,2,0,0,0,0,0,2,0,2,1,0,0,0,0,2,1,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,1,2,1,2,1,1,1,1,1,0,1,0,0,2,1,2,1,0,0,2,0,0,1,1,1,1,1,0,1,0,0,1,1,0,1,0,2,0,2,1,1,0,0,0,2,1,0,1,2,2,1,2,1,0,0,2,0,0,1,0,0,0,2,1,0,1,2,2,0,0,0,1,2,0,2,0,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableColony[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 5: Honeycomb
	GLubyte transition_tableHoneycomb[243] = {
		0,1,0,1,0,2,0,2,0,1,0,2,0,0,2,2,2,2,0,2,0,2,2,2,0,2,0,1,0,2,0,0,2,2,2,2,0,0,2,0,0,2,2,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,0,1,1,2,0,2,0,1,1,2,1,0,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,1,0,0,2,0,2,1,0,0,0,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,0,0,0,0,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,0,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,0,2,2,2,2,0,2,0,2,2,2,0,2,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableHoneycomb[ind - 1];
	}
	ptr += 4 * width;


	// Subtype 6: Lake
	GLubyte transition_tableLake[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,0,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,2,1,0,0,2,0,2,1,0,0,0,1,0,0,0,2,2,0,2,0,0,2,2,2,0,0,2,0,2,0,2,0,2,0,2,0,2,0,0,2,2,2,0,0,2,0,2,2,0,0,0,0,0,1,2,1,1,0,2,0,2,1,1,0,1,0,0,0,0,0,2,0,2,0,0,0,2,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,2,0,2,2,0,0,0,0,2,2,0,2,0,2,0,2,0,0,0,2,0,0,0,0,0,0,2,2,0,2,0,2,0,0,0,2,0,0,0,0,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableLake[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 7: Pond
	GLubyte transition_tablePond[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,2,2,2,2,0,2,0,2,2,2,0,2,0,1,1,2,1,1,2,2,2,2,1,1,2,1,0,2,2,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,0,1,0,2,0,2,0,1,0,2,0,1,0,2,0,2,0,2,0,2,0,2,0,2,0,1,0,2,0,1,0,2,0,2,0,1,0,1,1,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,0,2,0,2,0,0,0,0,0,0,2,0,2,2,0,0,0,0,2,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,2,2,0,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0,0,2,0,2,2,2,0,2,0,0,0,0,0,2,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tablePond[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 8: Strata
	GLubyte transition_tableStrata[243] = {
		0,0,0,0,0,0,2,0,0,1,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableStrata[ind - 1];
	}
	ptr += 4 * width;

	// Subtype 9: Tanks
	GLubyte transition_tableTanks[243] = {
		0,1,0,1,1,2,0,2,0,1,1,2,1,1,2,2,2,2,0,2,0,2,2,2,0,2,0,1,1,2,1,1,2,2,2,2,1,1,2,1,0,2,2,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,0,1,0,2,0,2,0,1,0,2,0,1,0,2,0,2,0,2,0,2,0,2,0,2,0,1,0,2,0,1,0,2,0,2,0,1,0,1,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,2,0,2,2,2,0,2,0,2,2,2,2,2,0,2,0,0,0,2,0,2,0,0,0,0,0,2,2,2,2,2,0,2,0,0,2,2,0,2,2,2,0,2,0,2,0,0,0,2,0,0,0,0,0,2,0,2,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0
	};
	ptr[0] = 3;
	for (int ind = 1; ind < std::min(width, 243 + 1); ind++) {
		ptr[ind * 4] = transition_tableTanks[ind - 1];
	}
	ptr += 4 * width;

	glEnable(GL_TEXTURE_RECTANGLE);
	glBindTexture(GL_TEXTURE_RECTANGLE, textureID);
	glTexParameterf(GL_TEXTURE_RECTANGLE, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_RECTANGLE, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_RECTANGLE, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameterf(GL_TEXTURE_RECTANGLE, GL_TEXTURE_WRAP_T, GL_CLAMP);
	glTexImage2D(GL_TEXTURE_RECTANGLE,     // Type of texture
		0,                 // Pyramid level (for mip-mapping) - 0 is the top level
		GL_RGBA8,            // Components: Internal colour format to convert to
		width,          // Image width
		height,          // Image heigh
		0,                 // Border width in pixels (can either be 1 or 0)
		GL_RGBA, // Format: Input image format (i.e. GL_RGB, GL_RGBA, GL_BGR etc.)
		GL_UNSIGNED_BYTE,  // Image data type
		data_table);        // The actual image data itself

	printOglError(4);
}
