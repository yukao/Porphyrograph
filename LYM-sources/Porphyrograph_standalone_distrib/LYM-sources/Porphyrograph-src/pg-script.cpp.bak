/*! \file pg-script.cpp
 * 
 * 
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free
 * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 */

#include "pg-all_include.h"

#ifdef TVW
#include "pg_script_body_TVW.cpp"
#endif
#ifdef CRITON
#include "pg_script_body_Criton.cpp"
#endif
#if defined(KOMPARTSD)
#include "pg_script_body_KompartSD.cpp"
bool testUDP_KOMPARTSD = false;
#endif
#if defined(LIGHT)
#include "pg_script_body_Light.cpp"
#endif
#if defined(RIVETS)
#include "pg_script_body_Rivets.cpp"
#endif
#if defined(CORE)
#include "pg_script_body_Core.cpp"
#endif
#if defined(FORET)
#include "pg_script_body_Foret.cpp"
#endif
#if defined(VOLUSPA)
#include "pg_script_body_voluspa.cpp"
#endif
#if defined(ARAKNIT)
#include "pg_script_body_araknit.cpp"
#endif
#if defined(CAAUDIO)
#include "pg_script_body_CAaudio.cpp"
#endif

std::string project_name = "core";

char AuxString[1024];

//////////////////////////////////////////////
// SCENARIO AND CONFIGURATION VARIABLES
// changed to true when a value is changed manually during scenario
bool BrokenInterpolationVar[_MaxInterpVarIDs];
// stepwise interpolation made only once
bool StepwiseInterpolationEffective[_MaxInterpVarIDs];
// initial values in the scenario (before first scene)
ScenarioValue InitialValuesInterpVar[_MaxInterpVarIDs][_NbConfigurations];
// rank of the scenario variable in the list of variables generated by python
int ConfigScenarioVarRank[_MaxInterpVarIDs][_NbConfigurations];
// var IDs in scenarios in the order in which they appear in the scenario
string ConfigScenarioVarIDs[_MaxInterpVarIDs][_NbConfigurations];
// number of vars in the scenario file
int ScenarioVarNb[_NbConfigurations] = {0};
// last value shipped to the GUI (PD)
float LastGUIShippedValuesInterpVar[_MaxInterpVarIDs][_NbConfigurations];
// initial values in the configuration file
//float InitialValuesConfigurationVar[_MaxConfigurationVarIDs];

//////////////////////////////////////////////
// beat no
int pg_BeatNo = 0;

//////////////////////////////////////////////
// beat no
int pg_MIDINote = 0;

//////////////////////////////////////////////
// Cuurent palette after interpolation
float pen_bandpass_3color_palette[3][3];

//////////////////////////////////////////////
// MIDI event creates a local stroke
int FourFrameStrokeNb = 5;
int FourFrameStroke_x = PG_OUT_OF_SCREEN_CURSOR;
int FourFrameStroke_y = PG_OUT_OF_SCREEN_CURSOR;

#if defined(var_GenerativeNights_planes)
//////////////////////////////////////////////
/// image number of first plane
int      firstPlaneFrameNo = -1;

//////////////////////////////////////////////
// CA initialization
float initCA = 0.0f;
#endif

/////////////////////////////////////////////////////////////////////////
// WORK VARIABLES
/////////////////////////////////////////////////////////////////////////

// ++++++++++++++++++++++ GLUT MODIFIER ++++++++++++++++++++ 
int pg_key_modifier = 0;

// ++++++++++++++++++++++ MUSIC CONTROL ++++++++++++++++++++ 
// music control inputs received at each frame

#if defined(PG_LIGHTS_CONTROL_IN_PG)
float pulse_light_prec[3] = { 0.f };
#if defined(var_light1_grey) && defined(var_light1_color) && defined(var_light1_dimmer) && defined(var_light1_strobe) && defined(var_light1_grey_pulse) && defined(var_light1_color_pulse) && defined(var_light1_dimmer_pulse) && defined(var_light1_strobe_pulse) 
float light1_color_prec = 0.f;
float light1_grey_prec = 0.f;
float light1_dimmer_prec = 0.f;
float light1_strobe_prec = 0.f;
// addition of color for light based on palette
float light1_color_pulse_prec = 0.f;
float light1_grey_pulse_prec = 0.f;
float light1_dimmer_pulse_prec = 0.f;
float light1_strobe_pulse_prec = 0.f;
#endif
#if defined(var_light2_grey) && defined(var_light2_color) && defined(var_light2_dimmer) && defined(var_light2_strobe) && defined(var_light2_grey_pulse) && defined(var_light2_color_pulse) && defined(var_light2_dimmer_pulse) && defined(var_light2_strobe_pulse) 
float light2_color_prec = 0.f;
float light2_grey_prec = 0.f;
float light2_dimmer_prec = 0.f;
float light2_strobe_prec = 0.f;
// addition of color for light based on palette
float light2_color_pulse_prec = 0.f;
float light2_grey_pulse_prec = 0.f;
float light2_dimmer_pulse_prec = 0.f;
float light2_strobe_pulse_prec = 0.f;
#endif
#if defined(var_light3_grey) && defined(var_light3_color) && defined(var_light3_dimmer) && defined(var_light3_strobe) && defined(var_light3_grey_pulse) && defined(var_light3_color_pulse) && defined(var_light3_dimmer_pulse) && defined(var_light3_strobe_pulse) 
float light3_color_prec = 0.f;
float light3_grey_prec = 0.f;
float light3_dimmer_prec = 0.f;
float light3_strobe_prec = 0.f;
// addition of color for light based on palette
float light3_color_pulse_prec = 0.f;
float light3_grey_pulse_prec = 0.f;
float light3_dimmer_pulse_prec = 0.f;
float light3_strobe_pulse_prec = 0.f;
#endif
#if defined(var_light4_grey) && defined(var_light4_color) && defined(var_light4_dimmer) && defined(var_light4_strobe) && defined(var_light4_grey_pulse) && defined(var_light4_color_pulse) && defined(var_light4_dimmer_pulse) && defined(var_light4_strobe_pulse) 
float light4_color_prec = 0.f;
float light4_grey_prec = 0.f;
float light4_dimmer_prec = 0.f;
float light4_strobe_prec = 0.f;
// addition of color for light based on palette
float light4_color_pulse_prec = 0.f;
float light4_grey_pulse_prec = 0.f;
float light4_dimmer_pulse_prec = 0.f;
float light4_strobe_pulse_prec = 0.f;
#endif
#if defined(var_light5_grey) && defined(var_light5_color) && defined(var_light5_dimmer) && defined(var_light5_strobe) && defined(var_light5_grey_pulse) && defined(var_light5_color_pulse) && defined(var_light5_dimmer_pulse) && defined(var_light5_strobe_pulse) 
float light5_color_prec = 0.f;
float light5_grey_prec = 0.f;
float light5_dimmer_prec = 0.f;
float light5_strobe_prec = 0.f;
// addition of color for light based on palette
float light5_color_pulse_prec = 0.f;
float light5_grey_pulse_prec = 0.f;
float light5_dimmer_pulse_prec = 0.f;
float light5_strobe_pulse_prec = 0.f;
#endif
#if defined(var_light6_grey) && defined(var_light6_color) && defined(var_light6_dimmer) && defined(var_light6_strobe) && defined(var_light6_grey_pulse) && defined(var_light6_color_pulse) && defined(var_light6_dimmer_pulse) && defined(var_light6_strobe_pulse) 
float light6_color_prec = 0.f;
float light6_grey_prec = 0.f;
float light6_dimmer_prec = 0.f;
float light6_strobe_prec = 0.f;
// addition of color for light based on palette
float light6_color_pulse_prec = 0.f;
float light6_grey_pulse_prec = 0.f;
float light6_dimmer_pulse_prec = 0.f;
float light6_strobe_pulse_prec = 0.f;
#endif
#if defined(var_light7_grey) && defined(var_light7_color) && defined(var_light7_dimmer) && defined(var_light7_strobe) && defined(var_light7_grey_pulse) && defined(var_light7_color_pulse) && defined(var_light7_dimmer_pulse) && defined(var_light7_strobe_pulse) 
float light7_color_prec = 0.f;
float light7_grey_prec = 0.f;
float light7_dimmer_prec = 0.f;
float light7_strobe_prec = 0.f;
// addition of color for light based on palette
float light7_color_pulse_prec = 0.f;
float light7_grey_pulse_prec = 0.f;
float light7_dimmer_pulse_prec = 0.f;
float light7_strobe_pulse_prec = 0.f;
#endif
#if defined(var_light8_grey) && defined(var_light8_color) && defined(var_light8_dimmer) && defined(var_light8_strobe) && defined(var_light8_grey_pulse) && defined(var_light8_color_pulse) && defined(var_light8_dimmer_pulse) && defined(var_light8_strobe_pulse) 
float light8_color_prec = 0.f;
float light8_grey_prec = 0.f;
float light8_dimmer_prec = 0.f;
float light8_strobe_prec = 0.f;
// addition of color for light based on palette
float light8_color_pulse_prec = 0.f;
float light8_grey_pulse_prec = 0.f;
float light8_dimmer_pulse_prec = 0.f;
float light8_strobe_pulse_prec = 0.f;
#endif
#endif

// addition of colorfor pen  based on palette
float pulsed_pen_color[4];
float pulsed_repop_colorPart[3];
float pulsed_repop_colorBG[3];
float pulsed_repop_colorCA[3];

// memory of preceding pulsed color values to avoid unnecessary update
float repop_colorBG_prec = -1.f;
float repop_colorBG_pulse_prec = -1.f;
float repop_greyBG_prec = -1.f;
float repop_greyBG_pulse_prec = -1.f;

float repop_colorCA_prec = -1.f;
float repop_colorCA_pulse_prec = -1.f;
float repop_greyCA_prec = -1.f;
float repop_greyCA_pulse_prec = -1.f;

#if defined(var_pen_color)
float pen_color_prec = -1.f;
float pen_color_pulse_prec = -1.f;
#endif
#if defined(var_pen_grey)
float pen_grey_prec = -1.f;
float pen_grey_pulse_prec = -1.f;
#endif
#if defined(var_pen_hue)
float pen_hue_prec = -1.f;
float pen_hue_pulse_prec = -1.f;
#endif
#if defined(var_pen_sat)
float pen_sat_prec = -1.f;
float pen_sat_pulse_prec = -1.f;
#endif
#if defined(var_pen_value)
float pen_value_prec = -1.f;
float pen_value_pulse_prec = -1.f;
#endif

#if defined(var_repop_colorPart) && defined(var_repop_greyPart)
float repop_colorPart_prec = -1.f;
float repop_colorPart_pulse_prec = -1.f;
float repop_greyPart_prec = -1.f;
float repop_greyPart_pulse_prec = -1.f;
#endif
#if defined(var_repop_huePart)
float repop_huePart_prec = -1.f;
float repop_huePart_pulse_prec = -1.f;
#endif
#if defined(var_repop_satPart)
float repop_satPart_prec = -1.f;
float repop_satPart_pulse_prec = -1.f;
#endif
#if defined(var_repop_valuePart)
float repop_valuePart_prec = -1.f;
float repop_valuePart_pulse_prec = -1.f;
#endif

float pulse_prec[3] = { -1.f };

// factor increasing the acceleration weight of pixels, the brush radius, color...
// based on sound volume attacks
float pulse_average;
float pulse_average_prec = -1.f;
float pulse[3] = { 0.0f };
float seed_pulsePerlinNoise[4 * 2] 
	= { rand_0_1 * 255, rand_0_1 * 255, rand_0_1 * 255, rand_0_1 * 255, 
		rand_0_1 * 255, rand_0_1 * 255, rand_0_1 * 255, rand_0_1 * 255 };
// not used currently float pulse_attack;

// auxiliary 
bool synchr_start_recording_path[PG_NB_PATHS + 1];
int synchr_start_path_replay_trackNo[PG_NB_PATHS + 1];
bool recorded_path[PG_NB_PATHS + 1];
bool is_path_replay[PG_NB_PATHS + 1];

// current working directory
std::string cwd;

// track loading 
int currentClipArtTrack = 0;

// sound track playing
int currentlyPlaying_trackNo = -1;
bool soundTrack_on = true;

// movie soundtrack passes over an onset or a peak before next frame
bool pg_track_sound_onset = false;
bool pg_track_sound_peak = false;

// movie playing
int currentlyPlaying_movieNo = -1;
float current_extern_movieNo = -1;

// movie soundtrack passes over an onset or a peak before next frame
bool pg_movie_sound_onset = false;
bool pg_movie_sound_peak = false;
// pen preset
int current_pen_colorPreset = -1;

// ++++++++++++++++++++++ FLASHES +++++++++++++++++++++++++
// flash: Trk->CA -> values passed to the shader
// as a function of on/off values and weights
float flashTrkCA_weights[PG_NB_TRACKS];
int flashTrkCA_weights_duration[PG_NB_TRACKS];
// flash: Trk->Part -> values passed to the shader
// as a function of on/off values and weights
float flashTrkPart_weights[PG_NB_TRACKS];
int flashTrkPart_weights_duration[PG_NB_TRACKS];
// flash: Trk->BG   -> values passed to the shader
// as a function of on/off values and weights
// only tracks 1 and 2 are concerned since it is a projection on track0
float flashTrkBG_weights[PG_NB_TRACKS];
int flashTrkBG_weights_duration[PG_NB_TRACKS];
// flash: CA->BG
float flashCABG_weight;
int flashCABG_weight_duration;
// flash: CA->Part
float flashCAPart_weight;
int flashCAPart_weight_duration;
// flash: Part->BG
float flashPartBG_weight;
int flashPartBG_weight_duration;
// flash: Part->CA
float flashPartCA_weight;
int flashPartCA_weight_duration;
// flash: extension of pixel reproduction  
int flashPixel;
// one-frame master flashing  
int flashMaster;

#if defined(var_Argenteuil_flashchange_diaporama_freq)
// diaporama change flashing with a first pass on a permutation of all the images
int var_Argenteuil_flashchange_diaporama_pass = -1;
std::vector<int> imageRanksPermutation;
#endif


int flashTrkCA_freq_0_saved = 0;
#if PG_NB_TRACKS >= 2
int flashTrkCA_freq_1_saved = 0;
#endif
#if PG_NB_TRACKS >= 3
int flashTrkCA_freq_2_saved = 0;
#endif
#if PG_NB_TRACKS >= 4
int flashTrkCA_freq_3_saved = 0;
#endif

int flashTrkPart_freq_0_saved = 0;
#if PG_NB_TRACKS >= 2
int flashTrkPart_freq_1_saved = 0;
#endif
#if PG_NB_TRACKS >= 3
int flashTrkPart_freq_2_saved = 0;
#endif
#if PG_NB_TRACKS >= 4
int flashTrkPart_freq_3_saved = 0;
#endif

int flashTrkBG_freq_1_saved = 0;
int flashTrkBG_freq_2_saved = 0;

// +++++++++++++++++++++ VIDEO FLASH +++++++++++++++++++++
bool is_flashCameraTrk = false;
float flashCameraTrk_weight = 0.0f;
float flashCameraTrk_decay = 1.0f;
float flashCameraTrk_threshold = 0.5f;
#if defined(var_flashPhotoTrkBeat) && defined(var_flashPhotoTrkBright) && defined(var_flashPhotoTrkLength) && defined(var_flashPhotoChangeBeat)
bool is_flashPhotoTrk = false;
float flashPhotoTrk_weight = 0.0f;
float flashPhotoTrk_decay = 1.0f;
float flashPhotoTrk_threshold = 0.5f;
int flashPhotoTrk_nbFrames = 0;
#endif

// +++++++++++++++++++++ VIDEO BACKGROUND SUBTRACTION +++++
bool is_firstVideoOn = true;

// +++++++++++++++++++++ CLEAR +++++++++++++++++++++++++++
int isClearCA;
int isClearLayer;
int isClearAllLayers;
int isClearEcho;

// +++++++++++++++++++++ SETUP +++++++++++++++++++++++++++
double LastSetupChangeClockTime = 0;
double LastTrackRecordingChangeClockTime = 0;

// +++++++++++++++++++++ DELAYED CAMERA WEIGHT ++++++++++++
int delayedCameraWeight = 0;

#ifdef PG_WITH_BLUR
// +++++++++++++++++++++ BLUR +++++++++++++++++++++++++++
bool is_blur_1 = false;
bool is_blur_2 = false;
int nb_blur_frames_1 = 0;
int nb_blur_frames_2 = 0;
#endif

// +++++++++++++++++++++ COPY LAYERS +++++++++++++++++++++++++++
// copy to layer above (+1) or to layer below (-1)
int copyToNextTrack = 0;

// ++++++++++++++++++++++ SET-UP +++++++++++++++++++++++++++ 
int pg_CurrentSceneIndex = -1;
Scene *pg_CurrentScene = NULL;
float pg_setup_interpolation_duration = 0.f;

// scene management
bool pg_FirstFrameInScene = true;
double remainingTimeInScene = 0.;

// interpolation scene between two discontinuous scenes so that there is no visual gap inbetween
int pg_SceneIndexAfterInterpolation = -1;
int pg_SceneIndexBeforeInterpolation = -1;
float pg_SceneInterpolationDuration = 0.f;
Scene pg_InterpolationScene;
bool* pg_variable_updated = NULL;
pg_Parameter_Input_Type* pg_variable_param_input_type = NULL;
ScenarioValue *pg_variable_scenario_or_gui_command_value = NULL;

// master automatic incay/decay
double pg_master_incay_duration = 0.;
double pg_master_incay_start_time = 0.;
float pg_master_incay_start_value = 0.f;
double pg_master_decay_duration = 0.;
double pg_master_decay_start_time = 0.;
float pg_master_decay_start_value = 1.f;

// resend all values (fx after interface crash)
bool resend_all_variables = true;

// resend all light values (fx after interface crash)
bool resend_all_light_variables = true;

// working variables 
int drawing_start_frame;

// SCENARIO LAUNCH TIME
double InitialScenarioTime;
double AbsoluteInitialScenarioTime;


// +++++++++++++++++++++++ CLEAR AND INVERT +++++++++++++++++++++++++++++++++
double lastClearTime = 0.;
int lastClearSceneIndex = -1;

// +++++++++++++++++++++++ Beats +++++++++++++++++++++++++++++++++
double lastBeatTime = 0.;

// +++++++++++++++++++++++ CA SubType memory for CA on/off command ++++++++++
int CASubTypeMem = 1;

#if defined(CAAUDIO) || defined(RIVETS)
pg_CAseed_types pg_CAseed_type = _pg_CAseed_dot_center;
pg_CAseed_locations pg_CAseed_location = _pg_CAseed_loc_center;
int pg_CAseed_coordinates[2] = { -1, -1 };
int pg_CAseed_size = 1;
bool pg_CAseed_trigger = false;
#endif

// +++++++++++++++++++++++ FFT levels and frequency storage ++++++++++++++++++++
#ifdef CRITON
float fftLevels[8];
float fftFrequencies[8];
float fftPhases[8];
#endif

// +++++++++++++++++++++++ Buttons and labels for ATELIERSENFANTS interface +++++
vector<string> FondButtonsPaths = { "/fond/fond1", "/fond/fond2", "/fond/fond3", "/fond/fond4" };
vector<string> FondButtonLabelsPaths = { "/fond/fond1_label", "/fond/fond2_label", "/fond/fond3_label", "/fond/fond4_label" };
vector<int> FondButtonValues = { 0, 1, 2, 3 };

vector<string> DessinButtonsPaths = { "/page/dessin", "/page/serpent", "/page/avion" };
vector<string> DessinButtonLabelsPaths = { "/page/dessin_label", "/page/serpent_label", "/page/avion_label" };
vector<float> DessinButtonValues = { 0.f, 0.002f, 0.02f };

vector<string> StylusvsRubberButtonsPaths = { "/trait/rubber", "/trait/pen" };
vector<string> StylusvsRubberButtonLabelsPaths = { "/trait/rubber_label", "/trait/pen_label" };
vector<int> StylusvsRubberButtonValues = { pg_Rubber, pg_Stylus };


// +++++++++++++++++++++++ Clip ranges for automatic clip selection for ContAct +++++
#if defined(var_Contact_clip_in_range)
std::vector<int> ContAct_clip_ranges_min;
std::vector<int> ContAct_clip_ranges_max;
#endif


///////////////////////////////////////////////////////////////////////////////////
// HASH MAP FOR STRING COMMANDS
enum pg_OSC_addresses_hashMap_IDs
{
	_testUDP = _MaxInterpVarIDs,
	_QT_connected,
	_PD_connected,
	_return_message,
	_launch,
	_reset_sound,
	_connect_PD,
	_quit,
	_flashCamera,
	_Note1,
	_Note2,
	_Note3,
	_Velocity1,
	_Velocity2,
	_Velocity3,
	_flashPhoto,
	_pulse_spectrum,
	_beat,
	_MIDINote,
	_flashTrkCA_onOff,
	_flashTrkPart_onOff,
	_snapshot,
	_initialBGCapture,
	_initCA,
	_currentVideoTrack_plus,
	_currentPhotoTrack_plus,
	_minimal_display,
	_paths_display,
	_new_scene,
	_pen_xy,
	_pen2_xy,
	_pen3_xy,
	_pen4_xy,
	_pen5_xy,
	_abs_pen_xy,
	_copyTrack_above,
	_copyTrack_under,
	_partStroke_mode_0,
	_partStroke_mode_1,
	_partStroke_mode_2,
	_partColor_mode_0,
	_partColor_mode_1,
	_partColor_mode_2,
	_partExit_mode_0,
	_partExit_mode_1,
	_partExit_mode_2,
#ifdef PG_WITH_BLUR
	_is_blur_1,
	_is_blur_1_plus,
	_is_blur_1_plus_plus,
	_is_blur_2,
#endif
	_cameraCumul_plus,
	_pen_brush_plus,
	_pen_brush_minus,
	_pen_brush_replay_plus,
	_pen_brush_replay_minus,
	_pixel_mode_plus,
#if defined(var_nb_CATypes)
	_CA1Type_plus,
	_CA1SubType_plus,
	_CA1Type_minus,
	_CA1SubType_minus,
	_CAonOff,
#endif
	_sensor_layout_plus,
	_sensor_sample_setUp_plus,
	_sensor_activation_plus,
	_partExit_mode_plus,
	_partStroke_mode_plus,
	_partColor_mode_plus,
	_pen_BW,
	_repopBG_BW,
	_repopCA_BW,
	_repopPart_BW,
	_pressure_onOff,
	_diaporama_random,
	_diaporama_plus,
	_diaporama_minus,
	_flash_photo_diaporama,
	_soundtrack_plus,
	_soundtrack_minus,
	_soundtrack_onOff,
	_soundtrack_volume,
	_soundtrack_seek,
	_pen_colorPreset_minus,
	_pen_colorPreset_plus,
	_pen_colorPreset,
#if defined(CAAUDIO) || defined(RIVETS)
	_CAseed_dot_center,
	_CAseed_dot,
	_CAseed_h_line,
	_CAseed_v_line,
	_CAseed_cross,
	_CAseed_X,
	_CAseed_square,
	_CAseed_size,
	_CAseed_loc,
	_CAseed_loc_plus,
	_CAseed_trigger,
#endif
	_movie_loop_onOff,
	_movie_plus,
	_movie_minus,
	_movie_forward,
	_movie_backward,
	_camera_open,
	_camera_close,
	_clip_plus,
	_clip_minus,
	_clip_forward,
	_clip_backward,
	_clip_scratch,
	_clip_scratch_touch_press,
	_clip_scratch_touch_release,
	_clip_nudge,
	_clip_nudge_touch_press,
	_clip_nudge_touch_release,
	_clip_cue_onOff,
	_clip_cue_jump,
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	_clip2_cue_jump,
#endif
	_clip_cue_call,
	_clip_fx,
	_clip_fx_std,
	_clip_equalizer,
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	_clip2_equalizer,
#endif
	_clip_sample,
	_clip_sample_range,
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	_clip2_sample,
#endif
	_clip_sample_shift,
	_clip_new,
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	_clip2_new,
#endif
	_clip_fader,
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	_clip2_fader,
#endif
	_clip_autoplay_left,
	_clip_autoplay_right,
	_clip_play_left,
	_clip_play_right,
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	_clip2_autoplay_left,
	_clip2_autoplay_right,
	_clip2_play_left,
	_clip2_play_right,
#endif
	_resend_all,
	_resend_all_light,
	_configurationNo,
	_setupNo,
	_setupName,
	_setup_plus,
	_setup_plus_5,
	_setup_minus,
	_setup_minus_5,
	_setup_plus_keep_total_dur,
	_interpolation_duration,
	_master_decay,
	_master_incay,
#ifdef CRITON
	_JUCE_loop_track,
	_JUCE_exit,
	_fftLevel8,
#endif
	_ClipArt_1_onOff,
	_ClipArt_2_onOff,
	_ClipArt_3_onOff,
	_ClipArt_4_onOff,
	_ClipArt_5_onOff,
	_ClipArt_6_onOff,
	_ClipArt_7_onOff,
	_ClipArt_8_onOff,
	_ClipArt_9_onOff,
	_ClipArt_10_onOff,
	_ClipArt_11_onOff,
	_ClipArt_12_onOff,
	_ClipArt_13_onOff,
	_ClipArt_14_onOff,
	_ClipArt_15_onOff,
	_ClipArt_16_onOff,
	_ClipArt_17_onOff,
	_ClipArt_18_onOff,
	_ClipArt_19_onOff,
	_ClipArt_20_onOff,
	_ClipArt_onOff,
	_ClipArt_off,
	_ClipArt_on,
	_ClipArt_SubPath_1_onOff,
	_ClipArt_SubPath_2_onOff,
	_ClipArt_SubPath_3_onOff,
	_ClipArt_SubPath_4_onOff,
	_ClipArt_scale,
	_ClipArt_rotate,
	_ClipArt_xy,
	_ClipArt_x,
	_ClipArt_y,
	_ClipArt_nat_color,
	_ClipArt_white_color,
	_ClipArt_red_color,
	_ClipArt_green_color,
	_ClipArt_blue_color,
	_ClipArt_yellow_color,
	_ClipArt_cyan_color,
	_ClipArt_magenta_color,
	_ClipArt_black_color,
	_ClipArt_translations,
#if defined(var_activeMeshes)
	_Mesh_onOff,
#if defined(var_Caverne_Mesh_Profusion)
	_Caverne_Mesh_Profusion_on,
	_Caverne_Mesh_Profusion_off,
	_Caverne_Mesh_7Solids_on,
	_Caverne_Mesh_7Solids_off,
	_Caverne_BackColor_onOff,
#endif
	_Mesh_mobile_onOff,
	_Mesh_light_x,
	_Mesh_light_y,
	_Mesh_light_z,
#endif
	_muteRightScreen_onOff,
	_isClearAllLayers,
	_StylusvsRubber,
#if defined(var_pen_hue) && defined(var_pen_sat) && defined(var_pen_value)
	_pen_hue_sat_value,
#endif
#if defined(var_repop_huePart) && defined(var_repop_satPart) && defined(var_repop_valuePart)
	_repop_hue_sat_valuePart,
#endif
	_take_snapshot,
	_path_replay_stopAll,
	_path_replay_playAll,
	_clear_path_group,
#ifdef PG_METAWEAR
	_mw_mss_pos,
#endif
	_cameraWB_R_plus,
	_cameraWB_B_plus,
	_cameraExposure_plus,
	_cameraGain_plus,
	_cameraBrightness_plus,
	_cameraSaturation_plus,
	_cameraContrast_plus,
	_cameraGamma_plus,
	_cameraWB_R_minus,
	_cameraWB_B_minus,
	_cameraExposure_minus,
	_cameraGain_minus,
	_cameraBrightness_minus,
	_cameraSaturation_minus,
	_cameraContrast_minus,
	_cameraGamma_minus,
	_reset_on_camera,
	_reset_camera_params,
	_processing_video,
	_processing_image,
	_processing_master,
	_BottomLeft,
	_BottomRight,
	_TopLeft,
	_TopRight,
	_ZeroLight,
	_flashPixel,
	_flashTrkPart,
	_flashTrkCA,
	_flashCABG,
	_flashCAPart,
	_flashMaster,
	_NextRecordReplayPath,
};
// Create an unordered_map of three strings (that map to strings)
std::unordered_map<std::string, int> pg_OSC_addresses_hashMap = {
	{ "testUDP", _testUDP },
	{ "QT_connected", _QT_connected },
	{ "PD_connected", _PD_connected },
	{ "return_message", _return_message },
	{ "launch", _launch },
	{ "reset_sound", _reset_sound },
	{ "connect_PD", _connect_PD },
	{ "quit", _quit },
	{ "flashCamera", _flashCamera },
	{ "Note1", _Note1 },
	{ "Note2", _Note2 },
	{ "Note3", _Note3 },
	{ "Velocity1", _Velocity1 },
	{ "Velocity2", _Velocity2 },
	{ "Velocity3", _Velocity3 },
	{ "flashPhoto", _flashPhoto },
	{ "pulse_spectrum", _pulse_spectrum },
	{ "MIDINote", _MIDINote },
	{ "beat", _beat },
	{ "flashTrkCA_onOff", _flashTrkCA_onOff },
	{ "flashTrkPart_onOff", _flashTrkPart_onOff },
	{ "snapshot", _snapshot },
	{ "initialBGCapture", _initialBGCapture },
	{ "initCA", _initCA },
	{ "currentVideoTrack_plus", _currentVideoTrack_plus },
	{ "currentPhotoTrack_plus", _currentPhotoTrack_plus },
	{ "minimal_display", _minimal_display },
	{ "paths_display", _paths_display },
	{ "new_scene", _new_scene },
	{ "pen_xy", _pen_xy },
	{ "pen2_xy", _pen2_xy },
	{ "pen3_xy", _pen3_xy },
	{ "pen4_xy", _pen4_xy },
	{ "pen5_xy", _pen5_xy },
	{ "abs_pen_xy", _abs_pen_xy },
	{ "copyTrack_above", _copyTrack_above },
	{ "copyTrack_under", _copyTrack_under },
	{ "partStroke_mode_0", _partStroke_mode_0 },
	{ "partStroke_mode_1", _partStroke_mode_1 },
	{ "partStroke_mode_2", _partStroke_mode_2 },
	{ "partColor_mode_0", _partColor_mode_0 },
	{ "partColor_mode_1", _partColor_mode_1 },
	{ "partColor_mode_2", _partColor_mode_2 },
	{ "partExit_mode_0", _partExit_mode_0 },
	{ "partExit_mode_1", _partExit_mode_1 },
	{ "partExit_mode_2", _partExit_mode_2 },
#ifdef PG_WITH_BLUR
	{ "is_blur_1", _is_blur_1 },
	{ "is_blur_1_plus", _is_blur_1_plus },
	{ "is_blur_1_plus_plus", _is_blur_1_plus_plus },
	{ "is_blur_2", _is_blur_2 },
#endif
	{ "cameraCumul_plus", _cameraCumul_plus },
	{ "pen_brush_plus", _pen_brush_plus },
	{ "pen_brush_minus", _pen_brush_minus },
	{ "pen_brush_replay_minus", _pen_brush_replay_minus },
	{ "pen_brush_replay_plus", _pen_brush_replay_plus },
	{ "pixel_mode_plus", _pixel_mode_plus },
#if defined(var_nb_CATypes)
	{ "CA1Type_plus", _CA1Type_plus },
	{ "CA1SubType_plus", _CA1SubType_plus },
	{ "CA1Type_minus", _CA1Type_minus },
	{ "CA1SubType_minus", _CA1SubType_minus },
	{ "CAonOff", _CAonOff },
#endif
	{ "sensor_layout_plus", _sensor_layout_plus },
	{ "sensor_sample_setUp_plus", _sensor_sample_setUp_plus },
	{ "sensor_activation_plus", _sensor_activation_plus },
	{ "partExit_mode_plus", _partExit_mode_plus },
	{ "partStroke_mode_plus", _partStroke_mode_plus },
	{ "partColor_mode_plus", _partColor_mode_plus },
	{ "pen_BW", _pen_BW },
	{ "repopBG_BW", _repopBG_BW },
	{ "repopCA_BW", _repopCA_BW },
	{ "repopPart_BW", _repopPart_BW },
	{ "pressure_onOff", _pressure_onOff },
	{ "diaporama_random", _diaporama_random },
	{ "diaporama_plus", _diaporama_plus },
	{ "diaporama_minus", _diaporama_minus },
	{ "flash_photo_diaporama", _flash_photo_diaporama },
	{ "soundtrack_plus", _soundtrack_plus },
	{ "soundtrack_minus", _soundtrack_minus },
	{ "soundtrack_onOff", _soundtrack_onOff },
	{ "soundtrack_volume", _soundtrack_volume },
	{ "soundtrack_seek", _soundtrack_seek },
	{ "pen_colorPreset_minus", _pen_colorPreset_minus },
	{ "pen_colorPreset_plus", _pen_colorPreset_plus },
	{ "pen_colorPreset", _pen_colorPreset },
#if defined(CAAUDIO) || defined(RIVETS)
	{ "CAseed_dot_center", _CAseed_dot_center },
	{ "CAseed_dot", _CAseed_dot },
	{ "CAseed_h_line", _CAseed_h_line },
	{ "CAseed_v_line", _CAseed_v_line },
	{ "CAseed_cross", _CAseed_cross },
	{ "CAseed_X", _CAseed_X },
	{ "CAseed_square", _CAseed_square },
	{ "CAseed_size", _CAseed_size },
	{ "CAseed_loc", _CAseed_loc },
	{ "CAseed_loc_plus", _CAseed_loc_plus },
	{ "CAseed_trigger", _CAseed_trigger },
#endif
	{ "movie_loop_onOff", _movie_loop_onOff },
	{ "movie_plus", _movie_plus },
	{ "movie_minus", _movie_minus },
	{ "movie_forward", _movie_forward },
	{ "movie_backward", _movie_backward },
	{ "camera_open", _camera_open },
	{ "camera_close", _camera_close },
	{ "clip_plus", _clip_plus },
	{ "clip_minus", _clip_minus },
	{ "clip_forward", _clip_forward },
	{ "clip_backward", _clip_backward },
	{ "clip_scratch", _clip_scratch },
	{ "clip_scratch_touch_press", _clip_scratch_touch_press },
	{ "clip_scratch_touch_release", _clip_scratch_touch_release },
	{ "clip_nudge", _clip_nudge },
	{ "clip_nudge_touch_press", _clip_nudge_touch_press },
	{ "clip_nudge_touch_release", _clip_nudge_touch_release },
	{ "clip_cue_onOff", _clip_cue_onOff },
	{ "clip_cue_jump", _clip_cue_jump },
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	{ "clip2_cue_jump", _clip2_cue_jump },
#endif
	{ "clip_cue_call", _clip_cue_call },
	{ "clip_fx", _clip_fx },
	{ "clip_fx_std", _clip_fx_std },
	{ "clip_equalizer", _clip_equalizer },
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	{ "clip2_equalizer", _clip2_equalizer },
#endif
	{ "clip_sample", _clip_sample },
	{ "clip_sample_range", _clip_sample_range },
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	{ "clip2_sample", _clip2_sample },
#endif
	{ "clip_sample_shift", _clip_sample_shift },
	{ "clip_new", _clip_new },
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	{ "clip2_new", _clip2_new },
	{ "clip_fader", _clip_fader },
	{ "clip2_fader", _clip2_fader },
#endif
	{ "clip_autoplay_left", _clip_autoplay_left },
	{ "clip_autoplay_right", _clip_autoplay_right },
	{ "clip_play_left", _clip_play_left },
	{ "clip_play_right", _clip_play_right },
#if defined(var_clipCaptFreq) && PG_NB_PARALLEL_CLIPS >= 2
	{ "clip2_autoplay_left", _clip_autoplay_left },
	{ "clip2_autoplay_right", _clip_autoplay_right },
	{ "clip2_play_left", _clip_play_left },
	{ "clip2_play_right", _clip_play_right },
#endif
	{ "resend_all", _resend_all },
	{ "resend_all_light", _resend_all_light },
	{ "configurationNo", _configurationNo },
	{ "setupNo", _setupNo },
	{ "setupName", _setupName },
	{ "setup_plus", _setup_plus },
	{ "setup_plus_5", _setup_plus_5 },
	{ "setup_minus", _setup_minus },
	{ "setup_minus_5", _setup_minus_5 },
	{ "setup_plus_keep_total_dur", _setup_plus_keep_total_dur },
	{ "interpolation_duration", _interpolation_duration },
	{ "master_decay", _master_decay },
	{ "master_incay", _master_incay },
#ifdef CRITON
	{ "JUCE_loop_track", _JUCE_loop_track },
	{ "JUCE_exit", _JUCE_exit },
	{ "fftLevel8", _fftLevel8 },
#endif
	{ "ClipArt_1_onOff", _ClipArt_1_onOff },
	{ "ClipArt_2_onOff", _ClipArt_2_onOff },
	{ "ClipArt_3_onOff", _ClipArt_3_onOff },
	{ "ClipArt_4_onOff", _ClipArt_4_onOff },
	{ "ClipArt_5_onOff", _ClipArt_5_onOff },
	{ "ClipArt_6_onOff", _ClipArt_6_onOff },
	{ "ClipArt_7_onOff", _ClipArt_7_onOff },
	{ "ClipArt_8_onOff", _ClipArt_8_onOff },
	{ "ClipArt_9_onOff", _ClipArt_9_onOff },
	{ "ClipArt_10_onOff", _ClipArt_10_onOff },
	{ "ClipArt_11_onOff", _ClipArt_11_onOff },
	{ "ClipArt_12_onOff", _ClipArt_12_onOff },
	{ "ClipArt_13_onOff", _ClipArt_13_onOff },
	{ "ClipArt_14_onOff", _ClipArt_14_onOff },
	{ "ClipArt_15_onOff", _ClipArt_15_onOff },
	{ "ClipArt_16_onOff", _ClipArt_16_onOff },
	{ "ClipArt_17_onOff", _ClipArt_17_onOff },
	{ "ClipArt_18_onOff", _ClipArt_18_onOff },
	{ "ClipArt_19_onOff", _ClipArt_19_onOff },
	{ "ClipArt_20_onOff", _ClipArt_20_onOff },
	{ "ClipArt_onOff", _ClipArt_onOff },
	{ "ClipArt_off", _ClipArt_off },
	{ "ClipArt_on", _ClipArt_on },
	{ "ClipArt_SubPath_1_onOff", _ClipArt_SubPath_1_onOff },
	{ "ClipArt_SubPath_2_onOff", _ClipArt_SubPath_2_onOff },
	{ "ClipArt_SubPath_3_onOff", _ClipArt_SubPath_3_onOff },
	{ "ClipArt_SubPath_4_onOff", _ClipArt_SubPath_4_onOff },
	{ "ClipArt_scale", _ClipArt_scale },
	{ "ClipArt_rotate", _ClipArt_rotate },
	{ "ClipArt_xy", _ClipArt_xy },
	{ "ClipArt_x", _ClipArt_x },
	{ "ClipArt_y", _ClipArt_y },
	{ "ClipArt_nat_color", _ClipArt_nat_color },
	{ "ClipArt_white_color", _ClipArt_white_color },
	{ "ClipArt_red_color", _ClipArt_red_color },
	{ "ClipArt_green_color", _ClipArt_green_color },
	{ "ClipArt_blue_color", _ClipArt_blue_color },
	{ "ClipArt_yellow_color", _ClipArt_yellow_color },
	{ "ClipArt_cyan_color", _ClipArt_cyan_color },
	{ "ClipArt_magenta_color", _ClipArt_magenta_color },
	{ "ClipArt_black_color", _ClipArt_black_color },
	{ "ClipArt_translations", _ClipArt_translations },
#if defined(var_activeMeshes)
	{ "Mesh_onOff", _Mesh_onOff },
#if defined(var_Caverne_Mesh_Profusion)
	{ "Caverne_Mesh_Profusion_on", _Caverne_Mesh_Profusion_on },
	{ "Caverne_Mesh_Profusion_off", _Caverne_Mesh_Profusion_off },
	{ "Caverne_Mesh_7Solids_on", _Caverne_Mesh_7Solids_on },
	{ "Caverne_Mesh_7Solids_off", _Caverne_Mesh_7Solids_off },
	{ "Caverne_BackColor_onOff", _Caverne_BackColor_onOff },
#endif
	{ "Mesh_mobile_onOff", _Mesh_mobile_onOff },
	{ "Mesh_light_x", _Mesh_light_x },
	{ "Mesh_light_y", _Mesh_light_y },
	{ "Mesh_light_z", _Mesh_light_z },
#endif
	{ "muteRightScreen_onOff", _muteRightScreen_onOff },
	{ "isClearAllLayers", _isClearAllLayers },
	{ "StylusvsRubber", _StylusvsRubber },
#if defined(var_pen_hue) && defined(var_pen_sat) && defined(var_pen_value)
	{ "pen_hue_sat_value", _pen_hue_sat_value },
#endif
#if defined(var_repop_huePart) && defined(var_repop_satPart) && defined(var_repop_valuePart)
	{ "repop_hue_sat_valuePart", _repop_hue_sat_valuePart },
#endif
	{ "take_snapshot", _take_snapshot },
	{ "path_replay_stopAll", _path_replay_stopAll },
	{ "path_replay_playAll", _path_replay_playAll },
	{ "clear_path_group", _clear_path_group },
#ifdef PG_METAWEAR
	{ "mw_mss_pos", _mw_mss_pos },
#endif
	{ "cameraWB_R_plus", _cameraWB_R_plus },
	{ "cameraWB_B_plus", _cameraWB_B_plus },
	{ "cameraExposure_plus", _cameraExposure_plus },
	{ "cameraGain_plus", _cameraGain_plus },
	{ "cameraBrightness_plus", _cameraBrightness_plus },
	{ "cameraSaturation_plus", _cameraSaturation_plus },
	{ "cameraContrast_plus", _cameraContrast_plus },
	{ "cameraGamma_plus", _cameraGamma_plus },
	{ "cameraWB_R_minus", _cameraWB_R_minus },
	{ "cameraWB_B_minus", _cameraWB_B_minus },
	{ "cameraExposure_minus", _cameraExposure_minus },
	{ "cameraGain_minus", _cameraGain_minus },
	{ "cameraBrightness_minus", _cameraBrightness_minus },
	{ "cameraSaturation_minus", _cameraSaturation_minus },
	{ "cameraContrast_minus", _cameraContrast_minus },
	{ "cameraGamma_minus", _cameraGamma_minus },
	{ "reset_on_camera", _reset_on_camera },
	{ "reset_camera_params", _reset_camera_params },
	{ "processing_video", _processing_video },
	{ "processing_image", _processing_image },
	{ "processing_master", _processing_master },
	{ "TopLeft", _TopLeft },
	{ "TopRight", _TopRight },
	{ "BottomLeft", _BottomLeft },
	{ "BottomRight", _BottomRight },
	{ "ZeroLight", _ZeroLight },
	{ "flashPixel", _flashPixel },
	{ "flashTrkPart", _flashTrkPart },
	{ "flashTrkCA", _flashTrkCA },
	{ "flashCABG", _flashCABG },
	{ "flashCAPart", _flashCAPart },
	{ "flashMaster", _flashMaster },
	{ "NextRecordReplayPath", _NextRecordReplayPath },
};
// if (strcmp(address_string, ScenarioVarStrings[indVar]

// callBack variable conversions
bool double_to_bool(double param) {
	return (param != 0);
}
bool double_to_path(double param) {
	return (param > 0);
}
int double_to_sign(double param) {
	return (param > 0 ? 1 : (param < 0 ? - 1 : 0));
}


#if defined(CAAUDIO) || defined(RIVETS)
void pg_CAseed_location_to_coordinates(pg_CAseed_locations location, int coordinates[2]) {
	switch(location) {
	case 	_pg_CAseed_loc_center: {
		coordinates[0] = workingWindow_width / 2;
		coordinates[1] = window_height / 2;
		break;
	}
	case 	_pg_CAseed_loc_N: {
		coordinates[0] = workingWindow_width / 2;
		coordinates[1] = 0;
		break;
	}
	case 	_pg_CAseed_loc_E: {
		coordinates[0] = workingWindow_width;
		coordinates[1] = window_height / 2;
		break;
	}
	case 	_pg_CAseed_loc_S: {
		coordinates[0] = workingWindow_width / 2;
		coordinates[1] = window_height;
		break;
	}
	case 	_pg_CAseed_loc_W: {
		coordinates[0] = 0;
		coordinates[1] = window_height / 2;
		break;
	}
	case 	_pg_CAseed_loc_NW: {
		coordinates[0] = 0;
		coordinates[1] = 0;
		break;
	}
	case 	_pg_CAseed_loc_NE: {
		coordinates[0] = workingWindow_width;
		coordinates[1] = 0;
		break;
	}
	case 	_pg_CAseed_loc_SE: {
		coordinates[0] = workingWindow_width;
		coordinates[1] = window_height;
		break;
	}
	case 	_pg_CAseed_loc_SW: {
		coordinates[0] = 0;
		coordinates[1] = window_height;
		break;
	}
	}
}
#endif

///////////////////////////////////////////////////////////////////////////////////
// MANAGES EXCLUSIVE BUTTONS IN INTERFACE
template <typename T>
void ExclusiveButtonsAndLabelsOnOff(vector<string> ButtonPaths, vector<string> ButtonLabelPaths, vector<T> ButtonValues, bool withDefault, T value) {
	if(ButtonPaths.size() != ButtonValues.size() || ButtonLabelPaths.size() != ButtonValues.size()) {
		sprintf(ErrorStr, "Incorrect button values and sizes (%d/%d/%d) differ!", ButtonPaths.size(), ButtonLabelPaths.size(), ButtonValues.size()); ReportError(ErrorStr);  throw 768;
	}
	// all greyed except the active one
	for (int ind = 0; ind < int(ButtonPaths.size()); ind++) {
		if (fabs(value - ButtonValues[ind]) < 0.00001) {
			int selectedButtonIndex = ind;
			for (int indAux = 0; indAux < int(ButtonPaths.size()); indAux++) {
				if (indAux == selectedButtonIndex) {
					sprintf(AuxString, "%s/textColor FF8888FF", ButtonLabelPaths[indAux].c_str()); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
					sprintf(AuxString, "%s/color FF0000FF", ButtonPaths[indAux].c_str()); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "%s/textColor AAAAAAFF", ButtonLabelPaths[indAux].c_str()); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
					sprintf(AuxString, "%s/color 888888FF", ButtonPaths[indAux].c_str()); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
			return;
		}
	}
	// no active one and default allowed => all greyed
	if (withDefault) {
		for (int ind = 0; ind < int(ButtonPaths.size()); ind++) {
			sprintf(AuxString, "%s/textColor AAAAAAFF", ButtonLabelPaths[ind].c_str()); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "%s/color 888888FF", ButtonPaths[ind].c_str()); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
		}
	}
}


///////////////////////////////////////////////////////////////////////////////////
// ASSIGNS INITIAL VALUES TO ALL CONFIGURATION FILES
/*
void InitializeConfigurationVar(void) {
	for (int indVar = 0; indVar < _MaxConfigurationVarIDs; indVar++) {
		if (ConfigurationVarTypes[indVar] == _pg_float) {
			*((float *)ConfigurationVarPointers[indVar]) = InitialValuesConfigurationVar[indVar];
		}
		else if (ConfigurationVarTypes[indVar] == _pg_int) {
			*((int *)ConfigurationVarPointers[indVar]) = int(InitialValuesConfigurationVar[indVar]);
		}
		else if (ConfigurationVarTypes[indVar] == _pg_bool) {
			*((bool *)ConfigurationVarPointers[indVar]) = (InitialValuesConfigurationVar[indVar] != 0);
		}
		else if (ConfigurationVarTypes[indVar] == _pg_sign) {
			*((int *)ConfigurationVarPointers[indVar]) = (InitialValuesConfigurationVar[indVar] > 0 ? 1 : (InitialValuesConfigurationVar[indVar] < 0 ? -1 : 0));
		}
		else if (ConfigurationVarTypes[indVar] == _pg_path) {
			*((bool*)ConfigurationVarPointers[indVar]) = (InitialValuesConfigurationVar[indVar] > 0);
		}
		else {
			sprintf(ErrorStr, "Incorrect variable type (%d) for configuration variable #%d!", ConfigurationVarTypes[indVar], indVar); ReportError(ErrorStr);
		}
	}
}
*/

/////////////////////////////////////////////////////////////////////////
// INITIALIZES ALL SCENARIO VARIABLES AND ASSIGNS THEM THE VALUES OF THE INITIAL VALUES LINE
void pg_initializeScenearioVariables(void) {
	/////////////////////////////////////////////////////////////////////////
	// CONSTANT UNIFORM VARIABLES
	// only assigned at initialization, does not change during the set
	//glUseProgram(shader_programme[pg_current_configuration_rank][pg_shader_Camera]);
	//glUniform2f(uniform_Camera_vp_2fv_width_height[pg_current_configuration_rank],
	//	(GLfloat)workingWindow_width, (GLfloat)window_height);
#if defined(var_part_initialization) 
	if (ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank] && shader_programme[pg_current_configuration_rank][_pg_shader_ParticleAnimation]) {
		// only assigned at initialization, does not change during the set
		glUseProgram(shader_programme[pg_current_configuration_rank][_pg_shader_ParticleAnimation]);

		///////////////////////////////////////////////////////////////////
		// VERTEX SHADER VARIABLE
		glUniform2f(uniform_ParticleAnimation_vp_2fv_width_height[pg_current_configuration_rank],
			(GLfloat)workingWindow_width, (GLfloat)window_height);
	}
#endif

	// only assigned at initialization, does not change during the set
	if (shader_programme[pg_current_configuration_rank][_pg_shader_Update]) {
		glUseProgram(shader_programme[pg_current_configuration_rank][_pg_shader_Update]);

		///////////////////////////////////////////////////////////////////
		// VERTEX SHADER VARIABLE
		glUniform2f(uniform_Update_vp_2fv_width_height[pg_current_configuration_rank],
			(GLfloat)workingWindow_width, (GLfloat)window_height);
	}

	/////////////////////////////////////////////////////////////////////////
	// ADDITION OF SCENARIO-CONTROLLED UNIFORM VARIABLES TO THE HASH MAP
	for (int indVar = 0; indVar < _MaxInterpVarIDs; indVar++) {
		pg_OSC_addresses_hashMap[std::string(ScenarioVarStrings[indVar])] = indVar;
	}

	/////////////////////////////////////////////////////////////////////////
	// INItiAL VALUES OF SCENARIO-CONTROLLED UNIFORM VARIABLES
	for (int indP = 0; indP < ScenarioVarNb[pg_current_configuration_rank]; indP++) {
		int indVar = ConfigScenarioVarRank[indP][pg_current_configuration_rank];
		if (ScenarioVarConfigurations[indVar][pg_current_configuration_rank]) {
			if (ScenarioVarTypes[indVar] == _pg_float) {
				*((float*)ScenarioVarPointers[indVar]) = float(InitialValuesInterpVar[indVar][pg_current_configuration_rank].val_num);
			}
			else if (ScenarioVarTypes[indVar] == _pg_int) {
				*((int*)ScenarioVarPointers[indVar]) = int(InitialValuesInterpVar[indVar][pg_current_configuration_rank].val_num);
			}
			else if (ScenarioVarTypes[indVar] == _pg_bool) {
				*((bool*)ScenarioVarPointers[indVar]) = (InitialValuesInterpVar[indVar][pg_current_configuration_rank].val_num != 0);
			}
			else if (ScenarioVarTypes[indVar] == _pg_sign) {
				*((int*)ScenarioVarPointers[indVar]) = (InitialValuesInterpVar[indVar][pg_current_configuration_rank].val_num > 0 ? 1 : (InitialValuesInterpVar[indVar][pg_current_configuration_rank].val_num < 0 ? -1 : 0));
			}
			else if (ScenarioVarTypes[indVar] == _pg_path) {
				*((bool*)ScenarioVarPointers[indVar]) = (InitialValuesInterpVar[indVar][pg_current_configuration_rank].val_num > 0);
			}
			else if (ScenarioVarTypes[indVar] == _pg_string) {
				*((string*)ScenarioVarPointers[indVar]) = InitialValuesInterpVar[indVar][pg_current_configuration_rank].val_string;
			}
			else {
				sprintf(ErrorStr, "Incorrect variable type (%d) for scenario variable #%d!", ScenarioVarTypes[indVar], indVar); ReportError(ErrorStr);
			}
		}
	}

	// track replay 
	// source track recording
	// is recording source -> has to stop recording source 
#if defined(var_path_replay_trackNo_1)
	if (path_replay_trackNo_1 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[1] = path_replay_trackNo_1;
		}
		else {
			pg_path_replay_trackNo_onOff(1, path_replay_trackNo_1);
		}
	}
#endif
#if defined(var_path_replay_trackNo_2)
	if (path_replay_trackNo_2 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[2] = path_replay_trackNo_2;
		}
		else {
			pg_path_replay_trackNo_onOff(2, path_replay_trackNo_2);
		}
	}
#endif
#if defined(var_path_replay_trackNo_3)
	if (path_replay_trackNo_3 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[3] = path_replay_trackNo_3;
		}
		else {
			pg_path_replay_trackNo_onOff(3, path_replay_trackNo_3);
		}
	}
#endif
#if defined(var_path_replay_trackNo_4)
	if (path_replay_trackNo_4 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[4] = path_replay_trackNo_4;
		}
		else {
			pg_path_replay_trackNo_onOff(4, path_replay_trackNo_4);
		}
	}
#endif
#if defined(var_path_replay_trackNo_5)
	if (path_replay_trackNo_5 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[5] = path_replay_trackNo_5;
		}
		else {
			pg_path_replay_trackNo_onOff(5, path_replay_trackNo_5);
		}
	}
#endif
#if defined(var_path_replay_trackNo_6)
	if (path_replay_trackNo_6 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[6] = path_replay_trackNo_6;
		}
		else {
			pg_path_replay_trackNo_onOff(6, path_replay_trackNo_6);
		}
	}
#endif
#if defined(var_path_replay_trackNo_7)
	if (path_replay_trackNo_7 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[7] = path_replay_trackNo_7;
		}
		else {
			pg_path_replay_trackNo_onOff(7, path_replay_trackNo_7);
		}
	}
#endif
#if defined(var_path_replay_trackNo_8)
	if (path_replay_trackNo_8 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[8] = path_replay_trackNo_8;
		}
		else {
			pg_path_replay_trackNo_onOff(8, path_replay_trackNo_8);
		}
	}
#endif
#if defined(var_path_replay_trackNo_9)
	if (path_replay_trackNo_9 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[9] = path_replay_trackNo_9;
		}
		else {
			pg_path_replay_trackNo_onOff(9, path_replay_trackNo_9);
		}
	}
#endif
#if defined(var_path_replay_trackNo_10)
	if (path_replay_trackNo_10 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[10] = path_replay_trackNo_10;
		}
		else {
			pg_path_replay_trackNo_onOff(10, path_replay_trackNo_10);
		}
	}
#endif
#if defined(var_path_replay_trackNo_11)
	if (path_replay_trackNo_11 >= 0) {
		if (tracksSync) {
			synchr_start_path_replay_trackNo[11] = path_replay_trackNo_11;
		}
		else {
			pg_path_replay_trackNo_onOff(11, path_replay_trackNo_11);
		}
	}
#endif

	// track recording 
	// source track recording
	// is recording source -> has to stop recording source 
#if defined(var_path_record_1)
	if (!path_record_1) {
		pg_path_recording_stop(1);
	}
#endif
#if defined(var_path_record_2)
	if (!path_record_2) {
		pg_path_recording_stop(2);
	}
#endif
#if defined(var_path_record_3)
	if (!path_record_3) {
		pg_path_recording_stop(3);
	}
#endif
#if defined(var_path_record_4)
	if (!path_record_4) {
		pg_path_recording_stop(4);
	}
#endif
#if defined(var_path_record_5)
	if (!path_record_5) {
		pg_path_recording_stop(5);
	}
#endif
#if defined(var_path_record_6)
	if (!path_record_6) {
		pg_path_recording_stop(6);
	}
#endif
#if defined(var_path_record_7)
	if (!path_record_7) {
		pg_path_recording_stop(7);
	}
#endif
#if defined(var_path_record_8)
	if (!path_record_8) {
		pg_path_recording_stop(8);
	}
#endif
#if defined(var_path_record_9)
	if (!path_record_9) {
		pg_path_recording_stop(9);
	}
#endif
#if defined(var_path_record_10)
	if (!path_record_10) {
		pg_path_recording_stop(10);
	}
#endif
#if defined(var_path_record_11)
	if (!path_record_11) {
		pg_path_recording_stop(11);
	}
#endif
	for (int indPath = 1; indPath < PG_NB_PATHS; indPath++) {
		sprintf(AuxString, "/path_replay_trackNo_%d -1", indPath);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_%d 0", indPath);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
	}

	/////////////////////////////////////////////////////////////////////////
	// SOUND-CONTROLLED UNIFORM VARIABLES: dynamic values received from PD 
	// flashes
	for (int indtrack = 0; indtrack < PG_NB_TRACKS; indtrack++) {
		flashTrkCA_weights[indtrack] = 0;
		flashTrkPart_weights[indtrack] = 0;
		flashTrkBG_weights[indtrack] = 0;
		flashTrkCA_weights_duration[indtrack] = 0;
		flashTrkPart_weights_duration[indtrack] = 0;
		flashTrkBG_weights_duration[indtrack] = 0;
	}
	flashPixel = 0;
	flashCABG_weight = 0;
	flashCAPart_weight = 0;
	flashPartBG_weight = 0;
	flashPartCA_weight = 0;
	flashCABG_weight_duration = 0;
	flashCAPart_weight_duration = 0;
	flashPartBG_weight_duration = 0;
	flashPartCA_weight_duration = 0;

	// video flash
	is_flashCameraTrk = false;
	flashCameraTrk_weight = 0.0f;

	// master flash
	flashMaster = 0;

	// background subraction
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		reset_camera = true;
	}
#endif

#if defined(var_part_initialization)
	if (ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank]) {
		// particle initialization reset
		part_initialization = -1;
	}
#endif

	// clear
	isClearCA = 0;
	isClearLayer = 0;
	isClearAllLayers = 0;
	isClearEcho = 0;

	// DELAYED CAMERA WEIGHT
	delayedCameraWeight = 0;

#ifdef PG_WITH_BLUR
	// blur
	is_blur_1 = false;
	is_blur_2 = false;
	nb_blur_frames_1 = 0;
	nb_blur_frames_2 = 0;
#endif

#if defined(CAAUDIO) || defined(RIVETS)
	// CA seed
	pg_CAseed_trigger = false;
	pg_CAseed_type = _pg_CAseed_dot_center;
	// INTERFACE VARIABLE INITIALIZATION
	sprintf(AuxString, "/CAseed_dot_center %d", 1); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/CAseed_dot %d", 0); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/CAseed_h_line %d", 0); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/CAseed_v_line %d", 0); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/CAseed_cross %d", 0); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/CAseed_X %d", 0); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/CAseed_square %d", 0); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	pg_CAseed_location = _pg_CAseed_loc_center;
	sprintf(AuxString, "/CAseed_loc %d", pg_CAseed_location); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	pg_CAseed_coordinates[0] = workingWindow_width / 2;
	pg_CAseed_coordinates[1] = window_height / 2;
	pg_CAseed_size = 1;
	sprintf(AuxString, "/CAseed_size %d", pg_CAseed_size); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
#endif

	// copy to layer above (+1) or to layer below (-1)
	copyToNextTrack = 0;

	// pen music color
	pulsed_pen_color[0] = RGBpalette_r_ini;
	pulsed_pen_color[1] = RGBpalette_g_ini;
	pulsed_pen_color[2] = RGBpalette_b_ini;
	pulsed_pen_color[3] = RGBpalette_a_ini;

	// repop music color
	pulsed_repop_colorBG[0] = RGBpalette_r_ini;
	pulsed_repop_colorBG[1] = RGBpalette_g_ini;
	pulsed_repop_colorBG[2] = RGBpalette_b_ini;
	pulsed_repop_colorCA[0] = RGBpalette_r_ini;
	pulsed_repop_colorCA[1] = RGBpalette_g_ini;
	pulsed_repop_colorCA[2] = RGBpalette_b_ini;
	pulsed_repop_colorPart[0] = RGBpalette_r_ini;
	pulsed_repop_colorPart[1] = RGBpalette_g_ini;
	pulsed_repop_colorPart[2] = RGBpalette_b_ini;

	// pulse from sound 
	pulse_average = 0.0f;

	/////////////////////////////////////////////////////////////////////////
	// DRAWING-CONTROLLED UNIFORM VARIABLES: dynamic values received from drawing or track display 
	// pen position storage on the two quads 
	for (int indPath = 0; indPath < PG_NB_PATHS + 1; indPath++) {
		paths_x_next[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_y_next[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_x[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_y[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_x_prev[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_y_prev[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_x_prev_prev[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_y_prev_prev[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_x_memory[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_y_memory[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_x_prev_memory[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_y_prev_memory[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		isBegin[indPath] = false;
		isEnd[indPath] = false;
#ifdef PG_BEZIER_PATHS
		paths_xL[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_yL[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_xR[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_yR[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		tang_x[indPath] = 0;
		tang_y[indPath] = 0;
		tang_x_prev[indPath] = 0;
		tang_y_prev[indPath] = 0;
#endif

		// pen color
		paths_Color_r[indPath] = 0.0F;
		paths_Color_g[indPath] = 0.0F;
		paths_Color_b[indPath] = 0.0F;
		paths_Color_a[indPath] = 1.0F;
		// pen brush & size
		paths_BrushID[indPath] = 0;
		paths_RadiusX[indPath] = 0.0F;
		paths_RadiusY[indPath] = 0.0F;
	}

	// particule color
	repop_ColorBG_r = 0.f;
	repop_ColorBG_g = 0.f;
	repop_ColorBG_b = 0.f;
	repop_ColorCA_r = 0.f;
	repop_ColorCA_g = 0.f;
	repop_ColorCA_b = 0.f;
	repop_ColorPart_r = 0.f;
	repop_ColorPart_g = 0.f;
	repop_ColorPart_b = 0.f;

	// hoover cursor
	CurrentCursorHooverPos_x = 0;
	CurrentCursorHooverPos_y = 0;
	// stylus type
	CurrentCursorStylusvsRubber = pg_Stylus;

	/////////////////////////////////////////////////////////////////////////
	// TIME CONTROLLED VARIABLES (NOT FORWARDED TO SHADERS)
	// scenario management
	pg_CurrentSceneIndex = -1;
	pg_CurrentScene = NULL;
	// frame number initialization
	pg_FrameNo = first_frame_number - 1;
	// intial real time
	InitialRealTime = RealTime() + initial_time;
	// initial scenario time: well before current time to be over
	InitialScenarioTime = InitialRealTime - 1000000.f;
	AbsoluteInitialScenarioTime = InitialRealTime - 1000000.f;
	// TIME CONTROLLED UNIFORM VARIABLES
	// message transparency & echo
	messageTransparency = 0.0;

	// pg_send_message_udp((char *)"s", (char *)"/message init_completed", (char *)"udp_TouchOSC_send");
	// INTERFACE VARIABLE INITIALIZATION

	// soundtrack on
	soundTrack_on = true;
#ifdef PG_WITH_PUREDATA
	sprintf(AuxString, "/soundtrack_onOff %d", soundTrack_on);
	pg_send_message_udp((char*)"i", AuxString, (char*)"udp_PD_send");
	printf("Init script: soundtrack: %s\n", AuxString);
#endif
	sprintf(AuxString, "/soundtrack_onOff %d", !soundTrack_on);
	pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/soundtrack_volume %d", int(soundTrack_on));
	pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");

#if defined(PIERRES)
	updateXYKeystonePad();
#endif

#if !defined(LIGHT)
	// rubber vs pen interface initialization
	if (CurrentCursorStylusvsRubber == pg_Stylus) {
		sprintf(AuxString, "/StylusvsRubber %d", pg_Stylus); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	}
	else {
		sprintf(AuxString, "/StylusvsRubber %d", pg_Rubber); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	}
#endif

	// color interface initialization
#if (defined(var_pen_hue) && defined(var_pen_sat) && defined(var_pen_value)) || (defined(var_repop_huePart) && defined(var_repop_satPart) && defined(var_repop_valuePart))
	float control_color[3];
#endif
#if defined(var_pen_hue) && defined(var_pen_sat) && defined(var_pen_value)
	if (ScenarioVarConfigurations[_pen_hue][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_pen_sat][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_pen_value][pg_current_configuration_rank]) {
		HSVtoRGB(pen_hue, pen_sat, pen_value, &control_color[0], &control_color[1], &control_color[2]);
		sprintf(AuxString, "/pen_color/color %02x%02x%02xFF", int(control_color[0] * 255), int(control_color[1] * 255), int(control_color[2] * 255)); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
		//printf("color msg HSV %.2f %.2f %.2f  %s\n", pen_hue, pen_sat, pen_value, AuxString);
}
#endif

#if defined(var_repop_huePart) && defined(var_repop_satPart) && defined(var_repop_valuePart)
	if (ScenarioVarConfigurations[_repop_huePart][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_repop_satPart][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_repop_valuePart][pg_current_configuration_rank]) {
	HSVtoRGB(repop_huePart, repop_satPart, repop_valuePart, &control_color[0], &control_color[1], &control_color[2]);
	sprintf(AuxString, "/part_color/color %02x%02x%02xFF", int(control_color[0] * 255), int(control_color[1] * 255), int(control_color[2] * 255)); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
#endif
	// drawing type initialization
	ExclusiveButtonsAndLabelsOnOff(DessinButtonsPaths, DessinButtonLabelsPaths, DessinButtonValues, true, trkDecay_1);

#if defined(var_photo_diaporama)
	if (ScenarioVarConfigurations[_photo_diaporama][pg_current_configuration_rank]) {
		// photo diaporama initialization
		ExclusiveButtonsAndLabelsOnOff(FondButtonsPaths, FondButtonLabelsPaths, FondButtonValues, true, photo_diaporama);
	}
#endif

	// drawing type initialization
	ExclusiveButtonsAndLabelsOnOff(StylusvsRubberButtonsPaths, StylusvsRubberButtonLabelsPaths, StylusvsRubberButtonValues, false, CurrentCursorStylusvsRubber);
}

/////////////////////////////////////////////////////////////////////////
// INITIALIZES ALL SCENARIO VARIABLES CALLBACKS
void pg_initializationCallBacks(void) {
	for (int indVar = 0; indVar < _MaxInterpVarIDs; indVar++) {
		if (ScenarioVarCallbacks[indVar] != NULL) {
			(*ScenarioVarCallbacks[indVar])(_PG_SCENARIO, InitialValuesInterpVar[indVar][pg_current_configuration_rank]);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////
// GUI DISPLAY & LOG FILE LOGGING
/////////////////////////////////////////////////////////////
void pg_displaySceneVariables(void) {
	if (resend_all_variables) {
#if !defined(LIGHT)
		if (pg_CurrentScene && pg_CurrentSceneIndex >= 0 && pg_CurrentSceneIndex < pg_NbScenes[pg_current_configuration_rank]) {
			sprintf(AuxString, "/setupNo %d", pg_CurrentSceneIndex); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/setup %s", pg_CurrentScene->scene_IDs.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/setup_1 %s", pg_CurrentScene->scene_Msg1.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/setup_2 %s", pg_CurrentScene->scene_Msg2.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			if (pg_CurrentSceneIndex < pg_NbScenes[pg_current_configuration_rank] - 1) {
				sprintf(AuxString, "/setup_next next:_%s", pg_Scenario[pg_current_configuration_rank][pg_CurrentSceneIndex + 1].scene_IDs.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			}
			else {
				sprintf(AuxString, "/setup_next next:_%s", (char*)"END"); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			}
		}
		else if (pg_CurrentScene == NULL) {
			sprintf(AuxString, "/setupNo -1"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/setup initial_setup"); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/setup_1 ***"); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/setup_2 ***"); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			if (pg_NbScenes[pg_current_configuration_rank] > 0) {
				sprintf(AuxString, "/setup_next next:_%s", pg_Scenario[pg_current_configuration_rank][0].scene_IDs.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			}
		}
		else if (pg_CurrentScene == &pg_InterpolationScene) {
			sprintf(AuxString, "/setupNo -1"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/setup interpolation scene"); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/setup_1 next_scene_%s", pg_Scenario[pg_current_configuration_rank][pg_SceneIndexAfterInterpolation].scene_IDs.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/setup_2 previous_scene_%s", pg_Scenario[pg_current_configuration_rank][pg_SceneIndexBeforeInterpolation].scene_IDs.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		}
		sprintf(AuxString, "/pen_colorPreset %d", current_pen_colorPreset); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
		InterfaceInitializations();
#endif
#ifdef PG_WITH_PUREDATA
		// resends the sound variables to PD (as in the callback)
		sprintf(AuxString, "/sound_env_min %.2f", float(*((float*)ScenarioVarPointers[_sound_env_min])));
		pg_send_message_udp((char*)"f", AuxString, (char*)"udp_PD_send");
		sprintf(AuxString, "/sound_env_max %.2f", float(*((float*)ScenarioVarPointers[_sound_env_max])));
		pg_send_message_udp((char*)"f", AuxString, (char*)"udp_PD_send");
#endif

#if defined(var_partColor_mode) || defined(var_partStroke_mode) || defined(var_partExit_mode) 
		if (ScenarioVarConfigurations[_partColor_mode][pg_current_configuration_rank]
			|| ScenarioVarConfigurations[_partStroke_mode][pg_current_configuration_rank]
			|| ScenarioVarConfigurations[_partExit_mode][pg_current_configuration_rank]) {
			for (int ind = 0; ind < 3; ind++) {
				if (ind == *((int*)ScenarioVarPointers[_partColor_mode])) {
					sprintf(AuxString, "/partColor_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partColor_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				if (ind == *((int*)ScenarioVarPointers[_partStroke_mode])) {
					sprintf(AuxString, "/partStroke_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partStroke_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				if (ind == *((int*)ScenarioVarPointers[_partExit_mode])) {
					sprintf(AuxString, "/partExit_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partExit_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
#endif

#if defined(var_clipCaptFreq)
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			// clip intialization for First Clip
			sprintf(AuxString, "/clip_autoplay_left %d", int(pg_clip_status[_clipLeft].get_clip_autoplay(0)));
			pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/clip_play_left %d", int(pg_clip_status[_clipLeft].get_clip_play(0)));
			pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/clip_autoplay_right %d", int(pg_clip_status[_clipLeft].get_clip_autoplay(0)));
			pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/clip_play_right %d", int(pg_clip_status[_clipLeft].get_clip_play(0)));
			pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");

#if PG_NB_PARALLEL_CLIPS >= 2
			// clip intialization for Second Clip
			sprintf(AuxString, "/clip2_autoplay_left %d", int(pg_clip_status[_clipLeft].get_clip_autoplay(1)));
			pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/clip2_play_left %d", int(pg_clip_status[_clipLeft].get_clip_play(1)));
			pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/clip2_autoplay_right %d", int(pg_clip_status[_clipLeft].get_clip_autoplay(1)));
			pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/clip2_play_right %d", int(pg_clip_status[_clipLeft].get_clip_play(1)));
			pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
#endif
		}
#endif
#if defined(var_path_replay_trackNo_1) && defined(var_path_record_1)
		sprintf(AuxString, "/path_replay_trackNo_1 %d", path_replay_trackNo_1);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_1 %d", path_record_1);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_path_replay_trackNo_2) && defined(var_path_record_2)
		sprintf(AuxString, "/path_replay_trackNo_2 %d", path_replay_trackNo_2);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_2 %d", path_record_2);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_path_replay_trackNo_3) && defined(var_path_record_3)
		sprintf(AuxString, "/path_replay_trackNo_3 %d", path_replay_trackNo_3);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_3 %d", path_record_3);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_path_replay_trackNo_4) && defined(var_path_record_4)
		sprintf(AuxString, "/path_replay_trackNo_4 %d", path_replay_trackNo_4);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_4 %d", path_record_4);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_path_replay_trackNo_5) && defined(var_path_record_5)
		sprintf(AuxString, "/path_replay_trackNo_5 %d", path_replay_trackNo_5);
		pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_5 %d", path_record_5);
		pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_path_replay_trackNo_6) && defined(var_path_record_6)
		sprintf(AuxString, "/path_replay_trackNo_6 %d", path_replay_trackNo_6);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_6 %d", path_record_6);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_path_replay_trackNo_7) && defined(var_path_record_7)
		sprintf(AuxString, "/path_replay_trackNo_7 %d", path_replay_trackNo_7);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_7 %d", path_record_7);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_path_replay_trackNo_8) && defined(var_path_record_8)
		sprintf(AuxString, "/path_replay_trackNo_8 %d", path_replay_trackNo_8);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_8 %d", path_record_8);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_path_replay_trackNo_9) && defined(var_path_record_9)
		sprintf(AuxString, "/path_replay_trackNo_9 %d", path_replay_trackNo_9);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_9 %d", path_record_9);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_path_replay_trackNo_10) && defined(var_path_record_10)
		sprintf(AuxString, "/path_replay_trackNo_10 %d", path_replay_trackNo_10);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_10 %d", path_record_10);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_path_replay_trackNo_11) && defined(var_path_record_11)
		sprintf(AuxString, "/path_replay_trackNo_11 %d", path_replay_trackNo_11);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/path_record_11 %d", path_record_11);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
	}
#if defined(LIGHT)
	if (resend_all_light_variables) {
		pg_lightGUI_initialization();
		resend_all_light_variables = false;
	}
#endif

	/////////////////////////////////////////////////////////////////////////
	// TIME CONTROLLED VARIABLES (NOT FORWARDED TO SHADERS)
	// time display
	// time exceeded in scene
#if !defined(LIGHT)
	sprintf(AuxString, "/volumeDisplay %.2f", pulse_average);
	pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");

	if (remainingTimeInScene >= 0) {
		sprintf(AuxString, "/time %d:%d", (int)remainingTimeInScene / 60, (int)remainingTimeInScene % 60); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		if (remainingTimeInScene < 20) {
			sprintf(AuxString, "/time_color_red 1"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/time_color_orange 0"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/time_color_green 0"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		}
		else if (remainingTimeInScene < 20) {
			sprintf(AuxString, "/time_color_red 0"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/time_color_orange 1"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/time_color_green 0"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		}
		else {
			sprintf(AuxString, "/time_color_red 0"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/time_color_orange 0"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
			sprintf(AuxString, "/time_color_green 1"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		}
	}
	// time exceeded in scene
	else {
		int remTime = (int)remainingTimeInScene;
		if (remTime > -60) {
			sprintf(AuxString, "/time %d:%d", remTime / 60, remTime % 60); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		}
		else {
			sprintf(AuxString, "/time %d:%d", remTime / 60, -(remTime % 60)); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		}
		sprintf(AuxString, "/time_color 3"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
	}
#endif

	/////////////////////////////////////////////////////////////////////////
	// SCENARIO-CONTROLLED VARIABLES
	//int rank = max(pg_FrameNo, 1) % 10;
	//for (int indVar = rank * 45; indVar < min((rank + 1) * 45, int(_MaxInterpVarIDs)); indVar++) {
	for (int indP = 0; indP < ScenarioVarNb[pg_current_configuration_rank]; indP++) {
		int indVar = ConfigScenarioVarRank[indP][pg_current_configuration_rank];
		if (ScenarioVarConfigurations[indVar][pg_current_configuration_rank]) {
			// the variable has a registered GUI ID in the scenario
			// and its values has changed since it was sent to the GUI last time
			if (*(ScenarioVarMessages[indVar])) {
				if (ScenarioVarTypes[indVar] == _pg_float) {
					float new_value = float(*((float*)ScenarioVarPointers[indVar]));
					switch (ScenarioVarPulse[indVar]) {
					case _pg_pulsed_absolute:
						new_value *= (1.f + pulse_average * float(*((float*)ScenarioVarPointers[indVar + 1])));
						break;
					case _pg_pulsed_uniform:
						new_value += pulse_average * float(*((float*)ScenarioVarPointers[indVar + 1]));
						break;
					case _pg_pulsed_differential:
						new_value *= (pulse_average - pulse_average_prec) * float(*((float*)ScenarioVarPointers[indVar + 1]));
						break;
					}
					if (LastGUIShippedValuesInterpVar[indVar][pg_current_configuration_rank] != new_value || resend_all_variables) {
						sprintf(AuxString, "/%s %.4f", ScenarioVarMessages[indVar], new_value); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						LastGUIShippedValuesInterpVar[indVar][pg_current_configuration_rank] = new_value;
						//if (indVar == _track_y_transl_1) {
						//	printf("REPOST: track_y_transl_1 %s %.1f\n", ScenarioVarMessages[indVar], new_value);
						//}
					}
				}
				else if (ScenarioVarTypes[indVar] == _pg_int) {
					float new_value = float(*((int*)ScenarioVarPointers[indVar]));
					switch (ScenarioVarPulse[indVar]) {
					case _pg_pulsed_absolute:
						new_value *= (1.f + pulse_average * float(*((float*)ScenarioVarPointers[indVar + 1])));
						break;
					case _pg_pulsed_uniform:
						new_value += pulse_average * float(*((float*)ScenarioVarPointers[indVar + 1]));
						break;
					case _pg_pulsed_differential:
						new_value *= (pulse_average - pulse_average_prec) * float(*((float*)ScenarioVarPointers[indVar + 1]));
						break;
					}
					if (LastGUIShippedValuesInterpVar[indVar][pg_current_configuration_rank] != float(int(new_value)) || resend_all_variables) {
						sprintf(AuxString, "/%s %d", ScenarioVarMessages[indVar], int(new_value)); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						// memorizes the shipped value in order to resend it only when changed
						LastGUIShippedValuesInterpVar[indVar][pg_current_configuration_rank] = float(int(new_value));
					}
				}
				else if (ScenarioVarTypes[indVar] == _pg_bool
					&& (LastGUIShippedValuesInterpVar[indVar][pg_current_configuration_rank] != float(*((bool*)ScenarioVarPointers[indVar])) || resend_all_variables)) {
					sprintf(AuxString, "/%s %d", ScenarioVarMessages[indVar], (int)(*((bool*)ScenarioVarPointers[indVar]))); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
					LastGUIShippedValuesInterpVar[indVar][pg_current_configuration_rank] = float(*((bool*)ScenarioVarPointers[indVar]));
				}
				else if (ScenarioVarTypes[indVar] == _pg_sign
					&& (LastGUIShippedValuesInterpVar[indVar][pg_current_configuration_rank] != float(*((int*)ScenarioVarPointers[indVar])) || resend_all_variables)) {
					sprintf(AuxString, "/%s %d", ScenarioVarMessages[indVar], *((int*)ScenarioVarPointers[indVar])); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
					LastGUIShippedValuesInterpVar[indVar][pg_current_configuration_rank] = float(*((int*)ScenarioVarPointers[indVar]));
				}
				else if (ScenarioVarTypes[indVar] == _pg_path
					&& (LastGUIShippedValuesInterpVar[indVar][pg_current_configuration_rank] != float(*((bool*)ScenarioVarPointers[indVar])) || resend_all_variables)) {
					sprintf(AuxString, "/%s %d", ScenarioVarMessages[indVar], (int)(*((bool*)ScenarioVarPointers[indVar]))); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
					LastGUIShippedValuesInterpVar[indVar][pg_current_configuration_rank] = float(*((bool*)ScenarioVarPointers[indVar]));
				}
			}
		}
	}

	resend_all_variables = false;

}

void pg_send_message_udp(char *pattern, char * message, char *targetHostid) {
	pg_IPClient* targetHost = NULL;
	for (int ind = 0; ind < nb_IP_Clients; ind++) {
		if (strcmp(targetHostid, IP_Clients[ind]->id.c_str()) == 0) {
			targetHost = IP_Clients[ind];
			// char msg[512];
			// sprintf(msg, "send_message_udp %s %s %d %d size (curr %d tot %d)\n", message, pattern, nb_IP_Clients, targetHost, targetHost->current_depth_output_stack, targetHost->max_depth_output_stack);
			targetHost->storeIP_output_message(message, pattern);
		}
	}
	if (!targetHost) {
		// printf( "UDP client unknown %s\n" , targetHostid );
		return;
	}
}

void pg_send_message_udp(char *pattern, char * message, pg_IPClient *targetHost) {
	if (targetHost) {
		// printf("send_message_udp %s %s %d %d\n", message, pattern, nb_IP_Clients, targetHost);
		targetHost->storeIP_output_message(message, pattern);
	}
}

pg_IPClient *pg_UDP_client(char *targetHostid) {
	for (int ind = 0; ind < nb_IP_Clients; ind++) {
		if (strcmp(targetHostid, IP_Clients[ind]->id.c_str()) == 0) {
			return IP_Clients[ind];
		}
	}
	return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////
// LOG FILE
// makes a line of a CSV file to be used as a starting point for a repetition of the
// setup

void pg_logCurrentLineSceneVariables(string fileName) {
	/////////////////////////////////////////////////////////////////////////
	// SCENARIO-CONTROLLED UNIFORM VARIABLES
	for (int indP = 0; indP < ScenarioVarNb[pg_current_configuration_rank]; indP++) {
		int indVar = ConfigScenarioVarRank[indP][pg_current_configuration_rank];
		if (ScenarioVarConfigurations[indVar][pg_current_configuration_rank]) {
			if (ScenarioVarTypes[indVar] == _pg_float) {
				fprintf(pg_csv_log_file, ",%.6f", *((float*)ScenarioVarPointers[indVar]));
			}
			else if (ScenarioVarTypes[indVar] == _pg_int) {
				fprintf(pg_csv_log_file, ",%d", *((int*)ScenarioVarPointers[indVar]));
			}
			else if (ScenarioVarTypes[indVar] == _pg_bool) {
				fprintf(pg_csv_log_file, ",%d", int(*((bool*)ScenarioVarPointers[indVar])));
			}
			else if (ScenarioVarTypes[indVar] == _pg_sign) {
				fprintf(pg_csv_log_file, ",%d", (*((int*)ScenarioVarPointers[indVar]) > 0 ? +1 : (*((int*)ScenarioVarPointers[indVar]) < 0) ? -1 : 0));
			}
			else if (ScenarioVarTypes[indVar] == _pg_path) {
				fprintf(pg_csv_log_file, ",%d", int(*((bool*)ScenarioVarPointers[indVar])));
			}
			else if (ScenarioVarTypes[indVar] == _pg_string) {
				fprintf(pg_csv_log_file, ",%s", (*((string*)ScenarioVarPointers[indVar])).c_str());
			}
		}
	}
	fprintf(pg_csv_log_file, ",%s\n" , fileName.c_str());
}

// makes the first line of a CSV log file
void pg_logFirstLineSceneVariables(void) {
	/////////////////////////////////////////////////////////////////////////
	// SCENARIO-CONTROLLED UNIFORM VARIABLES
	fprintf(pg_csv_log_file, "ID");
	for (int indP = 0; indP < ScenarioVarNb[pg_current_configuration_rank]; indP++) {
		int indVar = ConfigScenarioVarRank[indP][pg_current_configuration_rank];
		if (ScenarioVarConfigurations[indVar][pg_current_configuration_rank]) {
			fprintf(pg_csv_log_file, ",%s", ScenarioVarStrings[indVar]);
		}
	}
	fprintf(pg_csv_log_file, "\n");
}


///////////////////////////////////////////////////////////////////////////////////
// SCENARIO BASED COMMANDS
///////////////////////////////////////////////////////////////////////////////////
void auto_beat_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	lastBeatTime = pg_CurrentClockTime;
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#ifdef PG_WITH_PUREDATA
		// sends a message to PD to stop sending music beats
		sprintf(AuxString, "/auto_beat %d", (int)(*((bool *)ScenarioVarPointers[_auto_beat])));
		pg_send_message_udp((char *)"i", AuxString, (char *)"udp_PD_send");
		// printf("auto_beat [%s] %.2f %d\n", AuxString, scenario_or_gui_command_value, (int)(*((bool *)ScenarioVarPointers[_auto_beat])));
#endif
	}
}
#if defined(var_MIDIwithStroke)
void MIDIwithStroke_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#ifdef PG_WITH_PUREDATA
		// sends a message to PD to stop sending music beats
		sprintf(AuxString, "/MIDIwithStroke %d", (int)(*((bool*)ScenarioVarPointers[_MIDIwithStroke])));
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_PD_send");
		// printf("MIDIwithStroke[%s] %.2f %d\n", AuxString, scenario_or_gui_command_value, (int)(*((bool *)ScenarioVarPointers[_MIDIwithBeat])));
#endif
	}
}
#endif
#if defined(var_MIDIwithBeat)
void MIDIwithBeat_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#ifdef PG_WITH_PUREDATA
		// sends a message to PD to stop sending music beats
		sprintf(AuxString, "/MIDIwithBeat %d", (int)(*((bool*)ScenarioVarPointers[_MIDIwithBeat])));
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_PD_send");
		// printf("MIDIwithBeat [%s] %.2f %d\n", AuxString, scenario_or_gui_command_value, (int)(*((bool *)ScenarioVarPointers[_MIDIwithBeat])));
#endif
	}
}
#endif
#if defined(var_MIDIwithColor)
void MIDIwithColor_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#ifdef PG_WITH_PUREDATA
		// sends a message to PD to stop sending music Colors
		sprintf(AuxString, "/MIDIwithColor %d", (int)(*((bool *)ScenarioVarPointers[_MIDIwithColor])));
		pg_send_message_udp((char *)"i", AuxString, (char *)"udp_PD_send");
		// printf("MIDIwithColor [%s] %.2f %d\n", AuxString, scenario_or_gui_command_value, (int)(*((bool *)ScenarioVarPointers[_MIDIwithColor])));
#endif
	}
}
#endif
#if defined(var_MIDIwithBrush)
void MIDIwithBrush_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#ifdef PG_WITH_PUREDATA
		// sends a message to PD to stop sending music Brushs
		sprintf(AuxString, "/MIDIwithBrush %d", (int)(*((bool *)ScenarioVarPointers[_MIDIwithBrush])));
		pg_send_message_udp((char *)"i", AuxString, (char *)"udp_PD_send");
		// printf("MIDIwithBrush [%s] %.2f %d\n", AuxString, scenario_or_gui_command_value, (int)(*((bool *)ScenarioVarPointers[_MIDIwithBrush])));
#endif
	}
}
#endif
#if defined(var_MIDIwithCameraFlash)
void MIDIwithCameraFlash_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#ifdef PG_WITH_PUREDATA
			// sends a message to PD to stop sending music Flashs
			sprintf(AuxString, "/MIDIwithCameraFlash %d", (int)(*((bool*)ScenarioVarPointers[_MIDIwithCameraFlash])));
			pg_send_message_udp((char*)"i", AuxString, (char*)"udp_PD_send");
			// printf("MIDIwithFlash [%s] %.2f %d\n", AuxString, scenario_or_gui_command_value, (int)(*((bool *)ScenarioVarPointers[_MIDIwithFlash])));
#endif
		}
	}
#endif
}
#endif
#if defined(var_Contact_clip_in_range)
void Contact_clip_in_range_callBack(pg_Parameter_Input_Type param_input_type, string scenario_or_gui_command_value) {
#if defined(var_clipCaptFreq)
	if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			ContAct_clip_ranges_min.clear();
			ContAct_clip_ranges_max.clear();
			if (scenario_or_gui_command_value != "NULL") {
				std::vector<std::string> ContAct_clip_ranges;
				ContAct_clip_ranges = split_string(scenario_or_gui_command_value, '/');
				for (string range : ContAct_clip_ranges) {
					std::vector<std::string> clip_min_max;
					clip_min_max = split_string(range, '-');
					ContAct_clip_ranges_min.push_back(stoi(clip_min_max[0]));
					ContAct_clip_ranges_max.push_back(stoi(clip_min_max[1]));
				}
			}
		}
	}
#endif
}
#endif
#if defined(var_MIDIwithPhotoFlash)
void MIDIwithPhotoFlash_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#ifdef PG_WITH_PUREDATA
		// sends a message to PD to stop sending music Flashs
		sprintf(AuxString, "/MIDIwithPhotoFlash %d", (int)(*((bool *)ScenarioVarPointers[_MIDIwithPhotoFlash])));
		pg_send_message_udp((char *)"i", AuxString, (char *)"udp_PD_send");
		// printf("MIDIwithFlash [%s] %.2f %d\n", AuxString, scenario_or_gui_command_value, (int)(*((bool *)ScenarioVarPointers[_MIDIwithFlash])));
#endif
	}
}
#endif
#if defined(var_auto_pulse)
void auto_pulse_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#ifdef PG_WITH_PUREDATA
		// sends a message to PD to stop sending music pulse
		sprintf(AuxString, "/auto_pulse %d", (int)(*((bool *)ScenarioVarPointers[_auto_pulse])));
		pg_send_message_udp((char *)"i", AuxString, (char *)"udp_PD_send");
		// printf("auto_pulse [%s] %.2f %d\n", AuxString, scenario_or_gui_command_value, (int)(*((bool *)ScenarioVarPointers[_auto_pulse])));
#endif
		for (int ind = 0; ind < 3 * 2; ind++) {
			seed_pulsePerlinNoise[ind] = rand_0_1 * 255;
		}
	}
}
#endif
void beat_delay_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#ifdef PG_WITH_PUREDATA
		sprintf(AuxString, "/beat_delay %.5f", scenario_or_gui_command_value);
		pg_send_message_udp((char *)"f", AuxString, (char *)"udp_PD_send");
#endif
	}
}
void beat_threshold_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#ifdef PG_WITH_PUREDATA
		sprintf(AuxString, "/beat_threshold %.5f", scenario_or_gui_command_value);
		pg_send_message_udp((char *)"f", AuxString, (char *)"udp_PD_send");
#endif
	}
}
#if defined(var_pen_color)
void pen_color_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		sprintf(AuxString, "/pen_colorPreset -1.0");
		pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
	}
}
#endif
#if defined(PG_WITH_PUREDATA) || defined(PG_WITH_JUCE)
void audioInput_weight_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		audioInput_weight = scenario_or_gui_command_value;
#ifdef PG_WITH_PUREDATA
		sprintf(AuxString, "/audioInput_weight %.2f", audioInput_weight);
		pg_send_message_udp((char *)"f", AuxString, (char *)"udp_PD_send");
#endif
#ifdef PG_WITH_JUCE
		sprintf(AuxString, "/JUCE_audioInput_weight %.2f", audioInput_weight);
		pg_send_message_udp((char *)"f", AuxString, (char *)"udp_SoundJUCE_send");
#endif
	}
}
#endif
#if defined(PG_WITH_PUREDATA) || defined(PG_WITH_JUCE)
void soundtrack_PD_weight_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		soundtrack_PD_weight = scenario_or_gui_command_value;
#ifdef PG_WITH_PUREDATA
		sprintf(AuxString, "/soundtrack_weight %.2f", soundtrack_PD_weight);
		pg_send_message_udp((char*)"f", AuxString, (char*)"udp_PD_send");
#endif
#ifdef PG_WITH_JUCE
		sprintf(AuxString, "/JUCE_soundtrack_weight %.2f", soundtrack_PD_weight);
		pg_send_message_udp((char*)"f", AuxString, (char*)"udp_SoundJUCE_send");
#endif
	}
}
#endif
#if defined(PG_WITH_PORTAUDIO)
void soundtrack_PA_weight_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		soundtrack_PA_weight = scenario_or_gui_command_value;
	}
}
#endif


#if defined(var_pen_hue)
void pen_hue_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		float control_color[3];
		HSVtoRGB(pen_hue, pen_sat, pen_value, &control_color[0], &control_color[1], &control_color[2]);
		sprintf(AuxString, "/pen_color/color %02x%02x%02xFF", int(control_color[0] * 255), int(control_color[1] * 255), int(control_color[2] * 255)); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
		//printf("colorH msg HSV %.2f %.2f %.2f  %s\n", pen_hue, pen_sat, pen_value, AuxString);
	}
}
#endif
#if defined(var_pen_sat)
void pen_sat_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		float control_color[3];
		HSVtoRGB(pen_hue, pen_sat, pen_value, &control_color[0], &control_color[1], &control_color[2]);
		sprintf(AuxString, "/pen_color/color %02x%02x%02xFF", int(control_color[0] * 255), int(control_color[1] * 255), int(control_color[2] * 255)); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
		//printf("colorS msg HSV %.2f %.2f %.2f  %s\n", pen_hue, pen_sat, pen_value, AuxString);
	}
}
#endif
#if defined(var_pen_value)
void pen_value_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		float control_color[3];
		HSVtoRGB(pen_hue, pen_sat, pen_value, &control_color[0], &control_color[1], &control_color[2]);
		sprintf(AuxString, "/pen_color/color %02x%02x%02xFF", int(control_color[0] * 255), int(control_color[1] * 255), int(control_color[2] * 255)); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
		//printf("colorV msg HSV %.2f %.2f %.2f  %s\n", pen_hue, pen_sat, pen_value, AuxString);
	}
}
#endif
#if defined(var_repop_huePart)
void repop_huePart_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#if defined(var_repop_huePart)
		if (ScenarioVarConfigurations[_repop_huePart][pg_current_configuration_rank]) {
			&& defined(var_repop_satPart) && defined(var_repop_valuePart)
				float control_color[3];
			HSVtoRGB(repop_huePart, repop_satPart, repop_valuePart, &control_color[0], &control_color[1], &control_color[2]);
			sprintf(AuxString, "/part_color/color %02x%02x%02xFF", int(control_color[0] * 255), int(control_color[1] * 255), int(control_color[2] * 255)); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
		}
#endif
		//printf("colorH msg HSV %.2f %.2f %.2f  %s\n", repop_huePart, repop_satPart, repop_valuePart, AuxString);
	}
}
#endif
#if defined(var_repop_satPart)
void repop_satPart_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#if defined(var_repop_huePart)
		if (ScenarioVarConfigurations[_repop_huePart][pg_current_configuration_rank]) {
			&& defined(var_repop_satPart) && defined(var_repop_valuePart)
				float control_color[3];
			HSVtoRGB(repop_huePart, repop_satPart, repop_valuePart, &control_color[0], &control_color[1], &control_color[2]);
			sprintf(AuxString, "/part_color/color %02x%02x%02xFF", int(control_color[0] * 255), int(control_color[1] * 255), int(control_color[2] * 255)); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
		}
#endif
		//printf("colorS msg HSV %.2f %.2f %.2f  %s\n", repop_huePart, repop_satPart, repop_valuePart, AuxString);
	}
}
#endif
#if defined(var_repop_valuePart)
void repop_valuePart_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		float control_color[3];
#if defined(var_repop_huePart) && defined(var_repop_satPart) && defined(var_repop_valuePart)
	if (ScenarioVarConfigurations[_repop_huePart][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_repop_satPart][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_repop_valuePart][pg_current_configuration_rank]) {
		HSVtoRGB(repop_huePart, repop_satPart, repop_valuePart, &control_color[0], &control_color[1], &control_color[2]);
		sprintf(AuxString, "/part_color/color %02x%02x%02xFF", int(control_color[0] * 255), int(control_color[1] * 255), int(control_color[2] * 255)); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
#endif
		//printf("colorV msg HSV %.2f %.2f %.2f  %s\n", repop_huePart, repop_satPart, repop_valuePart, AuxString);
	}
}
#endif
void trkDecay_1_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		// drawing type initialization
		ExclusiveButtonsAndLabelsOnOff(DessinButtonsPaths, DessinButtonLabelsPaths, DessinButtonValues, true, trkDecay_1);
	}
}
#if defined(var_fingers)
void fingers_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		// drawing type initialization
		NumberOfInteractionFingers(scenario_or_gui_command_value);
	}
}
#endif

#if defined(var_Contact_anim_speed)
void Contact_anim_speed_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		for (int indMesh = 0; indMesh < pg_nb_Mesh_files; indMesh++) {
			mesh_startAnime[indMesh] = pg_CurrentClockTime;
		}
	}
}
#endif

#if defined(var_Contact_motion_speed)
void Contact_motion_speed_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		for (int indMesh = 0; indMesh < pg_nb_Mesh_files; indMesh++) {
			mesh_startAnime[indMesh] = pg_CurrentClockTime;
		}
	}
}
#endif

void cameraExposure_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			// sprintf(AuxString, "/message Exposure_%.1f", scenario_or_gui_command_value); pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");
			if (scenario_or_gui_command_value != CameraCurrent_exposure) {
				//printf("Cam exposure %.2f\n", scenario_or_gui_command_value);
				// cvSetCaptureProperty comment for see3cam
				//pg_webCam_capture.set(CAP_PROP_EXPOSURE, scenario_or_gui_command_value);
				CameraCurrent_exposure = scenario_or_gui_command_value;
				pg_LastCameraParameterChange_Frame = pg_FrameNo;
			}
		}
	}
#endif
}
#if defined(var_Caverne_Mesh_Profusion)
void Caverne_Mesh_Profusion_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		//printf("/Caverne_Mesh_Profusion %.1f\n", scenario_or_gui_command_value);
		if (scenario_or_gui_command_value == 1.) {
			for (int indMesh = 7; indMesh < pg_nb_Mesh_files; indMesh++) {
				Caverne_Mesh_Profusion_On(indMesh);
			}
		}
		else if (scenario_or_gui_command_value == 0.) {
			for (int indMesh = 7; indMesh < pg_nb_Mesh_files; indMesh++) {
				Caverne_Mesh_Profusion_Off(indMesh);
			}
		}
	}
}
#endif
void cameraGamma_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			// sprintf(AuxString, "/message Gamma%.1f", scenario_or_gui_command_value); pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");
			if (scenario_or_gui_command_value != CameraCurrent_gamma) {
				//printf("Cam gamma %.2f\n", scenario_or_gui_command_value);
				// cvSetCaptureProperty comment for see3cam
				pg_webCam_capture.set(CAP_PROP_GAMMA, scenario_or_gui_command_value);
				CameraCurrent_gamma = scenario_or_gui_command_value;
				pg_LastCameraParameterChange_Frame = pg_FrameNo;
			}
		}
	}
#endif
}
void cameraGain_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			if (scenario_or_gui_command_value != CameraCurrent_gain) {
				printf("Cam gain %.2f\n", scenario_or_gui_command_value);
				// cvSetCaptureProperty comment for see3cam 
				pg_webCam_capture.set(CAP_PROP_GAIN, scenario_or_gui_command_value);
				CameraCurrent_gain = scenario_or_gui_command_value;
				pg_LastCameraParameterChange_Frame = pg_FrameNo;
			}
		}
	}
#endif
}
void cameraBrightness_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			if (scenario_or_gui_command_value != CameraCurrent_brightness) {
				//printf("Cam brightness %.2f\n", scenario_or_gui_command_value);
				// cvSetCaptureProperty comment for see3cam
				pg_webCam_capture.set(CAP_PROP_BRIGHTNESS, scenario_or_gui_command_value);
				CameraCurrent_brightness = scenario_or_gui_command_value;
				pg_LastCameraParameterChange_Frame = pg_FrameNo;
			}
		}
	}
#endif
}
void cameraSaturation_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			if (scenario_or_gui_command_value != CameraCurrent_saturation) {
				//printf("Cam saturation %.2f\n", scenario_or_gui_command_value);
				// cvSetCaptureProperty comment for see3cam 
				pg_webCam_capture.set(CAP_PROP_SATURATION, scenario_or_gui_command_value);
				CameraCurrent_saturation = scenario_or_gui_command_value;
				pg_LastCameraParameterChange_Frame = pg_FrameNo;
			}
		}
	}
#endif
}
void cameraContrast_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			if (scenario_or_gui_command_value != CameraCurrent_contrast) {
				//printf("Cam contrast %.2f\n", scenario_or_gui_command_value);
				// cvSetCaptureProperty comment for see3cam
				pg_webCam_capture.set(CAP_PROP_CONTRAST, scenario_or_gui_command_value);
				CameraCurrent_contrast = scenario_or_gui_command_value;
				pg_LastCameraParameterChange_Frame = pg_FrameNo;
			}
		}
	}
#endif
}
void cameraWB_B_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			if (scenario_or_gui_command_value != CameraCurrent_WB_B) {
				//printf("Cam WB B %.2f\n", scenario_or_gui_command_value);
				// cvSetCaptureProperty comment for see3cam
				pg_webCam_capture.set(CAP_PROP_WHITE_BALANCE_BLUE_U, scenario_or_gui_command_value);
				CameraCurrent_WB_B = scenario_or_gui_command_value;
				pg_LastCameraParameterChange_Frame = pg_FrameNo;
			}
		}
	}
#endif
}
void cameraWB_R_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			if (scenario_or_gui_command_value != CameraCurrent_WB_R) {
				//printf("Cam WB R %.2f\n", scenario_or_gui_command_value);
				// cvSetCaptureProperty comment for see3cam
				if (scenario_or_gui_command_value >= 0) {
					pg_webCam_capture.set(CAP_PROP_WHITE_BALANCE_RED_V, scenario_or_gui_command_value);
					CameraCurrent_WB_R = scenario_or_gui_command_value;
					pg_LastCameraParameterChange_Frame = pg_FrameNo;
				}
			}
		}
	}
#endif
}
#if defined(PG_WITH_JUCE) || defined(PG_WITH_PUREDATA) || defined(PG_WITH_PORTAUDIO)
void playing_soundtrackNo_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		// play a new track
		if (int(scenario_or_gui_command_value) >= 0
			&& int(scenario_or_gui_command_value) < nb_soundtracks[pg_current_configuration_rank]
			&& currentlyPlaying_trackNo != int(scenario_or_gui_command_value)) {
			PlayTrack(int(scenario_or_gui_command_value), 0.);
		}
		// stop playing a track
		else if (int(scenario_or_gui_command_value) < 0) {
			//printf("playing_soundtrackNo_callBack: playing_soundtrackNo neg %d\n", int(scenario_or_gui_command_value));
			StopTrack();
		}
	}
}
#endif
#if defined(var_movieCaptFreq)
void playing_movieNo_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		// starts playing another video
		pg_play_movie_no();

		// if the video no is outside the range of available videos: stops the playing video
		if (playing_movieNo != currentlyPlaying_movieNo
			&& playing_movieNo < 0 || playing_movieNo >= nb_movies[pg_current_configuration_rank]) {
			// printf("VideoPb Video initialization inside callback (thread) \n");

			currentlyPlaying_movieNo = -1;
			pg_movie_frame.setTo(Scalar(0, 0, 0));
			sprintf(AuxString, "/movie_shortName %s", "---");
			pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		}
	}
}
#endif
void cameraNo_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
#if defined(var_cameraCaptFreq)
	if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			printf("camera current %d new %d param type %d\n", pg_current_active_cameraNo, cameraNo, param_input_type);
			if (cameraNo != pg_current_active_cameraNo) {
				pg_releaseCameraCapture();
				pg_openCameraCaptureAndLoadFrame();
			}
		}
	}
#endif
}

#if defined(var_clipCaptFreq)
void playing_clipNameLeft_callBack(pg_Parameter_Input_Type param_input_type, string scenario_or_gui_command_value) {
#if defined(var_clipCaptFreq)
	if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			if (scenario_or_gui_command_value != "NULL") {
				for (int ind_clip = 0; ind_clip < pg_nbClips; ind_clip++) {
					//printf("clip ID (%s)\n", pg_clip_tracks[ind_clip].get_name().c_str());
					if (pg_clip_tracks[ind_clip].get_name() == scenario_or_gui_command_value) {
						// starts playing another clip
						//printf("Start playing clip \n");
						playing_clipNoLeft = ind_clip;
						printf("playing left clip name %s\n", scenario_or_gui_command_value.c_str());
						pg_play_clip_no(0, _clipLeft, playing_clipNoLeft);
						return;
					}
				}
				printf("Left cLip not found [%s]\n", scenario_or_gui_command_value.c_str());
			}
			else {
				//printf("Stop playing left cLip [NULL]\n");
			}
			playing_clipNoLeft = -1;
			pg_clip_status[_clipLeft].setCurrentlyPlaying_clipNo(0, playing_clipNoLeft);
			sprintf(AuxString, "/clip_shortName_0 %s", "---");
			pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		}
	}
#endif
}
void playing_clipNameRight_callBack(pg_Parameter_Input_Type param_input_type, string scenario_or_gui_command_value) {
#if defined(var_clipCaptFreq)
	if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			if (scenario_or_gui_command_value != "NULL") {
				for (int ind_clip = 0; ind_clip < pg_nbClips; ind_clip++) {
					if (pg_clip_tracks[ind_clip].get_name() == scenario_or_gui_command_value) {
						// starts playing another clip
						//printf("Start playing clip \n");
						playing_clipNoRight = ind_clip;
						printf("playing right clip name %s\n", scenario_or_gui_command_value.c_str());
						pg_play_clip_no(0, _clipRight, playing_clipNoRight);
						return;
					}
				}
				printf("Right cLip not found [%s]\n", scenario_or_gui_command_value.c_str());
			}
			else {
				//printf("Stop playing right cLip [NULL]\n");
			}
			playing_clipNoRight = -1;
			pg_clip_status[_clipRight].setCurrentlyPlaying_clipNo(0, playing_clipNoRight);
			sprintf(AuxString, "/clip_shortName_1 %s", "---");
			pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		}
	}
#endif
}
#if PG_NB_PARALLEL_CLIPS >= 2
void playing_secondClipNameLeft_callBack(pg_Parameter_Input_Type param_input_type, string scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		if (scenario_or_gui_command_value != "NULL") {
			for (int ind_clip = 0; ind_clip < pg_nbClips; ind_clip++) {
				if (pg_clip_tracks[ind_clip].get_name() == scenario_or_gui_command_value) {
					// starts playing another clip
					//printf("Start playing clip \n");
					playing_secondClipNoLeft = ind_clip;
					printf("playing second left clip name %s\n", scenario_or_gui_command_value.c_str());
					pg_play_clip_no(1, _clipLeft, playing_secondClipNoLeft);
					return;
				}
			}
			printf("Scecond left cLip not found [%s]\n", scenario_or_gui_command_value.c_str());
		}
		else {
			//printf("Stop playing second left cLip [NULL]\n");
		}
		playing_secondClipNoLeft = -1;
		pg_clip_status[_clipLeft].setCurrentlyPlaying_clipNo(1, playing_secondClipNoLeft);
		sprintf(AuxString, "/clip2_shortName_0 %s", "---");
		pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
	}
}

void playing_secondClipNameRight_callBack(pg_Parameter_Input_Type param_input_type, string scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		if (scenario_or_gui_command_value != "NULL") {
			for (int ind_clip = 0; ind_clip < pg_nbClips; ind_clip++) {
				if (pg_clip_tracks[ind_clip].get_name() == scenario_or_gui_command_value) {
					// starts playing another clip
					//printf("Start playing clip \n");
					playing_secondClipNoRight = ind_clip;
					printf("playing second right clip name %s\n", scenario_or_gui_command_value.c_str());
					pg_play_clip_no(1, _clipRight, playing_secondClipNoRight);
					return;
				}
			}
			printf("Scecond left cLip not found [%s]\n", scenario_or_gui_command_value.c_str());
		}
		else {
			//printf("Stop playing second left cLip [NULL]\n");
		}
		playing_secondClipNoRight = -1;
		pg_clip_status[_clipRight].setCurrentlyPlaying_clipNo(1, playing_secondClipNoRight);
		sprintf(AuxString, "/clip2_shortName_1 %s", "---");
		pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
	}
}
#endif
#endif

#if defined(var_movieCaptFreq)
void pg_play_movie_no(void) {
	if (playing_movieNo >= 0 && playing_movieNo < nb_movies[pg_current_configuration_rank]
		&& playing_movieNo != currentlyPlaying_movieNo) {
		pg_movie_frame.setTo(Scalar(0, 0, 0));

		// printf("VideoPb Video initialization inside command movie+ (thread) \n");

		BrokenInterpolationVar[_playing_movieNo] = true;
		currentlyPlaying_movieNo = playing_movieNo;
		pg_movie_frame.setTo(Scalar(0, 0, 0));
		sprintf(AuxString, "/movie_shortName %s", movieShortName[pg_current_configuration_rank][playing_movieNo].c_str());
		pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");

		// texture ID initialization (should not be inside a thread)
		if (pg_movie_texture_texID == NULL_ID) {
			glGenTextures(1, &pg_movie_texture_texID);
		}

		is_movieLoading = true;
		printf("Loading %s\n", movieFileName[pg_current_configuration_rank][currentlyPlaying_movieNo].c_str());
		// sprintf(AuxString, "/message %s", movieFileName[currentlyPlaying_movieNo].c_str()); pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");
//#if (defined(RIVETS) || defined(CAAUDIO) || defined(CORE)) && !defined(SOUNDINITATIVE)
		pg_initVideoMoviePlayback_nonThreaded(&movieFileName[pg_current_configuration_rank][currentlyPlaying_movieNo]);
/*
#else
#ifdef WIN32
		DWORD rc;
		HANDLE  hThread = CreateThread(
			NULL,                   // default security attributes
			0,                      // use default stack size  
			pg_initVideoMoviePlayback,		    // thread function name
			(void*)(&movieFileName[currentlyPlaying_movieNo]),		    // argument to thread function 
			0,                      // use default creation flags 
			&rc);   // returns the thread identifier 
		if (hThread == NULL) {
			std::cout << "Error:unable to create thread pg_initVideoMoviePlayback" << std::endl;
			exit(-1);
		}
		CloseHandle(hThread);
#else
		pthread_t drawing_thread;
		int rc;
		rc = pthread_create(&drawing_thread, NULL,
			pg_initVideoMoviePlayback,
			(void*)(&movieFileName[currentlyPlaying_movieNo]));
		if (rc) {
			std::cout << "Error:unable to create thread pg_initVideoMoviePlayback" << rc << std::endl;
			exit(-1);
		}
		pthread_exit(NULL);
#endif
#endif
*/
	}
}
#endif

#if defined(var_clipCaptFreq)
void clip_new(int indClipRank, int clipSide, int nb_arguments, float *float_arguments) {
	if (clipSide < _clipLR && clipSide >= 0 && pg_nbClips > 0) {
		int i = 0;
		int clipNo = -1;
		if (nb_arguments == 1) {
			clipNo = int(floor(rand_0_1 * pg_nbClips)) % pg_nbClips;
			while (i++ < 10 && clipNo == pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank)) {
				clipNo = int(floor(rand_0_1 * pg_nbClips)) % pg_nbClips;
			}
		}
		else if (nb_arguments == 3 || nb_arguments == 2) {
			if ((nb_arguments == 3 && (float_arguments[1] > float_arguments[2])) || float_arguments[1] < 0) {
				if (nb_arguments == 2)
					sprintf(ErrorStr, "Incorrect new clip arguments (%.2f)!", float_arguments[1]); ReportError(ErrorStr);
				if (nb_arguments == 3)
					sprintf(ErrorStr, "Incorrect new clip arguments (%.2f, %.2f)!", float_arguments[1], float_arguments[2]); ReportError(ErrorStr);
			}
			int clipMin = int(float_arguments[1]);
			int clipMax = pg_nbClips;
			if (nb_arguments == 3) {
				clipMax = int(float_arguments[2]);
			}
			clipNo = int(floor(rand_0_1 * (clipMax - clipMin + 1))) % (clipMax - clipMin + 1) + clipMin;
			while (i++ < 10 && clipNo == pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank)) {
				clipNo = int(floor(rand_0_1 * (clipMax - clipMin + 1))) % (clipMax - clipMin + 1) + clipMin;
			}
		}
		if (clipNo >= 0 && clipNo < pg_nbClips) {
			pg_play_clip_no(indClipRank, clipSide, clipNo);
		}
	}
}

void pg_play_clip_no(int indClipRank, int clipSide, int clipNo) {
	//printf("play clip No %d side %d rank %d previous clip no %d\n", clipNo, clipSide, indClipRank, pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank));
	if ((clipSide == _clipLeft || clipSide == _clipRight)
		&& clipNo >= 0 && clipNo < pg_nbClips
		&& clipNo != pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank)) {

		pg_clip_status[clipSide].setCurrentlyPlaying_clipNo(indClipRank, clipNo);
		pg_clip_status[clipSide].clip_play[indClipRank] = pg_clip_status[clipSide].clip_autoplay;
		if (clipSide == _clipLeft) {
			if (indClipRank == 0) {
				playing_clipNoLeft = clipNo;
				sprintf(AuxString, "/clip_shortName_0 %s", pg_clip_tracks[playing_clipNoLeft].get_name().c_str());
				pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
				sprintf(AuxString, "/clip_play_0 %d", playing_clipNoLeft);
				pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
				(*((string*)ScenarioVarPointers[_playing_clipNameLeft])) = pg_clip_tracks[playing_clipNoLeft].get_name();
				playing_clipNameLeft = pg_clip_tracks[playing_clipNoLeft].get_name();
				//printf("Play left clip %d at %d fps, is playing %d nb frames %d\n", pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank), int(clipCaptFreq), int(pg_clip_status[clipSide].clip_play[indClipRank]), pg_clip_tracks[pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank)].get_initialNbFrames());
			}
#if PG_NB_PARALLEL_CLIPS >= 2
			else {
				playing_secondClipNoLeft = clipNo;
				sprintf(AuxString, "/clip2_shortName_0 %s", pg_clip_tracks[playing_secondClipNoLeft].get_name().c_str());
				pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
				sprintf(AuxString, "/clip2_play_0 %d", playing_secondClipNoLeft);
				pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
				//printf("Play second left clip %d at %d fps, is playing %d\n", pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank), int(clipCaptFreq), int(pg_clip_status[clipSide].clip_play[indClipRank]));
				(*((string*)ScenarioVarPointers[_playing_secondClipNameLeft])) = pg_clip_tracks[playing_secondClipNoLeft].get_name();
				playing_secondClipNameLeft = pg_clip_tracks[playing_secondClipNoLeft].get_name();
			}
#endif
		}
		else {
			if (indClipRank == 0) {
				playing_clipNoRight = pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank);
				sprintf(AuxString, "/clip_shortName_1 %s", pg_clip_tracks[playing_clipNoRight].get_name().c_str());
				pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
				sprintf(AuxString, "/clip_play_1 %d", playing_clipNoRight);
				pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
				//printf("Play right clip %d at %d fps, is playing %d\n", pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank), int(clipCaptFreq), int(pg_clip_status[clipSide].clip_play[indClipRank]));
				(*((string*)ScenarioVarPointers[_playing_clipNameRight])) = pg_clip_tracks[playing_clipNoRight].get_name();
				playing_clipNameRight = pg_clip_tracks[playing_clipNoRight].get_name();
			}
#if PG_NB_PARALLEL_CLIPS >= 2
			else {
				playing_secondClipNoRight = pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank);
				sprintf(AuxString, "/clip2_shortName_1 %s", pg_clip_tracks[playing_secondClipNoRight].get_name().c_str());
				pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
				sprintf(AuxString, "/clip2_play_1 %d", playing_secondClipNoRight);
				pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
				//printf("Play second right clip %d at %d fps, is playing %d\n", pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank), int(clipCaptFreq), int(pg_clip_status[clipSide].clip_play[indClipRank]));
				(*((string*)ScenarioVarPointers[_playing_secondClipNameRight])) = pg_clip_tracks[playing_secondClipNoRight].get_name();
				playing_secondClipNameRight = pg_clip_tracks[playing_secondClipNoRight].get_name();
			}
#endif
		}

		pg_clip_status[clipSide].reset_clip(indClipRank);
		pg_clip_status[clipSide].set_currentFPS(double(clipCaptFreq));
	}

}
#endif

#if defined(var_Caverne_Mesh_Profusion)
void extern_movieNo_callBack(pg_Parameter_Input_Type param_input_type, ScenarioValue scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		if (extern_movieNo != current_extern_movieNo) {
			current_extern_movieNo = extern_movieNo;
			sprintf(AuxString, "/video %.0f", extern_movieNo);
			pg_send_message_udp((char *)"f", AuxString, (char *)"udp_Processing_send");
		}
	}
}
#endif

#if defined(var_photo_diaporama)
void photo_diaporama_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE || param_input_type == _PG_SCENARIO) {
		//printf("photo_diaporama_callBack %d\n", scenario_or_gui_command_value);
		if (pg_nbCompressedImageDirs[pg_current_configuration_rank] > 0 && scenario_or_gui_command_value >= 0 && scenario_or_gui_command_value != pg_CurrentDiaporamaDir) {
			pg_CurrentDiaporamaDir = int(scenario_or_gui_command_value) % pg_nbCompressedImageDirs[pg_current_configuration_rank];
			//printf("pg_CurrentDiaporamaDir %d\n", pg_CurrentDiaporamaDir);
			sprintf(AuxString, "/diaporama_shortName %03d", pg_CurrentDiaporamaDir);
			pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
			pg_launch_diaporama();
		}
		else if (pg_nbCompressedImageDirs[pg_current_configuration_rank] > 0 && scenario_or_gui_command_value < 0) {
			pg_CurrentDiaporamaDir = -1;
			//printf("pg_CurrentDiaporamaDir %d\n", pg_CurrentDiaporamaDir);
			sprintf(AuxString, "/diaporama_shortName %03d", pg_CurrentDiaporamaDir);
			pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
			pg_launch_diaporama();
		}
		// do nothing / no images to display
		else {
		}
#ifdef ATELIERSENFANTS
		// photo diaporama initialization
		printf("current photo diaporama %d\n", scenario_or_gui_command_value);
		ExclusiveButtonsAndLabelsOnOff(FondButtonsPaths, FondButtonLabelsPaths, FondButtonValues, true, scenario_or_gui_command_value);
#endif
	}
}
#endif

void flashCameraTrkLength_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE || param_input_type == _PG_SCENARIO) {
		if (scenario_or_gui_command_value > 0.) {
			flashCameraTrk_decay = float(1. / scenario_or_gui_command_value);
		}
		else {
			flashCameraTrk_decay = 0.001f;
		}
	}
}
#if defined(var_flashPhotoTrkBeat) && defined(var_flashPhotoTrkBright) && defined(var_flashPhotoTrkLength) && defined(var_flashPhotoChangeBeat)
void flashPhotoTrkLength_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE || param_input_type == _PG_SCENARIO) {
		if (scenario_or_gui_command_value > 0.) {
			flashPhotoTrk_decay = 1.f / scenario_or_gui_command_value;
		}
		else {
			flashPhotoTrk_decay = 0.001f;
		}
	}
}
#endif
void pen_brush_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE || param_input_type == _PG_SCENARIO) {
		if (scenario_or_gui_command_value >= 1) { // large radius for the image brushes*
			pen_radiusMultiplier = 50.0f;
#if defined(FORET) || defined(CORE)
			pen_radiusMultiplier = 1.0f;
#endif
		}
		else {
			pen_radiusMultiplier = 1.0f;
		}
		// printf("pen_radiusMultiplier %.2f\n", pen_radiusMultiplier);
	}
}
void clearAllLayers_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
		// printf("delta %.3f\n", (float)(pg_CurrentClockTime - lastClearTime) );
		if (pg_CurrentClockTime - lastClearTime < 0.5f) {
			// pg_send_message_udp((char *)"s", (char *)"/message clear_all", (char *)"udp_TouchOSC_send");
			isClearAllLayers = 1;
			lastClearTime = 0.0f;
			//printf("****** _PG_GUI_COMMAND isClearAllLayers %d\n",isClearAllLayers);
		}
		else {
			lastClearTime = pg_CurrentClockTime;
		}
	}
	// clearing is only made once at the beginning of a scene
	else if (param_input_type == _PG_SCENARIO && scenario_or_gui_command_value && lastClearSceneIndex != pg_CurrentSceneIndex) {
		// pg_send_message_udp((char *)"s", (char *)"/message clear_all", (char *)"udp_TouchOSC_send");
		isClearAllLayers = 1;
		lastClearTime = pg_CurrentClockTime;
		lastClearSceneIndex = pg_CurrentSceneIndex;
		 //printf("****** _PG_SCENARIO isClearAllLayers %d %d %d\n", isClearAllLayers, pg_FirstFrameInScene, pg_CurrentSceneIndex);
	}
}
void clearLayer_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
		if (pg_CurrentClockTime - lastClearTime < 0.2f) {
			isClearLayer = 1;
			lastClearTime = 0.0f;
			// pg_send_message_udp((char *)"s", (char *)"/message clear_all_layers", (char *)"udp_TouchOSC_send");
		}
		else {
			isClearLayer = 1;
			lastClearTime = pg_CurrentClockTime;
			// pg_send_message_udp((char *)"s", (char *)"/message clear_layer", (char *)"udp_TouchOSC_send");
		}
	}
	else if (param_input_type == _PG_SCENARIO && scenario_or_gui_command_value && lastClearSceneIndex != pg_CurrentSceneIndex) {
		isClearLayer = 1;
		lastClearTime = pg_CurrentClockTime;
		lastClearSceneIndex = pg_CurrentSceneIndex;
	}
}
#if defined(var_currentLightScene)
void currentLightScene_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	if ((param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) && scenario_or_gui_command_value >= 0) {
		sprintf(AuxString, "/light_control/light_scene_start %d", int(currentLightScene) - 1);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_Python_send");
	}
}
#endif
#ifdef PG_WITH_PUREDATA
void sound_env_min_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		sprintf(AuxString, "/sound_env_min %.2f", scenario_or_gui_command_value);
		pg_send_message_udp((char *)"f", AuxString, (char *)"udp_PD_send");
	}
	// printf("reset sound\n");
}
void sound_env_max_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		sprintf(AuxString, "/sound_env_max %.2f", scenario_or_gui_command_value);
		pg_send_message_udp((char *)"f", AuxString, (char *)"udp_PD_send");
	}
	// printf("reset sound\n");
}
#endif
#if defined(var_activeMeshes)
void activeMeshes_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE || param_input_type == _PG_SCENARIO) {
		// MESH INTERFACE VARIABLE INITIALIZATION
		for (int indImage = 0; indImage < pg_nb_Mesh_files; indImage++) {
			sprintf(AuxString, "/Mesh_%d_onOff %d", indImage + 1, (activeMeshes & (1 << (indImage)))); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		}
	}
}
#endif
#if defined(var_mobileMeshes)
void mobileMeshes_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE || param_input_type == _PG_SCENARIO) {
		// MESH INTERFACE VARIABLE INITIALIZATION
		for (int indImage = 0; indImage < pg_nb_Mesh_files; indImage++) {
			sprintf(AuxString, "/Mesh_mobile_%d_onOff %d", indImage + 1, (mobileMeshes & (1 << (indImage)))); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		}
	}
}
#endif
#if defined(var_MmeShanghai_brokenGlass)
void MmeShanghai_brokenGlass_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE || param_input_type == _PG_SCENARIO) {
		// activation of a mesh subgroup for which the edges will be drawn
	}
}
#endif
void clearCA_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
		// pg_send_message_udp((char *)"s", (char *)"/message clear_CA", (char *)"udp_TouchOSC_send");
		isClearCA = 1;
	}
	else if (param_input_type == _PG_SCENARIO && scenario_or_gui_command_value && lastClearSceneIndex != pg_CurrentSceneIndex) {
		isClearCA = 1;
		lastClearSceneIndex = pg_CurrentSceneIndex;
	}
}
void clearEcho_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
		// pg_send_message_udp((char *)"s", (char *)"/message clear_CA", (char *)"udp_TouchOSC_send");
		isClearEcho = 1;
	}
	else if (param_input_type == _PG_SCENARIO && scenario_or_gui_command_value) {
		isClearEcho = 1;
	}
}
void clear_path_group(void) {
	for (int ind = 0; ind <= PG_NB_PATHS; ind++) {
		pg_Path_Status[ind].isFirstFrame = false;
		pg_Path_Status[ind].isActiveRecording = false;
		pg_Path_Status[ind].isNormalized = false;
		pg_Path_Status[ind].indReading = -1;
		pg_Path_Status[ind].initialTimeRecording = 0.0f;
		pg_Path_Status[ind].finalTimeRecording = 0.0f;
		pg_Path_Status[ind].initialTimeReading = 0.0f;
		pg_Path_Status[ind].lastPlayedFrameTime = 1.0F;
		pg_Path_Status[ind].readSpeedScale = 1.0F;
		pg_indPreviousFrameReading[ind] = 0;
	}
}
void path_group_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		if (int(scenario_or_gui_command_value) >= 0 && int(scenario_or_gui_command_value) - 1 != current_path_group) {
			//printf("old current path %d\n", current_path_group);
			bool was_path_replay[PG_NB_PATHS + 1];
			for (int indPrerecPath = 0; indPrerecPath < nb_paths[pg_current_configuration_rank]; indPrerecPath++) {
				//printf("path %d path group %d\n", current_path_group, paths[indPrerecPath].path_group);
				if (paths[pg_current_configuration_rank][indPrerecPath].indPath <= PG_NB_PATHS && paths[pg_current_configuration_rank][indPrerecPath].path_group == current_path_group) {
					was_path_replay[paths[pg_current_configuration_rank][indPrerecPath].indPath] = is_path_replay[paths[pg_current_configuration_rank][indPrerecPath].indPath];
#if defined(var_path_replay_trackNo_1)
					if (is_path_replay[paths[pg_current_configuration_rank][indPrerecPath].indPath]) {
						 //printf("Stops Replay indPath %d: %d\n", paths[indPrerecPath].indPath, is_path_replay[paths[indPrerecPath].indPath]);
						
						(paths[pg_current_configuration_rank][indPrerecPath].indPath);
					}
#endif
#if defined(var_path_record_1)
					// is recording source -> has to stop recording source 
					if (pg_Path_Status[paths[pg_current_configuration_rank][indPrerecPath].indPath].isActiveRecording) {
						//printf("Stops Recording indPath %d: %d\n", paths[indPrerecPath].indPath, pg_Path_Status[paths[indPrerecPath].indPath].isActiveRecording);
						pg_path_recording_stop(paths[pg_current_configuration_rank][indPrerecPath].indPath);
					}
#endif
				}
			}
			clear_path_group();
			current_path_group = int(scenario_or_gui_command_value) - 1;
			//printf("new current path %d\n", current_path_group);
			for (int indPrerecPath = 0; indPrerecPath < nb_paths[pg_current_configuration_rank]; indPrerecPath++) {
				//printf("path %d path group %d\n", current_path_group, paths[indPrerecPath].path_group);
				if (paths[pg_current_configuration_rank][indPrerecPath].indPath <= PG_NB_PATHS && paths[pg_current_configuration_rank][indPrerecPath].path_group == current_path_group) {
					//printf("load path for replay %s\n", paths[indPrerecPath].path_fileName.c_str());
#if defined(var_path_replay_trackNo_1) && defined(var_path_record_1)
					load_svg_path((char*)paths[pg_current_configuration_rank][indPrerecPath].path_fileName.c_str(),
						paths[pg_current_configuration_rank][indPrerecPath].indPath, paths[pg_current_configuration_rank][indPrerecPath].indTrack, paths[pg_current_configuration_rank][indPrerecPath].pathRadius,
						paths[pg_current_configuration_rank][indPrerecPath].path_r_color, paths[pg_current_configuration_rank][indPrerecPath].path_g_color, paths[pg_current_configuration_rank][indPrerecPath].path_b_color,
						paths[pg_current_configuration_rank][indPrerecPath].path_readSpeedScale, paths[pg_current_configuration_rank][indPrerecPath].path_ID, paths[pg_current_configuration_rank][indPrerecPath].with_color_radius_from_scenario,
						paths[pg_current_configuration_rank][indPrerecPath].secondsforwidth);
#endif
#if defined(var_path_replay_trackNo_1)
					// start reading if it was already reading
					if (was_path_replay[paths[pg_current_configuration_rank][indPrerecPath].indPath]) {
						//printf("Starts Replay indPath %d: %d\n", paths[indPrerecPath].indPath, was_path_replay[paths[indPrerecPath].indPath]);
						pg_path_replay_trackNo_start(paths[pg_current_configuration_rank][indPrerecPath].indPath, paths[pg_current_configuration_rank][indPrerecPath].indTrack);
					}
#endif
				}
			}
		}
	}
}

#if defined(var_path_replay_trackNo_1) || defined(var_path_record_1)
void path_replay_trackNo_callBack(int pathNo, pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	int playing_track = -1;
	// for a keystroke or a GUI, the command is the current track whatever its value
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
		playing_track = currentDrawingTrack;
	}
	// for a scenario >= 0 -> replay and -1 -> no replay
	else if (param_input_type == _PG_SCENARIO) {
		playing_track = scenario_or_gui_command_value;
	}
	// is not currently reading -> starts reading if it is a valid track number
	if (!is_path_replay[pathNo]) {
		// does not change anything if it is not a valid track
		if (playing_track < 0 || playing_track >= PG_NB_TRACKS) {
			sprintf(AuxString, "/path_replay_trackNo_%d -1", pathNo);
			//pg_send_message_udp((char *)"i", AuxString, (char *)"udp_TouchOSC_send");
			//printf("replay unchanged (stop) invalid track\n");
			return;
		}
		// stops recording if recording is on
		bool isTrackRecord = false;
		switch (pathNo) {
		case 1:
			isTrackRecord = path_record_1;
			break;
#if defined(var_path_record_2)
		case 2:
			isTrackRecord = path_record_2;
			break;
#endif
#if defined(var_path_record_3)
		case 3:
			isTrackRecord = path_record_3;
			break;
#endif
#if defined(var_path_record_4)
		case 4:
			isTrackRecord = path_record_4;
			break;
#endif
#if defined(var_path_record_5)
		case 5:
			isTrackRecord = path_record_5;
			break;
#endif
#if defined(var_path_record_6)
		case 6:
			isTrackRecord = path_record_6;
			break;
#endif
#if defined(var_path_record_7)
		case 7:
			isTrackRecord = path_record_7;
			break;
#endif
#if defined(var_path_record_8)
		case 8:
			isTrackRecord = path_record_8;
			break;
#endif
#if defined(var_path_record_9)
		case 9:
			isTrackRecord = path_record_9;
			break;
#endif
#if defined(var_path_record_10)
		case 10:
			isTrackRecord = path_record_10;
			break;
#endif
#if defined(var_path_record_11)
		case 11:
			isTrackRecord = path_record_11;
			break;
#endif
		}
		// is currently recording -> stops recording 
		if (isTrackRecord) {
			// stops recording 
			pg_path_recording_onOff(pathNo);
			//printf("replay stops recording\n");
		}

		// only reads a track that has been recorded
		// assumes that no svg track has been loaded for this track
		//printf("recorded path %d : %d\n", pathNo, recorded_path[pathNo]);
		if (recorded_path[pathNo] == true) {
			if (tracksSync) {
				synchr_start_path_replay_trackNo[pathNo] = playing_track;
			}
			else {
				//printf("start replay path %d\n", pathNo);
				pg_path_replay_trackNo_onOff(pathNo, playing_track);
			}
			//sprintf(AuxString, "/path_replay_trackNo_%d 1", pathNo);
			//pg_send_message_udp((char *)"i", AuxString, (char *)"udp_TouchOSC_send");
			//printf("replay on recorded track (%s)\n", AuxString);
		}
		else {
			//sprintf(AuxString, "/path_replay_trackNo_%d 0", pathNo);
			//pg_send_message_udp((char *)"i", AuxString, (char *)"udp_TouchOSC_send");
			//printf("replay off non recorded track\n");
		}
	}
	// is currently reading && playing_track < 0 (scenario) or on/off command -> stops reading 
	else {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
			playing_track = -1;
		}
		if (playing_track == -1) {
			pg_path_replay_trackNo_onOff(pathNo, playing_track);
			//sprintf(AuxString,  "/path_replay_trackNo_%d 0", pathNo);
			//pg_send_message_udp((char *)"i", AuxString, (char *)"udp_TouchOSC_send");
			//printf("replay off track was currently read (%s)\n", AuxString);
		}
	}
}
#endif

void reload_paths_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
		if (scenario_or_gui_command_value) {
			for (int indPrerecPath = 0; indPrerecPath < nb_paths[pg_current_configuration_rank]; indPrerecPath++) {
				if (paths[pg_current_configuration_rank][indPrerecPath].indPath <= PG_NB_PATHS) {
#if defined(var_path_replay_trackNo_1) && defined(var_path_record_1)
					load_svg_path((char*)paths[pg_current_configuration_rank][indPrerecPath].path_fileName.c_str(),
						paths[pg_current_configuration_rank][indPrerecPath].indPath, paths[pg_current_configuration_rank][indPrerecPath].indTrack, paths[pg_current_configuration_rank][indPrerecPath].pathRadius,
						paths[pg_current_configuration_rank][indPrerecPath].path_r_color, paths[pg_current_configuration_rank][indPrerecPath].path_g_color, paths[pg_current_configuration_rank][indPrerecPath].path_b_color,
						paths[pg_current_configuration_rank][indPrerecPath].path_readSpeedScale, paths[pg_current_configuration_rank][indPrerecPath].path_ID, paths[pg_current_configuration_rank][indPrerecPath].with_color_radius_from_scenario,
						paths[pg_current_configuration_rank][indPrerecPath].secondsforwidth);
#endif
				}
			}
		}
	}
}

#if defined(var_path_replay_trackNo_1) 
void path_replay_trackNo_1_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(1, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_replay_trackNo_2) 
void path_replay_trackNo_2_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(2, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_replay_trackNo_3) 
void path_replay_trackNo_3_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(3, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_replay_trackNo_4) 
void path_replay_trackNo_4_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(4, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_replay_trackNo_5) 
void path_replay_trackNo_5_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(5, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_replay_trackNo_6) 
void path_replay_trackNo_6_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(6, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_replay_trackNo_7) 
void path_replay_trackNo_7_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(7, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_replay_trackNo_8) 
void path_replay_trackNo_8_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(8, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_replay_trackNo_9) 
void path_replay_trackNo_9_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(9, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_replay_trackNo_10) 
void path_replay_trackNo_10_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(10, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_replay_trackNo_11) 
void path_replay_trackNo_11_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	path_replay_trackNo_callBack(11, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_1) 
void path_record_callBack(int pathNo, pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	//keystroke on/off command
	//printf("begin callback path %d is track record %d (recorded %d)\n", pathNo, int(pg_Path_Status[pathNo].isActiveRecording), int(recorded_path[pathNo]));
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
		// is not currently recording -> starts recording 
		if (!pg_Path_Status[pathNo].isActiveRecording) {
			recorded_path[pathNo] = true;
			if (tracksSync) {
				synchr_start_recording_path[pathNo] = true;
			}
			else {
				pg_path_recording_onOff(pathNo);
			}
		}
		// is currently recording -> stops recording 
		else {
			// stops recording 
			pg_path_recording_onOff(pathNo);
		}
	}
	// scenario absolute command
	if (param_input_type == _PG_SCENARIO) {
		// recording on 
		if (scenario_or_gui_command_value) {
			// starts recording 
			if (!pg_Path_Status[pathNo].isActiveRecording) {
				recorded_path[pathNo] = true;
				if (tracksSync) {
					synchr_start_recording_path[pathNo] = true;
				}
				else {
					pg_path_recording_onOff(pathNo);
				}
			}
		}
		// recording off 
		else {
			if (pg_Path_Status[pathNo].isActiveRecording) {
				// stops recording 
				pg_path_recording_onOff(pathNo);
			}
		}
	}

	//printf("end callback path record for path 1 recording %d active recording %d (recorded %d)\n", path_record_1, int(pg_Path_Status[1].isActiveRecording), recorded_path[1]);
	//printf("end callback path record for path 2 recording %d active recording %d (recorded %d)\n", path_record_2, int(pg_Path_Status[2].isActiveRecording), recorded_path[2]);
}
#endif
#if defined(var_path_record_1) 
void path_record_1_callBack( pg_Parameter_Input_Type param_input_type , bool scenario_or_gui_command_value ) {
	path_record_callBack(1 , param_input_type , scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_2) 
void path_record_2_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	path_record_callBack(2, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_3) 
void path_record_3_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	path_record_callBack(3, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_4) 
void path_record_4_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	path_record_callBack(4, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_5) 
void path_record_5_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	path_record_callBack(5, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_6) 
void path_record_6_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	path_record_callBack(6, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_7) 
void path_record_7_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	path_record_callBack(7, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_8) 
void path_record_8_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	path_record_callBack(8, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_9) 
void path_record_9_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	path_record_callBack(9, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_10) 
void path_record_10_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	path_record_callBack(10, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_path_record_11) 
void path_record_11_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	path_record_callBack(11, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_initialization) 
void part_move_init(void) {
	if (ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank]) {
#if defined(var_part_path_follow_0) && defined(var_part_path_repulse_0)
		* ((bool*)ScenarioVarPointers[_part_path_follow_0]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_0]) = false;
#endif
#if defined(var_part_path_follow_1) && defined(var_part_path_repulse_1)
		* ((bool*)ScenarioVarPointers[_part_path_follow_1]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_1]) = false;
#endif
#if defined(var_part_path_follow_2) && defined(var_part_path_repulse_2)
		* ((bool*)ScenarioVarPointers[_part_path_follow_2]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_2]) = false;
#endif
#if defined(var_part_path_follow_3) && defined(var_part_path_repulse_3)
		* ((bool*)ScenarioVarPointers[_part_path_follow_3]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_3]) = false;
#endif
#if defined(var_part_path_follow_4) && defined(var_part_path_repulse_4)
		* ((bool*)ScenarioVarPointers[_part_path_follow_4]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_4]) = false;
#endif
#if defined(var_part_path_follow_5) && defined(var_part_path_repulse_5)
		* ((bool*)ScenarioVarPointers[_part_path_follow_5]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_5]) = false;
#endif
#if defined(var_part_path_follow_6) && defined(var_part_path_repulse_6)
		* ((bool*)ScenarioVarPointers[_part_path_follow_6]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_6]) = false;
#endif
#if defined(var_part_path_follow_7) && defined(var_part_path_repulse_7)
		* ((bool*)ScenarioVarPointers[_part_path_follow_7]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_7]) = false;
#endif
#if defined(var_part_path_follow_8) && defined(var_part_path_repulse_8)
		* ((bool*)ScenarioVarPointers[_part_path_follow_8]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_8]) = false;
#endif
#if defined(var_part_path_follow_9) && defined(var_part_path_repulse_9)
		* ((bool*)ScenarioVarPointers[_part_path_follow_9]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_9]) = false;
#endif
#if defined(var_part_path_follow_10) && defined(var_part_path_repulse_10)
		* ((bool*)ScenarioVarPointers[_part_path_follow_10]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_10]) = false;
#endif
#if defined(var_part_path_follow_11) && defined(var_part_path_repulse_11)
		* ((bool*)ScenarioVarPointers[_part_path_follow_11]) = false;
		*((bool*)ScenarioVarPointers[_part_path_repulse_11]) = false;
#endif
	}
}
void part_path_follow_callBack(int pathNo, pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	bool state = false;
	if (ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank]) {
#if defined(var_part_path_follow_0)
		switch (pathNo) {
		case 0:
			state = part_path_follow_0;
			break;
#if defined(var_part_path_follow_1)
		case 1:
			state = part_path_follow_1;
			break;
#endif
#if defined(var_part_path_follow_2)
		case 2:
			state = part_path_follow_2;
			break;
#endif
#if defined(var_part_path_follow_3)
		case 3:
			state = part_path_follow_3;
			break;
#endif
#if defined(var_part_path_follow_4)
		case 4:
			state = part_path_follow_4;
			break;
#endif
#if defined(var_part_path_follow_5)
		case 5:
			state = part_path_follow_5;
			break;
#endif
#if defined(var_part_path_follow_6)
		case 6:
			state = part_path_follow_6;
			break;
#endif
#if defined(var_part_path_follow_7)
		case 7:
			state = part_path_follow_7;
			break;
#endif
#if defined(var_part_path_follow_8)
		case 8:
			state = part_path_follow_8;
			break;
#endif
#if defined(var_part_path_follow_9)
		case 9:
			state = part_path_follow_9;
			break;
#endif
#if defined(var_part_path_follow_10)
		case 10:
			state = part_path_follow_10;
			break;
#endif
#if defined(var_part_path_follow_11b)
		case 11:
			state = part_path_follow_11;
			break;
#endif
		}
#endif

		if (!state)
			return; // nothing to do for null values

		part_move_init();

#if defined(var_part_path_follow_0)
		switch (pathNo) {
		case 0:
			*((bool*)ScenarioVarPointers[_part_path_follow_0]) = state;
			break;
#if defined(var_part_path_follow_1)
		case 1:
			*((bool*)ScenarioVarPointers[_part_path_follow_1]) = state;
			break;
#endif
#if defined(var_part_path_follow_2)
		case 2:
			*((bool*)ScenarioVarPointers[_part_path_follow_2]) = state;
			break;
#endif
#if defined(var_part_path_follow_3)
		case 3:
			*((bool*)ScenarioVarPointers[_part_path_follow_3]) = state;
			break;
#endif
#if defined(var_part_path_follow_4)
		case 4:
			*((bool*)ScenarioVarPointers[_part_path_follow_4]) = state;
			break;
#endif
#if defined(var_part_path_follow_5)
		case 5:
			*((bool*)ScenarioVarPointers[_part_path_follow_5]) = state;
			break;
#endif
#if defined(var_part_path_follow_6)
		case 6:
			*((bool*)ScenarioVarPointers[_part_path_follow_6]) = state;
			break;
#endif
#if defined(var_part_path_follow_7)
		case 7:
			*((bool*)ScenarioVarPointers[_part_path_follow_7]) = state;
			break;
#endif
#if defined(var_part_path_follow_8)
		case 8:
			*((bool*)ScenarioVarPointers[_part_path_follow_8]) = state;
			break;
#endif
#if defined(var_part_path_follow_9)
		case 9:
			*((bool*)ScenarioVarPointers[_part_path_follow_9]) = state;
			break;
#endif
#if defined(var_part_path_follow_10)
		case 10:
			*((bool*)ScenarioVarPointers[_part_path_follow_10]) = state;
			break;
#endif
#if defined(var_part_path_follow_11)
		case 11:
			*((bool*)ScenarioVarPointers[_part_path_follow_11]) = state;
			break;
#endif
		}
#endif
	}
}
void part_path_repulse_callBack(int pathNo, pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	bool state = false;
	if (ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank]) {
#if defined(var_part_path_repulse_0)
		switch (pathNo) {
		case 0:
			state = part_path_repulse_0;
			break;
#if defined(var_part_path_repulse_1)
		case 1:
			state = part_path_repulse_1;
			break;
#endif
#if defined(var_part_path_repulse_2)
		case 2:
			state = part_path_repulse_2;
			break;
#endif
#if defined(var_part_path_repulse_3)
		case 3:
			state = part_path_repulse_3;
			break;
#endif
#if defined(var_part_path_repulse_4)
		case 4:
			state = part_path_repulse_4;
			break;
#endif
#if defined(var_part_path_repulse_5)
		case 5:
			state = part_path_repulse_5;
			break;
#endif
#if defined(var_part_path_repulse_6)
		case 6:
			state = part_path_repulse_6;
			break;
#endif
#if defined(var_part_path_repulse_7)
		case 7:
			state = part_path_repulse_7;
			break;
#endif
#if defined(var_part_path_repulse_8)
		case 8:
			state = part_path_repulse_8;
			break;
#endif
#if defined(var_part_path_repulse_9)
		case 9:
			state = part_path_repulse_9;
			break;
#endif
#if defined(var_part_path_repulse_10)
		case 10:
			state = part_path_repulse_10;
			break;
#endif
#if defined(var_part_path_repulse_11)
		case 11:
			state = part_path_repulse_11;
			break;
#endif
		}
}
#endif

	if (!state)
		return; // nothing to do for null values
	if (ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank]) {
		part_move_init();
	}

	if (ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank]) {
#if defined(var_part_path_repulse_0)
		switch (pathNo) {
		case 0:
			*((bool*)ScenarioVarPointers[_part_path_repulse_0]) = state;
			break;
#if defined(var_part_path_repulse_1)
		case 1:
			*((bool*)ScenarioVarPointers[_part_path_repulse_1]) = state;
			break;
#endif
#if defined(var_part_path_repulse_2)
		case 2:
			*((bool*)ScenarioVarPointers[_part_path_repulse_2]) = state;
			break;
#endif
#if defined(var_part_path_repulse_3)
		case 3:
			*((bool*)ScenarioVarPointers[_part_path_repulse_3]) = state;
			break;
#endif
#if defined(var_part_path_repulse_4)
		case 4:
			*((bool*)ScenarioVarPointers[_part_path_repulse_4]) = state;
			break;
#endif
#if defined(var_part_path_repulse_5)
		case 5:
			*((bool*)ScenarioVarPointers[_part_path_repulse_5]) = state;
			break;
#endif
#if defined(var_part_path_repulse_6)
		case 6:
			*((bool*)ScenarioVarPointers[_part_path_repulse_6]) = state;
			break;
#endif
#if defined(var_part_path_repulse_7)
		case 7:
			*((bool*)ScenarioVarPointers[_part_path_repulse_7]) = state;
			break;
#endif
#if defined(var_part_path_repulse_8)
		case 8:
			*((bool*)ScenarioVarPointers[_part_path_repulse_8]) = state;
			break;
#endif
#if defined(var_part_path_repulse_9)
		case 9:
			*((bool*)ScenarioVarPointers[_part_path_repulse_9]) = state;
			break;
#endif
#if defined(var_part_path_repulse_10)
		case 10:
			*((bool*)ScenarioVarPointers[_part_path_repulse_10]) = state;
			break;
#endif
#if defined(var_part_path_repulse_11)
		case 11:
			*((bool*)ScenarioVarPointers[_part_path_repulse_11]) = state;
			break;
#endif
		}
}
#endif
}
#if defined(var_part_path_follow_0)
void part_path_follow_0_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(0, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_1)
void part_path_follow_1_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(1, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_2)
void part_path_follow_2_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(2, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_3)
void part_path_follow_3_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(3, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_4)
void part_path_follow_4_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(4, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_5)
void part_path_follow_5_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(5, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_6)
void part_path_follow_6_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(6, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_7)
void part_path_follow_7_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(7, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_8)
void part_path_follow_8_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(8, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_9)
void part_path_follow_9_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(9, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_10)
void part_path_follow_10_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(10, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_follow_11)
void part_path_follow_11_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_follow_callBack(11, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_0)
void part_path_repulse_0_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(0, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_1)
void part_path_repulse_1_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(1, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_2)
void part_path_repulse_2_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(2, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_3)
void part_path_repulse_3_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(3, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_4)
void part_path_repulse_4_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(4, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_5)
void part_path_repulse_5_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(5, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_6)
void part_path_repulse_6_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(6, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_7)
void part_path_repulse_7_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(7, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_8)
void part_path_repulse_8_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(8, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_9)
void part_path_repulse_9_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(9, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_10)
void part_path_repulse_10_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(10, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_part_path_repulse_11)
void part_path_repulse_11_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	part_path_repulse_callBack(11, param_input_type, scenario_or_gui_command_value);
}
#endif
#if defined(var_partMove_target) && defined(var_partMove_rand) && defined(var_part_timeToTargt)
void partMove_target_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	// printf("Particle move target %d\n" , int(partMove_target));
	bool state = partMove_target;
	if (!state)
		return; // nothing to do for null values
	partMove_rand = false;
	partMove_target = state;
}
void partMove_rand_callBack(pg_Parameter_Input_Type param_input_type, bool scenario_or_gui_command_value) {
	bool state = partMove_rand;
	if (!state)
		return; // nothing to do for null values
	partMove_target = false;
	partMove_rand = state;
}
void part_initialization_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	pg_targetFrameNo = pg_FrameNo + int(part_timeToTargt);
	//printf("part initialization call back %d %d\n", part_initialization, scenario_or_gui_command_value);
}
#endif
#endif

#if defined(var_sensor_layout)
void sensor_layout_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	// copies the grid layout
	if (ScenarioVarConfigurations[_sensor_layout][pg_current_configuration_rank]) {
		assignSensorPositions();
	}
}
void sensor_activation_callBack(pg_Parameter_Input_Type param_input_type, int scenario_or_gui_command_value) {
	// copies the grid layout
	if (ScenarioVarConfigurations[_sensor_layout][pg_current_configuration_rank]) {
		assignSensorActivations();
	}
}
void sensor_sample_setUp_callBack(pg_Parameter_Input_Type param_input_type, float scenario_or_gui_command_value) {
	if (ScenarioVarConfigurations[_sensor_layout][pg_current_configuration_rank]) {
		sensor_sample_setUp_interpolation();
	}
}
#endif

///////////////////////////////////////////////////////////////////////////////////
// SCENARIO BASED COMMANDS
#if defined(var_path_record_1)
void pg_NextRecordReplayPath(void) {
	// only one track recording per second to avoid repetition
	if (pg_CurrentClockTime - LastTrackRecordingChangeClockTime > 1) {
		LastTrackRecordingChangeClockTime = pg_CurrentClockTime;
	}
	else {
		return;
	}
#if defined(var_path_record_11)
	if (path_record_11) {
		path_replay_trackNo_callBack(11, _PG_GUI_COMMAND, -1);
	}
#endif
#if defined(var_path_record_10)
	else if (path_record_10) {
		path_replay_trackNo_callBack(10, _PG_GUI_COMMAND, -1);
#if PG_NB_PATHS == 11
		path_record_callBack(11, _PG_GUI_COMMAND, true);
#endif
	}
#endif
#if defined(var_path_record_9)
	else if (path_record_9) {
		path_replay_trackNo_callBack(9, _PG_GUI_COMMAND, -1);
#if PG_NB_PATHS == 11
		path_record_callBack(10, _PG_GUI_COMMAND, true);
#endif
	}
#endif
#if defined(var_path_record_8)
	else if (path_record_8) {
		path_replay_trackNo_callBack(8, _PG_GUI_COMMAND, -1);
#if PG_NB_PATHS == 11
		path_record_callBack(9, _PG_GUI_COMMAND, true);
#endif
	}
#endif
#if defined(var_path_record_7)
	else if (path_record_7) {
		path_replay_trackNo_callBack(7, _PG_GUI_COMMAND, -1);
#if PG_NB_PATHS == 11
		path_record_callBack(8, _PG_GUI_COMMAND, true);
#endif
	}
#endif
#if defined(var_path_record_6)
	else if (path_record_6) {
		path_replay_trackNo_callBack(6, _PG_GUI_COMMAND, -1);
#if PG_NB_PATHS == 7 || PG_NB_PATHS == 11
		path_record_callBack(7, _PG_GUI_COMMAND, true);
#endif
	}
#endif
#if defined(var_path_record_5)
	else if (path_record_5) {
		path_replay_trackNo_callBack(5, _PG_GUI_COMMAND, -1);
#if PG_NB_PATHS == 7 || PG_NB_PATHS == 11
		path_record_callBack(6, _PG_GUI_COMMAND, true);
#endif
	}
#endif
#if defined(var_path_record_4)
	else if (path_record_4) {
		path_replay_trackNo_callBack(4, _PG_GUI_COMMAND, -1);
#if PG_NB_PATHS == 7 || PG_NB_PATHS == 11
		path_record_callBack(5, _PG_GUI_COMMAND, true);
#endif
	}
#endif
#if defined(var_path_record_3)
	else if (path_record_3) {
		path_replay_trackNo_callBack(3, _PG_GUI_COMMAND, -1);
#if PG_NB_PATHS == 7 || PG_NB_PATHS == 11
		path_record_callBack(4, _PG_GUI_COMMAND, true);
#endif
	}
#endif
#if defined(var_path_record_2)
	else if (path_record_2) {
		path_replay_trackNo_callBack(2, _PG_GUI_COMMAND, -1);
#if PG_NB_PATHS == 3 || PG_NB_PATHS == 7 || PG_NB_PATHS == 11
		path_record_callBack(3, _PG_GUI_COMMAND, true);
#endif
	}
#endif
	else if (path_record_1) {
		path_replay_trackNo_callBack(1, _PG_GUI_COMMAND, -1);
#if PG_NB_PATHS == 3 || PG_NB_PATHS == 7 || PG_NB_PATHS == 11
		path_record_callBack(2, _PG_GUI_COMMAND, true);
#endif
	}
#if PG_NB_PATHS == 3 || PG_NB_PATHS == 7 || PG_NB_PATHS == 11
	else if (!is_path_replay[1]) {
		path_record_callBack(1, _PG_GUI_COMMAND, true);
	}
	else if (!is_path_replay[2]) {
		path_record_callBack(2, _PG_GUI_COMMAND, true);
	}
	else if (!is_path_replay[3]) {
		path_record_callBack(3, _PG_GUI_COMMAND, true);
	}
#endif
#if PG_NB_PATHS == 7 || PG_NB_PATHS == 11
	else if (!is_path_replay[4]) {
		path_record_callBack(4, _PG_GUI_COMMAND, true);
	}
	else if (!is_path_replay[5]) {
		path_record_callBack(5, _PG_GUI_COMMAND, true);
	}
	else if (!is_path_replay[6]) {
		path_record_callBack(6, _PG_GUI_COMMAND, true);
	}
	else if (!is_path_replay[7]) {
		path_record_callBack(7, _PG_GUI_COMMAND, true);
	}
#endif
#if PG_NB_PATHS == 11
	else if (!is_path_replay[8]) {
		path_record_callBack(8, _PG_GUI_COMMAND, true);
	}
	else if (!is_path_replay[9]) {
		path_record_callBack(9, _PG_GUI_COMMAND, true);
	}
	else if (!is_path_replay[10]) {
		path_record_callBack(10, _PG_GUI_COMMAND, true);
	}
	else if (!is_path_replay[11]) {
		path_record_callBack(11, _PG_GUI_COMMAND, true);
	}
#endif
}
#endif

///////////////////////////////////////////////////////////////////////////////////
// SCENARIO BASED COMMANDS
///////////////////////////////////////////////////////////////////////////////////
void pg_update_variable(pg_Parameter_Input_Type param_input_type,
	int indParam,
	ScenarioValue scenario_or_gui_command_value) {
	// save previous values of variables that have to know their previous value in their 

	if (param_input_type == _PG_SCENARIO) {
		if (BrokenInterpolationVar[indParam]) {
			return;
		}
	}
	if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
		BrokenInterpolationVar[indParam] = true;
	}

	pg_variable_updated[indParam] = true;
	pg_variable_param_input_type[indParam] = param_input_type;
	pg_variable_scenario_or_gui_command_value[indParam] = scenario_or_gui_command_value;

	if (ScenarioVarTypes[indParam] == _pg_float) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
			*((float*)ScenarioVarPointers[indParam]) = float(scenario_or_gui_command_value.val_num);
		}
		//if (indParam == 45) {
		//	printf("Param %d (%s) interp value %.2f var value %.2f\n", 
		//		indParam, ScenarioVarStrings[indParam], float(scenario_or_gui_command_value.val_num), pen_radius);
		//}
	}
	else if (ScenarioVarTypes[indParam] == _pg_int) {
		if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_SCENARIO) {
#if defined(var_nb_CATypes)
			if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]
				&& (indParam == _CA1Type || indParam == _CA2Type ||
					indParam == _CA1SubType || indParam == _CA2SubType)) {
				// for CAType we choose to alternate randomly between both types, according
				// to the proximity of floor or ceiling
				float randVal = rand_0_1;
				float thefloor = float(floor(scenario_or_gui_command_value.val_num));
				float decimalPart = float(scenario_or_gui_command_value.val_num - thefloor);
				if (randVal > decimalPart) {
					*((int*)ScenarioVarPointers[indParam]) = (int)thefloor;
				}
				if (randVal < decimalPart) {
					*((int*)ScenarioVarPointers[indParam]) = (int)thefloor + 1;
				}
			}
			else
#endif
			{
				*((int*)ScenarioVarPointers[indParam]) = int(round(scenario_or_gui_command_value.val_num));
			}
		}
	}
	else if (ScenarioVarTypes[indParam] == _pg_bool) {
		if (param_input_type == _PG_SCENARIO) {
			*((bool*)ScenarioVarPointers[indParam]) = bool(round(scenario_or_gui_command_value.val_num));
		}
		else if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
			*((bool*)ScenarioVarPointers[indParam]) = !(*((bool*)ScenarioVarPointers[indParam]));
			// printf("Opposite boolean index %d value %d\n" , indParam,*((bool *)ScenarioVarPointers[indParam]));
		}
	}
	else if (ScenarioVarTypes[indParam] == _pg_sign) {
		if (param_input_type == _PG_SCENARIO) {
			*((int*)ScenarioVarPointers[indParam]) = (scenario_or_gui_command_value.val_num > 0 ? 1 : (scenario_or_gui_command_value.val_num > 0 ? false : 0));
		}
		else if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
			*((float*)ScenarioVarPointers[indParam]) = -1.0f * (*((float*)ScenarioVarPointers[indParam]));
		}
	}
	else if (ScenarioVarTypes[indParam] == _pg_path) {
		if (param_input_type == _PG_SCENARIO) {
			*((bool*)ScenarioVarPointers[indParam]) = (scenario_or_gui_command_value.val_num > 0 ? true : false);
		}
		else if (param_input_type == _PG_GUI_COMMAND || param_input_type == _PG_KEYSTROKE) {
			*((bool*)ScenarioVarPointers[indParam]) = !(*((bool*)ScenarioVarPointers[indParam]));
			// printf("Opposite boolean index %d value %d\n" , indParam,*((bool *)ScenarioVarPointers[indParam]));
		}
	}
}
// runs a callBack on a variable which has been updated
void pg_run_a_callBack(int indParam) {
	if (pg_variable_updated[indParam] && ScenarioVarCallbacks[indParam]) {
		(*ScenarioVarCallbacks[indParam])(pg_variable_param_input_type[indParam], pg_variable_scenario_or_gui_command_value[indParam]);
	}
	pg_variable_updated[indParam] = false;
}

#if defined(PIERRES)
/// <summary>
/// updates the position of the cursor in the Keystone pad for texture keystone distortion
/// </summary>
/// <param name=""></param>
void updateXYKeystonePad(void) {
	// Keystone interface
	sprintf(AuxString, "/TopLeft %.2f %.2f", -VP1KeystoneYTopLeft, VP1KeystoneXTopLeft);
	pg_send_message_udp((char*)"ff", AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/BottomLeft %.2f %.2f", -float(double(VP1KeystoneYBottomLeft) - 1.f), VP1KeystoneXBottomLeft);
	pg_send_message_udp((char*)"ff", AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/TopRight %.2f %.2f", -VP1KeystoneYTopRight, float(double(VP1KeystoneXTopRight) - 1.f));
	pg_send_message_udp((char*)"ff", AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/BottomRight %.2f %.2f", -float(double(VP1KeystoneYBottomRight) - 1.f), float(double(VP1KeystoneXBottomRight) - 1.f));
	pg_send_message_udp((char*)"ff", AuxString, (char*)"udp_TouchOSC_send");
}
#endif


#if defined(TVW)
int SubScenesDiaporamaDir(int currentScene) {
	switch (currentScene) {
	case 0:
			return 0;
			break;
		case 1:
			return 0;
			break;
		case 2://letsgo
			return 0;
			break;
		case 3://phoneclear
			return 7;
			break;
		case 4://phonedark
			return 9;
			break;
		case 5://palestine_in
			return 11;
			break;
		case 6://palestine
			return 11;
			break;
		case 7://gbagbo_in
			return 13;
			break;
		case 8://gbagbo
			return 13;
			break;
		case 9://armee
			return 17;
			break;
		case 10://armee_flash
			return 22;
			break;
		case 11://SoE
			return 23;
			break;
		case 12://Master
			return 23;
			break;
		default:
			return 23;
			break;
}}
void pg_update_visual_and_text_chapters(bool new_scene) {
	// all scenes except first and last
	// the first scene is not special in case of relaunch
	if ((pg_CurrentSceneIndex > 0 || pg_NbScenes[pg_current_configuration_rank] < 13) && (pg_CurrentSceneIndex < pg_NbScenes[pg_current_configuration_rank] - 1)) {
		int old_pg_CurrentDiaporamaDir = pg_CurrentDiaporamaDir;
		if (new_scene) {
			pg_CurrentDiaporamaDir = SubScenesDiaporamaDir(pg_CurrentSceneIndex);
		}
		else if(pg_CurrentScene) {
			// possible text and visual scene advance
			float elapsed_time_from_start = pg_CurrentClockTime - InitialScenarioTime;

			pg_CurrentDiaporamaDir
				= (int(elapsed_time_from_start - pg_CurrentScene->scene_initial_time) / 60)
				+ SubScenesDiaporamaDir(pg_CurrentSceneIndex);
		}
		if (pg_CurrentDiaporamaDir >= pg_nbCompressedImageDirs[pg_current_configuration_rank]) {
			pg_CurrentDiaporamaDir = pg_nbCompressedImageDirs[pg_current_configuration_rank] - 1;
		}
		if (old_pg_CurrentDiaporamaDir != pg_CurrentDiaporamaDir) {
			// IMAGE CHOICE AND SWAP INIT
			// sets the directory for images
			// the first scene starts with 6 preloaded images
			if (pg_CurrentDiaporamaDir == 0)
				pg_CurrentDiaporamaFile = 6;
			else
				pg_CurrentDiaporamaFile = 0;
			// printf("scene / diaporama dir %d %d\n", pg_CurrentSceneIndex, pg_CurrentDiaporamaDir);

			// TEXT CHOICE AND SWAP INIT
			// sets the index for messages
			// initialization (first message to be displayed)
			if (DisplayText1Front) {
				IndDisplayText2 = DisplayTextFirstInChapter[pg_CurrentDiaporamaDir];
				LengthDisplayText2 = (float)pg_displayMessage_update(2);
				IndDisplayText1 = DisplayTextFirstInChapter[pg_CurrentDiaporamaDir] + 1;
				LengthDisplayText1 = (float)pg_displayMessage_update(1);
				DisplayText1Front = false;
				DisplayText1Alpha = 1.0f;
				DisplayText2Alpha = 0.0f;
			}
			else {
				IndDisplayText1 = DisplayTextFirstInChapter[pg_CurrentDiaporamaDir];
				LengthDisplayText1 = (float)pg_displayMessage_update(1);
				IndDisplayText2 = DisplayTextFirstInChapter[pg_CurrentDiaporamaDir] + 1;
				LengthDisplayText2 = (float)pg_displayMessage_update(2);
				DisplayText1Front = true;
				DisplayText1Alpha = 0.0f;
				DisplayText2Alpha = 1.0f;
			}
			DisplayTextSwapInitialTime = pg_CurrentClockTime;
			//printf("New text DisplayText1Front %d index 1/2 %d/%d dir %d dir size %d\n", int(DisplayText1Front), IndDisplayText1, IndDisplayText2, pg_CurrentDiaporamaDir, DisplayTextFirstInChapter[pg_CurrentDiaporamaDir]);
		}

		// sets the start index for available image layer to the first layer
		if (new_scene) {
			pg_IndInitialSwapPhoto = 0;
		}

		if (pg_CurrentDiaporamaDir >= pg_nbCompressedImageDirs[pg_current_configuration_rank]) {
			pg_CurrentDiaporamaDir = pg_nbCompressedImageDirs[pg_current_configuration_rank] - 1;
		}
	}
	else {
		// no visuals / no tweets
		IndDisplayText1 = -1;
		IndDisplayText1 = -1;
		DisplayText1Alpha = 0.0f;
		DisplayText2Alpha = 0.0f;
	}
}
#endif

////////////////////////////////////////////////////////////////////////////////////
// BEGINNING OF A NEW SCENE: INITIALIZATION OF TIMES AND DURATIONS, AND VARIABLE VALUES

// saves the current values of the parameters in case of k (copy) interpolation mode
// or in case of interpolation between the current values and the initial values of the current scene
void pg_keep_value_copy(Scene* currentScene, int indVar, ScenarioValue* parameter_value) {
	if (ScenarioVarTypes[indVar] == _pg_float) {
		parameter_value[indVar].val_num = double(*((float*)ScenarioVarPointers[indVar]));
	}
	else if (ScenarioVarTypes[indVar] == _pg_int) {
		parameter_value[indVar].val_num = double(*((int*)ScenarioVarPointers[indVar]));
	}
	else if (ScenarioVarTypes[indVar] == _pg_bool) {
		if (*((bool*)ScenarioVarPointers[indVar]) != false) {
			parameter_value[indVar].val_num = 1;
		}
		else {
			parameter_value[indVar].val_num = 0;
		}
	}
	else if (ScenarioVarTypes[indVar] == _pg_sign) {
		parameter_value[indVar].val_num = double(*((int*)ScenarioVarPointers[indVar]));
	}
	else if (ScenarioVarTypes[indVar] == _pg_path) {
		if (*((bool*)ScenarioVarPointers[indVar]) != false) {
			parameter_value[indVar].val_num = 1;
		}
		else {
			parameter_value[indVar].val_num = 0;
		}
	}
	else if (ScenarioVarTypes[indVar] == _pg_string) {
		parameter_value[indVar].val_string = *((string*)ScenarioVarPointers[indVar]);
	}
}

// begins a new configuration and selects the initial variables in this scene
void StartNewConfiguration(int config_no) {
	if (config_no >= _NbConfigurations || config_no < 0) {
		return;
	}
	pg_current_configuration_rank = config_no;

	pg_launch_performance(0);
	StartNewScene(0, 0);
}


// begins a new scene and updates scene variables
void StartNewScene(int ind_scene, double delta_time) {
	pg_last_scene_update = false;

	/////////////////////////////////////////////////
	// No interpolation: starts immediately a new scene
	if (pg_SceneInterpolationDuration <= 0 && ind_scene >= 0 && ind_scene < pg_NbScenes[pg_current_configuration_rank]) {
		pg_SceneIndexAfterInterpolation = -1;

		restoreInitialTimesAndDurations();

		// we place the beginning of the current scene at this time
		pg_Scenario[pg_current_configuration_rank][ind_scene].scene_initial_time -= delta_time;
		pg_Scenario[pg_current_configuration_rank][ind_scene].scene_duration += delta_time;
		if (ind_scene > 0) {
			pg_Scenario[pg_current_configuration_rank][ind_scene - 1].scene_final_time -= delta_time;
			pg_Scenario[pg_current_configuration_rank][ind_scene - 1].scene_duration -= delta_time;
		}
		// unuseful because is already made through pg_Scenario[pg_current_configuration_rank][ind_scene].scene_initial_time -= delta_time;
		//InitialScenarioTime = pg_CurrentClockTime - pg_Scenario[pg_current_configuration_rank][ind_scene].scene_initial_time;

		InitialScenarioTime = pg_CurrentClockTime - pg_Scenario[pg_current_configuration_rank][ind_scene].scene_initial_time;
		if (ind_scene == 0) {
			// restarts scenarios
			AbsoluteInitialScenarioTime = pg_CurrentClockTime - pg_Scenario[pg_current_configuration_rank][0].scene_initial_time;
		}

		// UPDATES THE SCENE POINTERS AND INDICES
		pg_CurrentSceneIndex = ind_scene;
		pg_CurrentScene = &pg_Scenario[pg_current_configuration_rank][pg_CurrentSceneIndex];
		pg_SceneIndexBeforeInterpolation = -1;
		pg_SceneIndexAfterInterpolation = -1;

#ifdef KOMPARTSD
		pg_IPClient* client;
		if ((client = pg_UDP_client((char*)"udp_Record_send"))) {
			// sends the new scene to recording for later replay
			sprintf(AuxString, "/new_scene %d", ind_scene);
			pg_send_message_udp((char*)"i", (char*)AuxString, client);
		}
		if ((client = pg_UDP_client((char*)"udp_Usine_send"))) {
			// sends the new scene to Usine for sample selection
			for (int ind = 0; ind < 4; ind++) {
				if (ind == ind_scene) {
					sprintf(AuxString, "/new_scene_%d 1", ind);
				}
				else {
					sprintf(AuxString, "/new_scene_%d 0", ind);
				}
				pg_send_message_udp((char*)"i", (char*)AuxString, client);
			}
		}
#endif
#if defined(ETOILES)
		if (pg_CurrentSceneIndex == 0 || pg_CurrentSceneIndex == 5) {
			pg_Ind_Current_DisplayText = 0;
		}
#endif

	}
	/////////////////////////////////////////////////
	// SCENE INTERPOLATION: linear interpolation of current variable values to a new scene 
	// variables all keep their current values and interpolate towards the values of the variables in the target scene
	else {
		//printf("Start interpolation scene\n");
		// UPDATES THE SCENE POINTERS AND INDICES
		pg_CurrentSceneIndex = -1;
		pg_CurrentScene = &pg_InterpolationScene;
		pg_SceneIndexBeforeInterpolation = pg_CurrentSceneIndex;
		pg_SceneIndexAfterInterpolation = ind_scene;

		//to be completed
		if (pg_CurrentScene) {
			pg_CurrentScene->scene_IDs = "INTERPOLATION";
			pg_CurrentScene->scene_duration = pg_SceneInterpolationDuration;
			pg_CurrentScene->scene_change_when_ends = true;
			pg_CurrentScene->scene_initial_time = pg_CurrentClockTime;
			pg_CurrentScene->scene_final_time = pg_CurrentScene->scene_initial_time + pg_SceneInterpolationDuration;
			pg_CurrentScene->scene_originalDuration = pg_SceneInterpolationDuration;
			pg_CurrentScene->scene_originalInitial_time = pg_CurrentClockTime;
			pg_CurrentScene->scene_originalFinal_time = pg_CurrentScene->scene_initial_time + pg_SceneInterpolationDuration;

			for (int indP = 0; indP < ScenarioVarNb[pg_current_configuration_rank]; indP++) {
				int indVar = ConfigScenarioVarRank[indP][pg_current_configuration_rank];
				if (ScenarioVarConfigurations[indP][pg_current_configuration_rank]) {
					// copies the current value in the initial value
					pg_keep_value_copy(pg_CurrentScene, indP, pg_CurrentScene->scene_initial_parameters);
					// if the next interpolation keeps the value, copies the current value in the final value
					// otherwise copies the initial value of the target scene as final value of the interpolaiton scene
					if (pg_Scenario[pg_current_configuration_rank][pg_SceneIndexAfterInterpolation].scene_interpolations[indP].interpolation_mode != pg_keep_value) {
						pg_CurrentScene->scene_final_parameters[indP] = pg_Scenario[pg_current_configuration_rank][pg_SceneIndexAfterInterpolation].scene_initial_parameters[indP]; // next scene initial value
					}
					else {
						pg_keep_value_copy(pg_CurrentScene, indP, pg_CurrentScene->scene_final_parameters);
					}
				}
			}
			for (int indP = 0; indP < ScenarioVarNb[pg_current_configuration_rank]; indP++) {
				int indVar = ConfigScenarioVarRank[indP][pg_current_configuration_rank];
				if (ScenarioVarConfigurations[indP][pg_current_configuration_rank]) {
					pg_CurrentScene->scene_interpolations[indP].interpolation_mode = pg_linear_interpolation;
					pg_CurrentScene->scene_interpolations[indP].offSet = 0.0;
					pg_CurrentScene->scene_interpolations[indP].duration = 1.0;
				}
			}
			//printf("Master values cur %.2f ini %.2f fin %.2f\n", *((float*)ScenarioVarPointers[_master]), 
			//	pg_CurrentScene->scene_final_parameters[_master], pg_CurrentScene->scene_final_parameters[_master]);
			// resets interpolation time so that the interpolation does not restart indefinitely
			pg_SceneInterpolationDuration = 0.f;
#if !defined(LIGHT)
			sprintf(AuxString, "/interpolation_duration %.2f", pg_SceneInterpolationDuration);
			pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif
		}
	}

#if !defined(LIGHT)
	if (pg_CurrentScene) {
		pg_FirstFrameInScene = true;
		sprintf(AuxString, "/setupNo %d", pg_CurrentSceneIndex); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/setup %s", pg_CurrentScene->scene_IDs.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/setup_1 %s", pg_CurrentScene->scene_Msg1.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		sprintf(AuxString, "/setup_2 %s", pg_CurrentScene->scene_Msg2.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		if (pg_CurrentSceneIndex < pg_NbScenes[pg_current_configuration_rank] - 1) {
			sprintf(AuxString, "/setup_next next:_%s", pg_Scenario[pg_current_configuration_rank][pg_CurrentSceneIndex + 1].scene_IDs.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		}
		else {
			sprintf(AuxString, "/setup_next next:_%s", (char*)"END"); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		}
	}
#endif

	if (pg_CurrentScene) {
		std::cout << "Scene: " << pg_CurrentScene->scene_IDs << std::endl;
		// fprintf(pg_csv_log_file, "Scene:%d %s\n", pg_CurrentSceneIndex, pg_CurrentScene->scene_IDs.c_str());
		// reinitialization of the interpolation control variables at the beginning of a new scene
		for (int indP = 0; indP < ScenarioVarNb[pg_current_configuration_rank]; indP++) {
			int indVar = ConfigScenarioVarRank[indP][pg_current_configuration_rank];
			if (ScenarioVarConfigurations[indVar][pg_current_configuration_rank]) {
				BrokenInterpolationVar[indVar] = false;
				StepwiseInterpolationEffective[indVar] = false;
				if (pg_CurrentScene->scene_interpolations[indVar].interpolation_mode == pg_keep_value
					|| pg_CurrentScene->scene_interpolations[indVar].initialization_mode == pg_current_value) {
					pg_keep_value_copy(pg_CurrentScene, indVar, pg_CurrentScene->scene_initial_parameters);
				}
			}
		}
	}
	// stops ongoing flashes if there is one
	flashCameraTrk_weight = 0.0f;
#if defined(var_flashPhotoTrkBeat) && defined(var_flashPhotoTrkBright) && defined(var_flashPhotoTrkLength) && defined(var_flashPhotoChangeBeat)
	if (ScenarioVarConfigurations[_flashPhotoTrkBeat][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_flashPhotoTrkBright][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_flashPhotoTrkLength][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_flashPhotoChangeBeat][pg_current_configuration_rank]) {
		flashPhotoTrk_weight = 0.0f;
		flashPhotoTrk_nbFrames = 0;
	}
#endif

#if defined(TVW)
	// updates image and text directories
	pg_update_visual_and_text_chapters(true);
#endif
}

#if defined(TVW)
float starting_time(float elapsed_time_from_start) {
	if (pg_NbScenes[pg_current_configuration_rank] == 13) {
		if (elapsed_time_from_start > pg_Scenario[pg_current_configuration_rank][2].scene_initial_time ) {
			return pg_Scenario[pg_current_configuration_rank][2].scene_initial_time;
		}
		else {
			return 0.f;
		}
	}
	else if (pg_NbScenes[pg_current_configuration_rank] == 11) { // relaunch 6mn
		return -360.f;
	}
	else if (pg_NbScenes[pg_current_configuration_rank] == 7) { // relaunch 12
		return -720.f;
	}
	else if (pg_NbScenes[pg_current_configuration_rank] == 4) { // relaunch 20
		return -1200.f;
	}
	return 0.f;
}
#endif

////////////////////////////////////////////////////////////////////////////////////
// UPDATE OF A CURRENT SCENE: UPDATE OF VARIABLE VALUES ACCORDING TO INTERPOLATIONS

void pg_update_scene_variables(Scene* cur_scene, double elapsed_time_from_start) {
	// transformed interpolation according to the interpolation function
	for (int indP = 0; indP < ScenarioVarNb[pg_current_configuration_rank]; indP++) {
		int indVar = ConfigScenarioVarRank[indP][pg_current_configuration_rank];
		//printf("Scene %d indP %d indVar %d\n", pg_CurrentSceneIndex, indP, indVar);
		//if (indVar == _cameraNo) {
		//	printf("Scene %d belongs to config %d\n",
		//		pg_CurrentSceneIndex, ScenarioVarConfigurations[indVar][pg_current_configuration_rank]);
		//}
		if (ScenarioVarConfigurations[indVar][pg_current_configuration_rank]) {
			//if (indVar == _cameraNo) {
			//	printf("Scene %d interpolation %d pg_keep_value %d\n",
			//		pg_CurrentSceneIndex, cur_scene->scene_interpolations[indVar].interpolation_mode, pg_keep_value);
			//}
			if (cur_scene->scene_interpolations[indVar].interpolation_mode == pg_keep_value) {
				continue;
			}
			// going from interpolation percentages to interpolation times by multiplying by scene duration
			double absoluteOffset = cur_scene->scene_interpolations[indVar].offSet
				* cur_scene->scene_duration;
			double absoluteDuration = cur_scene->scene_interpolations[indVar].duration
				* cur_scene->scene_duration;

			double transformedInterpolation = 0.0f;
			double coefInterpolation = 0.0f;
			double twoStepInterpolation[3] = { 0.0f , 0.0f , 0.0f };

			if (elapsed_time_from_start <= cur_scene->scene_initial_time + absoluteOffset) {
				transformedInterpolation = 0.0;
				twoStepInterpolation[0] = 1.0;
				twoStepInterpolation[1] = 0.0;
				twoStepInterpolation[2] = 0.0;
			}
			else if (elapsed_time_from_start >= cur_scene->scene_initial_time + absoluteOffset + absoluteDuration) {
				transformedInterpolation = 1.0;
				twoStepInterpolation[0] = 0.0;
				twoStepInterpolation[1] = 0.0;
				twoStepInterpolation[2] = 1.0;
			}
			else {
				coefInterpolation
					= elapsed_time_from_start - (cur_scene->scene_initial_time + absoluteOffset);
				// time normalization for interpolation
				if (absoluteDuration > 0.0) {
					coefInterpolation /= absoluteDuration;
				}
				if (coefInterpolation < 0.0) {
					coefInterpolation = 0.0;
				}
				if (coefInterpolation > 1.0) {
					coefInterpolation = 1.0;
				}

				switch (cur_scene->scene_interpolations[indVar].interpolation_mode) {
				case pg_linear_interpolation:
					transformedInterpolation = coefInterpolation;
					break;
				case pg_cosine_interpolation:
					transformedInterpolation
						= 0.5F * (cos((coefInterpolation - 1.0F) * (float)M_PI) + 1.0F);
					break;
				case pg_bezier_interpolation:
					// approximation of a bezier with cosine (more slow at beginning and end)
					transformedInterpolation
						= 0.5F * (cos((3 * pow(fabs(coefInterpolation), 2) - 2 * pow(fabs(coefInterpolation), 3) - 1.0F) * (float)M_PI) + 1.0F);
					break;
				case pg_exponential_interpolation:
					// approximation of a bezier with cosine (more slow at beginning and end)
					transformedInterpolation
						= pow(fabs(coefInterpolation), cur_scene->scene_interpolations[indVar].exponent);
					break;
				case pg_bell_interpolation:
					transformedInterpolation = coefInterpolation;
					if (coefInterpolation < 0.5f) {
						twoStepInterpolation[0] = 0.5F * (cos(2.0f * transformedInterpolation * (double)M_PI) + 1.0F);
						twoStepInterpolation[1] = 1.0f - twoStepInterpolation[0];
						twoStepInterpolation[2] = 0.0f;
					}
					else {
						twoStepInterpolation[0] = 0.0f;
						twoStepInterpolation[1] = 1.0f - 0.5F * (cos(2.0f * transformedInterpolation * (double)M_PI) + 1.0F);
						twoStepInterpolation[2] = 1.0f - twoStepInterpolation[1];
					}
					//printf("Scene %s param %d time from start %.2f interp %.2f transf_interp %.2f 2-step interp  %.2f %.2f %.2f start interp %.2f duration %.2f\n",
					   //cur_scene->scene_IDs.c_str(), indVar, elapsed_time_from_start, coefInterpolation, transformedInterpolation, twoStepInterpolation[0], twoStepInterpolation[1], twoStepInterpolation[2], absoluteOffset, absoluteDuration);
					break;
				case pg_sawtooth_interpolation:
					transformedInterpolation = coefInterpolation;
					if (coefInterpolation < 0.5f) {
						twoStepInterpolation[0] = 1.0f - 2.0f * transformedInterpolation;
						twoStepInterpolation[1] = 1.0f - twoStepInterpolation[0];
						twoStepInterpolation[2] = 0.0f;
					}
					else {
						twoStepInterpolation[0] = 0.0f;
						twoStepInterpolation[1] = 2.0f - 2.0f * transformedInterpolation;;
						twoStepInterpolation[2] = 1.0f - twoStepInterpolation[1];
					}
					break;
				case pg_stepwise_interpolation:
					// printf("Stepwise interpolations have no intermediate values\n");
					// no offset keeps initial value during the whole scene
					if (cur_scene->scene_interpolations[indVar].offSet == 0) {
						transformedInterpolation = 0.f;
					}
					else {
						if (coefInterpolation <= 0.f) {
							transformedInterpolation = 0.f;
						}
						else {
							transformedInterpolation = 1.f;
						}
					}
					break;
				default:
					printf("Unknown interpolation mode!\n");
					break;
				}
			}

			//if (indVar == _cameraNo) {
			//	printf("Scene %d transformedInterpolation %.2f pg_FirstFrameInScene %d\n",
			//		pg_CurrentSceneIndex, transformedInterpolation, pg_FirstFrameInScene);
			//}
			if ((transformedInterpolation == 0.0 && pg_FirstFrameInScene)
				|| transformedInterpolation > 0.0) {
				// calculation of the interpolated value and assignment to variable
				double interpolated_value = cur_scene->scene_initial_parameters[indVar].val_num;
				// stepwise interpolation
				if (cur_scene->scene_interpolations[indVar].interpolation_mode == pg_stepwise_interpolation) {
					//if (indVar == _cameraNo) {
					//	 printf( "Scene %d param %d time from start %.2f transf_interp %.2f value %.2f start interp %.2f end interp %.2f duration %.2f\n" , 
					//		 pg_CurrentSceneIndex, indVar, elapsed_time_from_start , transformedInterpolation , interpolated_value ,
					//		 cur_scene->scene_initial_parameters[indVar].val_num, cur_scene->scene_final_parameters[indVar].val_num,
					//		 cur_scene->scene_duration);
					//}
					// delayed stepwise change, made only once
					if (transformedInterpolation > 0.0
						&& StepwiseInterpolationEffective[indVar] == false) {
						pg_update_variable(_PG_SCENARIO,
							indVar, cur_scene->scene_final_parameters[indVar]);
						StepwiseInterpolationEffective[indVar] = true;
					}
					// initial stepwise value
					else if ((transformedInterpolation == 0.0 && pg_FirstFrameInScene)) {
						pg_update_variable(_PG_SCENARIO,
							indVar, cur_scene->scene_initial_parameters[indVar]);
						// set to false in case of offSet with later update
						StepwiseInterpolationEffective[indVar] = false;
					}
				}
				// continuous interpolation
				else if (cur_scene->scene_interpolations[indVar].interpolation_mode != pg_bell_interpolation
					&& cur_scene->scene_interpolations[indVar].interpolation_mode != pg_sawtooth_interpolation) {
					if (ScenarioVarTypes[indVar] != _pg_string) {
						// make sure that variables are interpolated to their final value when they reach the target value
						if (transformedInterpolation >= 1.f) {
							//if (indVar == _part_path_follow_0) {
							//	printf("Final value\n");
							//}
							interpolated_value = cur_scene->scene_final_parameters[indVar].val_num;
						}
						else {
							//if (indVar == _part_path_follow_0) {
							//	printf("Interpolated value\n");
							//}
							interpolated_value
								= (1.0F - transformedInterpolation)
								* cur_scene->scene_initial_parameters[indVar].val_num
								+ transformedInterpolation
								* cur_scene->scene_final_parameters[indVar].val_num;
						}

						//if (indVar == _part_path_follow_0) {
						//	printf("Scene %s param %d time from start %.2f interp %.2f transf_interp %.2f value %.2f\n", 
						//		cur_scene->scene_IDs.c_str(), indVar, elapsed_time_from_start, coefInterpolation, transformedInterpolation, interpolated_value);
						//}

						ScenarioValue interpolated_scene_value(interpolated_value, "");
						pg_update_variable(_PG_SCENARIO, indVar, interpolated_scene_value);

						//if (indVar == _part_path_follow_0) {
						//	printf("val ini fin %.2f %.2f alpha %.2f value %.2f val %d/%d\n",
						//		cur_scene->scene_initial_parameters[indVar].val_num,
						//		cur_scene->scene_final_parameters[indVar].val_num, transformedInterpolation, interpolated_value, part_path_follow_0, *((bool*)ScenarioVarPointers[_part_path_follow_0]));
						//}
					}
					else {
						if (transformedInterpolation <= 0.5) {
							pg_update_variable(_PG_SCENARIO,
								indVar, cur_scene->scene_initial_parameters[indVar]);
						}
						else {
							pg_update_variable(_PG_SCENARIO,
								indVar, cur_scene->scene_final_parameters[indVar]);
						}
					}
				}
				// 3-valued bell interpolation between initial, median and end value
				else {
					if (ScenarioVarTypes[indVar] != _pg_string) {
						interpolated_value
							= twoStepInterpolation[0]
							* cur_scene->scene_initial_parameters[indVar].val_num
							+ twoStepInterpolation[1]
							* cur_scene->scene_interpolations[indVar].midTermValue
							+ twoStepInterpolation[2]
							* cur_scene->scene_final_parameters[indVar].val_num;

						//printf("Scene %s param %d time from start %.2f transf_interp %.2f 2-step interp  %.2f %.2f %.2f interpolated value %.2f\n",
						   //cur_scene->scene_IDs.c_str(), indVar, elapsed_time_from_start, transformedInterpolation, twoStepInterpolation[0], twoStepInterpolation[1], twoStepInterpolation[2], interpolated_value);
						ScenarioValue int_val(interpolated_value, "");
						pg_update_variable(_PG_SCENARIO, indVar, int_val);
					}
					else {
						if (twoStepInterpolation[0] > 0) {
							pg_update_variable(_PG_SCENARIO,
								indVar, cur_scene->scene_initial_parameters[indVar]);
						}
						else {
							pg_update_variable(_PG_SCENARIO,
								indVar, cur_scene->scene_final_parameters[indVar]);
						}
					}
				}
			}
		}
	}
	// transformed interpolation according to the interpolation function
	pg_FirstFrameInScene = false;
}

///////////////////////////////////////////////////////////////////////////////////////
// CALLBACK EXECUTION ON UPDATED VARIABLES
void pg_run_callBacks(void) {
	// runs the callBack on the updated variables which have one
	for (int indP = 0; indP < _MaxInterpVarIDs; indP++) {
		if (ScenarioVarConfigurations[indP][pg_current_configuration_rank]) {
			pg_run_a_callBack(indP);
		}
	}
}


///////////////////////////////////////////////////////////////////////////////////////
// SCENARIO UPDATE: SELECTION OF THE CURRENT SCENE AND VARIABLE UPDATE

void pg_update_scenario(void) {
	// printf("VideoPb Update scenario \n");

#if defined(TVW)
	pg_update_visual_and_text_chapters(false);
#endif
	// the current scene is not the interpolation scene between two scenes
	if (pg_CurrentScene) {
		if (pg_CurrentScene != &pg_InterpolationScene) {
			double elapsed_time_from_start = pg_CurrentClockTime - InitialScenarioTime;

			// scans all scenes to find the current one and applies the corresponding interpolations
			for (int ind_scene = 0; ind_scene < pg_NbScenes[pg_current_configuration_rank]; ind_scene++) {
				 //printf( "time %.2f beg %.2f end %.2f\n" , elapsed_time_from_start ,  pg_Scenario[pg_current_configuration_rank][ind_scene].scene_initial_time ,  pg_Scenario[pg_current_configuration_rank][ind_scene].scene_final_time );
				// current scene found
				if ((elapsed_time_from_start >= pg_Scenario[pg_current_configuration_rank][ind_scene].scene_initial_time
					&& elapsed_time_from_start < pg_Scenario[pg_current_configuration_rank][ind_scene].scene_final_time)
					|| (pg_CurrentSceneIndex == pg_NbScenes[pg_current_configuration_rank] - 1 && ind_scene == pg_NbScenes[pg_current_configuration_rank] - 1
						&& elapsed_time_from_start > pg_Scenario[pg_current_configuration_rank][pg_NbScenes[pg_current_configuration_rank] - 1].scene_final_time)) {
					// loop at the end of the scenario
					if (pg_CurrentSceneIndex == pg_NbScenes[pg_current_configuration_rank] - 1 && ind_scene == pg_NbScenes[pg_current_configuration_rank] - 1
						&& elapsed_time_from_start > pg_Scenario[pg_current_configuration_rank][pg_NbScenes[pg_current_configuration_rank] - 1].scene_final_time) {
						ind_scene = 0;
					}
					// the current scene is finished 
					if (ind_scene != pg_CurrentSceneIndex) {
						// a new scene is launched only if pg_CurrentScene->scene_change_when_ends
						if (pg_CurrentScene->scene_change_when_ends) {
							StartNewScene(ind_scene, 0);
							elapsed_time_from_start = pg_CurrentClockTime - InitialScenarioTime;
						}
						// otherwise the current scene is prolonged, no interpolation takes place 
						// the parameter values stay as they were 
						else {
							// for time display + colors when reaching the end of the scene
							remainingTimeInScene
								= pg_CurrentScene->scene_initial_time + pg_CurrentScene->scene_duration - elapsed_time_from_start;
							if (!pg_last_scene_update) {
								pg_last_scene_update = true;
							}
							return;
						}
					}

					// for time display + colors when reaching the end of the scene
					remainingTimeInScene
						= pg_Scenario[pg_current_configuration_rank][ind_scene].scene_initial_time + pg_Scenario[pg_current_configuration_rank][ind_scene].scene_duration - elapsed_time_from_start;
					//printf( "time %.2f remainingTimeInScene %.2f\n" , elapsed_time_from_start, remainingTimeInScene);

					pg_update_scene_variables(&pg_Scenario[pg_current_configuration_rank][ind_scene], elapsed_time_from_start);

					// fprintf(pg_csv_log_file, "frame %ld cursor size %d\n", pg_FrameNo, cursorSize);
					return;
				}
				// current scene found
			}
			// scans all scenes to find the current one and applies the corresponding interpolations
		}
		// the current scene is the interpolation scene
		else {
			// end of interpolation
			if (pg_CurrentClockTime > pg_CurrentScene->scene_final_time) {
				// starts the scene memorized for after the interpolation
				StartNewScene(pg_SceneIndexAfterInterpolation, 0);
				// for time display + colors when reaching the end of the scene
				double elapsed_time_from_start = pg_CurrentClockTime - InitialScenarioTime;
				remainingTimeInScene
					= pg_CurrentScene->scene_initial_time + pg_CurrentScene->scene_duration - elapsed_time_from_start;
				//printf( "time %.2f remainingTimeInScene %.2f\n" , elapsed_time_from_start , remainingTimeInScene);

				pg_update_scene_variables(pg_CurrentScene, elapsed_time_from_start);
			}
			// ongoing interpolation
			// elapsed time is counted from scene beginning
			else {
				// for time display + colors when reaching the end of the scene
				remainingTimeInScene
					= pg_CurrentScene->scene_initial_time + pg_CurrentScene->scene_duration - pg_CurrentClockTime;
				//printf( "remainingTimeInScene %.2f pg_CurrentClockTime %.2f\n" , remainingTimeInScene, pg_CurrentClockTime);

				pg_update_scene_variables(pg_CurrentScene, pg_CurrentClockTime);
			}
		}
	}
}


///////////////////////////////////////////////////////////////////////////////////
// KEYSTROKE BASED COMMANDS
///////////////////////////////////////////////////////////////////////////////////

void pg_process_key(int key) {
	pg_key_modifier = glutGetModifiers();

	// printf( "key (%d) mod %d\n" , key , mod );

	if (!(pg_key_modifier & GLUT_ACTIVE_ALT)) {
		// non special key that corresponds to a script
		pg_keyStrokeScripts(key);
		return;
	}

	switch (key) {

		/* ------------------------------- beat */
	case 'b':
		auto_beat = !auto_beat;
		lastBeatTime = pg_CurrentClockTime;
		break;

		/* ------------------------------- frame per second */
	case 'f':
		DisplayFramePerSecond = !DisplayFramePerSecond;
		printf("FPS display %d\n", DisplayFramePerSecond);
		break;

		/* ------------------------------- MIDI play */
	case 'm':
		// MIDI messages IN
#ifdef PG_MIDI
		MIDI_OUT_event.message = Pm_Message(0xB0, 1, 0); // B = 1011 (Control Change) 0 = channel 1 / 1 controller number / value 0 = off
		MIDI_OUT_event.timestamp = midi_io.get_currenttime();
		midi_io.write_event(&MIDI_OUT_event);
		printf("MIDI OUT event %d %d %d (time %d)\n", Pm_MessageStatus(MIDI_OUT_event.message), Pm_MessageData1(MIDI_OUT_event.message), Pm_MessageData2(MIDI_OUT_event.message), MIDI_OUT_event.timestamp);
#endif
		break;

	case 'M':
		// MIDI messages IN
#ifdef PG_MIDI
		MIDI_OUT_event.message = Pm_Message(0xB0, 1, 127); // B = 1011 (Control Change) 0 = channel 1 / 1 controller number / value 127 = on
		MIDI_OUT_event.timestamp = midi_io.get_currenttime();
		midi_io.write_event(&MIDI_OUT_event);
		printf("MIDI OUT event %d %d %d (time %d)\n", Pm_MessageStatus(MIDI_OUT_event.message), Pm_MessageData1(MIDI_OUT_event.message), Pm_MessageData2(MIDI_OUT_event.message), MIDI_OUT_event.timestamp);
#endif
		break;

#ifdef PG_WITH_PUREDATA
		/* ------------------------------- check connection to PD */
	case 'p':
		pg_send_message_udp((char*)"", (char*)"/PD_connected", (char*)"udp_PD_send");
		break;
#endif

		/* ------------------------------- snapshot */
	case 's':
		pg_draw_scene(_Jpg, false);
		break;
	case 'S':
		pg_draw_scene(_Svg, false);
		break;

#if defined(var_cameraCaptFreq)
		/* ------------------------------- current video background capture */
	case 'v':
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			reset_camera = true;
		}
		break;
#endif

	default:
		printf("Alt key %d is not active.\n", key);
		break;
	}
}

/*!
 * \brief special keys events (interactive mode)
 * \param key			the key pressed
 */
void pg_process_special_key( int key ) {
  // switch (key) {    
  // default:
  //   printf ("special key %d is not active.\n", key);
  //   break;
  // }   
}

#if defined(PG_WITH_JUCE) || defined(PG_WITH_PUREDATA)
void soundTrackvolume(float vol) {
#ifdef PG_WITH_PUREDATA
	sprintf(AuxString, "/soundtrack_onOff %.5f", vol);
	pg_send_message_udp((char*)"f", AuxString, (char*)"udp_PD_send");
	printf("Command: soundtrack: %s\n", AuxString);
#endif
#ifdef PG_WITH_JUCE
	if (vol > 0) {
		pg_send_message_udp((char*)"", (char*)"/JUCE_play_track", (char*)"udp_SoundJUCE_send");
	}
	else {
		pg_send_message_udp((char*)"", (char*)"/JUCE_stop_track", (char*)"udp_SoundJUCE_send");
	}
#endif
	sprintf(AuxString, "/soundtrack_onOff %d", soundTrack_on);
	pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/soundtrack_volume %.5f", vol);
	pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
}
void soundTrackonOff() {
#ifdef PG_WITH_PUREDATA
	sprintf(AuxString, "/soundtrack_onOff %d", soundTrack_on);
	pg_send_message_udp((char*)"i", AuxString, (char*)"udp_PD_send");
	printf("Command: soundtrack: %s\n", AuxString);
#endif
#ifdef PG_WITH_JUCE
	if (soundTrack_on) {
		pg_send_message_udp((char*)"", (char*)"/JUCE_play_track", (char*)"udp_SoundJUCE_send");
	}
	else {
		pg_send_message_udp((char*)"", (char*)"/JUCE_stop_track", (char*)"udp_SoundJUCE_send");
	}
#endif
	sprintf(AuxString, "/soundtrack_onOff %d", soundTrack_on);
	pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/soundtrack_volume %.5f", float(int(soundTrack_on)));
	pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
}

void PlayTrack(int indTrack, double timeFromStart) {
	if (nb_soundtracks[pg_current_configuration_rank] > 0) {
		bool new_track = (indTrack >= 0 && currentlyPlaying_trackNo != indTrack % nb_soundtracks[pg_current_configuration_rank]);
		//std::cout << "new track ind: " << indTrack << " currentlyPlaying_trackNo:" << currentlyPlaying_trackNo << " nb_soundtracks:" << nb_soundtracks << std::endl;

		if (new_track) {
			// std::cout << "cwd: " << cwd << std::endl;
			int previouslyPlayingSoundtrackNo = currentlyPlaying_trackNo;
			currentlyPlaying_trackNo = indTrack % nb_soundtracks[pg_current_configuration_rank];
			std::cout << "Playing soundtrack name: " << trackFileName[pg_current_configuration_rank][currentlyPlaying_trackNo] << std::endl;

			if (trackFileName[pg_current_configuration_rank][currentlyPlaying_trackNo].find(':') == std::string::npos) {
				sprintf(AuxString, "/soundtrack_fileName %s",
					(cwd + "/Data/" + project_name + "-data/soundtracks/" + trackFileName[pg_current_configuration_rank][currentlyPlaying_trackNo]).c_str());
			}
			else {
				sprintf(AuxString, "/soundtrack_fileName %s", trackFileName[pg_current_configuration_rank][currentlyPlaying_trackNo].c_str());
			}

#ifdef PG_WITH_PUREDATA
			pg_send_message_udp((char*)"s", AuxString, (char*)"udp_PD_send");
#endif

#if defined(PG_WITH_PORTAUDIO)
			if ((previouslyPlayingSoundtrackNo >= 0 && previouslyPlayingSoundtrackNo < nb_soundtracks[pg_current_configuration_rank])|| pa_sound_data.pa_is_streaming()) {
				printf("Closing stream (%s)\n", (char*)(trackFileName[pg_current_configuration_rank][previouslyPlayingSoundtrackNo]).c_str());
				pa_sound_data.pa_stopMyStream();
				pa_sound_data.pa_closeMyStream();
			}
			printf("Opening Wav file (%s)\n", (char*)(trackFileName[pg_current_configuration_rank][currentlyPlaying_trackNo]).c_str());
			/* Open the soundfile */
			soundfile_data.sound_file = sf_open((char*)(trackFileName[pg_current_configuration_rank][currentlyPlaying_trackNo]).c_str(),
				SFM_READ, &soundfile_data.sound_file_info);
			if (sf_error(soundfile_data.sound_file) != SF_ERR_NO_ERROR) {
				fprintf(stderr, "%s\n", sf_strerror(soundfile_data.sound_file));
				sprintf(ErrorStr, "Wav file not opened (%s)!", (char*)(trackFileName[pg_current_configuration_rank][currentlyPlaying_trackNo]).c_str()); ReportError(ErrorStr);
				return;
			}

			// opening stream
			int channelCount;
			int sampleRate;
			if (pa_sound_data.pa_openMyStream(Pa_GetDefaultOutputDevice(), &channelCount, &sampleRate)) {
				printf("portaudio stream opened %d ch at %d Hz\n", channelCount, sampleRate);
			}
			else {
				fprintf(stderr, "Error number: %d\n", paInit->result());
				fprintf(stderr, "Error message: %s\n", Pa_GetErrorText(paInit->result()));
				sprintf(ErrorStr, "Port audio stream not opened!"); ReportError(ErrorStr); throw 100;
			}

			// starting stream
			if (pa_sound_data.pa_startMyStream()) {
				printf("portaudio stream started\n");
			}
			else {
				fprintf(stderr, "Error number: %d\n", paInit->result());
				fprintf(stderr, "Error message: %s\n", Pa_GetErrorText(paInit->result()));
				sprintf(ErrorStr, "Port audio stream not started!"); ReportError(ErrorStr); throw 100;
			}

			pg_track_sound_onset = false;
			pg_track_sound_peak = false;
			currentTrackSoundPeakIndex = 0;
			currentTrackSoundOnsetIndex = 0;

			if (currentlyPlaying_trackNo >= 0 && int(trackSoundtrackPeaks[pg_current_configuration_rank].size()) > currentlyPlaying_trackNo) {
				nbTrackSoundPeakIndex[pg_current_configuration_rank] = trackSoundtrackPeaks[pg_current_configuration_rank][currentlyPlaying_trackNo].size();
			}
			else {
				nbTrackSoundPeakIndex[pg_current_configuration_rank] = 0;
			}
			if (currentlyPlaying_trackNo >= 0 && int(trackSoundtrackOnsets[pg_current_configuration_rank].size()) > currentlyPlaying_trackNo) {
				nbTrackSoundOnsetIndex[pg_current_configuration_rank] = trackSoundtrackOnsets[pg_current_configuration_rank][currentlyPlaying_trackNo].size();
			}
			else {
				nbTrackSoundOnsetIndex[pg_current_configuration_rank] = 0;
			}
			printf("nbTrackSoundPeakIndex %d nbTrackSoundOnsetIndex %d\n", nbTrackSoundPeakIndex[pg_current_configuration_rank], nbTrackSoundOnsetIndex[pg_current_configuration_rank]);
#endif

		}

#if defined(PG_WITH_PORTAUDIO)
		// start position seeking
		if (timeFromStart > 0) {
			if (sf_seek(soundfile_data.sound_file, sf_count_t(timeFromStart * soundfile_data.sound_file_info.samplerate), SEEK_SET) == -1) {
				sprintf(ErrorStr, "Seek error in file (%s)!", (char*)(trackFileName[pg_current_configuration_rank][currentlyPlaying_trackNo]).c_str()); ReportError(ErrorStr);
			}
			soundfile_data.sound_file_StartReadingTime = RealTime() - trackSoundtrackOnsetsAndPeasksOffset[pg_current_configuration_rank][currentlyPlaying_trackNo] - timeFromStart;
		}
		else {
			soundfile_data.sound_file_StartReadingTime = RealTime() - trackSoundtrackOnsetsAndPeasksOffset[pg_current_configuration_rank][currentlyPlaying_trackNo];
		}
#endif

#ifdef PG_WITH_JUCE
		sprintf(AuxString, "/JUCE_open_track \"%s\"",
			(cwd + "/Data/" + project_name + "-data/soundtracks/" + trackFileName[currentlyPlaying_trackNo]).c_str());
		pg_send_message_udp((char *)"s", AuxString, (char *)"udp_SoundJUCE_send");
		pg_send_message_udp((char *)"", (char *)"/JUCE_play_track", (char *)"udp_SoundJUCE_send");
#endif

		//sprintf(AuxString, "/soundtrack_shortName %s", trackShortName[currentlyPlaying_trackNo].c_str());
		//pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/track_shortName %s", trackShortName[pg_current_configuration_rank][currentlyPlaying_trackNo].c_str());
		pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");

		//printf("soundtrack #%d %s\n", currentlyPlaying_trackNo, trackFileName[currentlyPlaying_trackNo].c_str());
		//BrokenInterpolationVar[_playing_soundtrackNo][pg_current_configuration_rank] = true;
		currentlyPlaying_trackNo = indTrack;
	}
}

void StopTrack(void) {
#ifdef PG_WITH_PUREDATA
	sprintf(AuxString, "/soundtrack_fileName %s", (char *)"");
	pg_send_message_udp((char *)"s", AuxString, (char *)"udp_PD_send");
#endif

#if defined(PG_WITH_PORTAUDIO)
	if (pa_sound_data.pa_is_streaming()) {
		pa_sound_data.pa_closeMyStream();
	}
#endif

#ifdef PG_WITH_JUCE
	sprintf(AuxString, "/JUCE_open_track \"%s\"", (char *)"void");
	pg_send_message_udp((char *)"s", AuxString, (char *)"udp_SoundJUCE_send");
	pg_send_message_udp((char *)"", (char *)"/JUCE_play_track", (char *)"udp_SoundJUCE_send");
#endif

	//sprintf(AuxString, "/soundtrack_shortName %s", trackShortName[currentlyPlaying_trackNo].c_str());
	//pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
	sprintf(AuxString, "/track_shortName %s", "void");
	pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");

	//printf("No soundtrack\n");
	//BrokenInterpolationVar[_playing_soundtrackNo][pg_current_configuration_rank] = true;
	currentlyPlaying_trackNo = -1;
}
#endif

void pg_launch_performance(int ind_scene) {
	// sprintf(AuxString, "/message launching"); pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
	
	// cleaning up
	//isClearCA = 1; // clean CA layer
	//isClearAllLayers = 1; // clears bg layer
	//isClearEcho = 1; // clears echo buffer

	pg_LaunchFrameNo = pg_FrameNo;

	// restarts scenarios
	restoreInitialTimesAndDurations();
	InitialScenarioTime = pg_CurrentClockTime - pg_Scenario[pg_current_configuration_rank][0].scene_initial_time;
	AbsoluteInitialScenarioTime = pg_CurrentClockTime - pg_Scenario[pg_current_configuration_rank][0].scene_initial_time;
#if !defined(LIGHT)
	sprintf(AuxString, "/setupNo 0"); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
	sprintf(AuxString, "/setup %s", pg_Scenario[pg_current_configuration_rank][0].scene_IDs.c_str()); pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
	sprintf(AuxString, "/setup_1 %s", pg_Scenario[pg_current_configuration_rank][0].scene_Msg1.c_str()); pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
	sprintf(AuxString, "/setup_2 %s", pg_Scenario[pg_current_configuration_rank][0].scene_Msg2.c_str()); pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
	if (pg_NbScenes[pg_current_configuration_rank] > 1) {
		sprintf(AuxString, "/setup_next next:_%s", pg_Scenario[pg_current_configuration_rank][1].scene_IDs.c_str()); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
	}
	else {
		sprintf(AuxString, "/setup_next next:_%s", (char*)"END"); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
	}
#endif
	// reinitialization of the interpolation control variables at the beginning of a new scene
	for (int indP = 0; indP < ScenarioVarNb[pg_current_configuration_rank]; indP++) {
		int indVar = ConfigScenarioVarRank[indP][pg_current_configuration_rank];
		if (ScenarioVarConfigurations[indVar][pg_current_configuration_rank]) {
			BrokenInterpolationVar[indVar] = false;
			StepwiseInterpolationEffective[indVar] = false;
		}
	}

	// removes snaptshots before launching
	// remove_files_in_dir(&snapshots_dir_path_name); // removes snapshots before pg_launch_performance

	// lights up the LED
	//pg_send_message_udp((char *)"f", (char *)"/launch 1", (char *)"udp_TouchOSC_send");

#if defined(var_GenerativeNights_planes)
	if (ScenarioVarConfigurations[_GenerativeNights_planes][pg_current_configuration_rank]) {
		initCA = 1.2f;
		printf("initCA %.2f\n", initCA);
	}
#endif

	StartNewScene(ind_scene, 0);
}

void setup(int scene_ind) {
	if (scene_ind >= 0 && pg_CurrentSceneIndex < 0) {
		pg_launch_performance(scene_ind % pg_NbScenes[pg_current_configuration_rank]);
	}
	else {
		StartNewScene(scene_ind % pg_NbScenes[pg_current_configuration_rank], 0);
	}
}

void setup_plus(int incay) {
	// only one setup change per second to avoid repetition
	//printf("pg_CurrentSceneIndex %d\n", pg_CurrentSceneIndex);
	if (pg_CurrentClockTime - LastSetupChangeClockTime > 0.3f) {
		LastSetupChangeClockTime = pg_CurrentClockTime;
	}
	else {
		return;
	}

	if (pg_CurrentSceneIndex < 0) {
		//printf("pg_launch_performance\n");
		pg_launch_performance(0);
	}
	else {
		if (incay + pg_CurrentSceneIndex < pg_NbScenes[pg_current_configuration_rank]) {
			//printf("new scene %d\n", incay + pg_CurrentSceneIndex);
			StartNewScene(incay + pg_CurrentSceneIndex, 0);
		}
		else if (pg_CurrentSceneIndex != pg_NbScenes[pg_current_configuration_rank] - 1) {
			//printf("last scene %d\n", pg_NbScenes[pg_current_configuration_rank] - 1);
			StartNewScene(pg_NbScenes[pg_current_configuration_rank] - 1, 0);
		}
	}
}

void setup_minus(int decay) {
	int new_scene = ((pg_CurrentSceneIndex - decay + pg_NbScenes[pg_current_configuration_rank]) % pg_NbScenes[pg_current_configuration_rank]);
	StartNewScene(new_scene, 0);
}

void pg_keyStrokeScripts(int key) {
	switch (key) {

		// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
		// +++++++++++++++++ PEDALS ++++++++++++++++++++++++++++++++ 
		// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
		// ====================================== 
	case 'a':
		setup_plus(1);
		break;
#if defined(var_path_record_1)
	case 'b':
		pg_NextRecordReplayPath();
		break;
#endif
		// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
		// +++++++++++++++++ SET-UP ++++++++++++++++++++++++++++++++ 
		// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
		// ====================================== 
		// advances to next scene without respect for the global timing
	case'S':
		setup_plus(1);
		break;

		// advances to next scene and keeps the global timing
	case's': {
		restoreInitialTimesAndDurations();
		double deltaTime = pg_Scenario[pg_current_configuration_rank][1 + pg_CurrentSceneIndex].scene_initial_time - (pg_CurrentClockTime - InitialScenarioTime);
		// if the scene has not yet begun
		if (deltaTime > 0) {
			int new_scene = ((1 + pg_CurrentSceneIndex) % pg_NbScenes[pg_current_configuration_rank]);
			// we place the beginning of the current scene at this time
			pg_Scenario[pg_current_configuration_rank][new_scene].scene_initial_time -= deltaTime;
			if (new_scene > 0) {
				pg_Scenario[pg_current_configuration_rank][new_scene - 1].scene_final_time -= deltaTime;
				pg_Scenario[pg_current_configuration_rank][new_scene - 1].scene_duration -= deltaTime;
			}
			pg_Scenario[pg_current_configuration_rank][new_scene].scene_duration += deltaTime;
			// unuseful because is already made through pg_Scenario[pg_current_configuration_rank][new_scene].scene_initial_time -= deltaTime;
			//InitialScenarioTime = pg_CurrentClockTime - pg_Scenario[pg_current_configuration_rank][new_scene].scene_initial_time;
			StartNewScene(new_scene, 0);
		}
	}
		   break;

		   // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
		   // +++++++++++++++++ TEST UDP ++++++++++++++++++++++++++++++ 
		   // +++++++++++++++++   keystroke (T)  ++++++++++++++++++++++ 
		   // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case'T':
		pg_writeMessageOnScreen("******");
		pg_IPClient* client;
		// message to supercollider
		if ((client = pg_UDP_client((char*)"udp_SC"))) {
			pg_send_message_udp((char*)"f", (char*)"/testUDP 0", client);
		}
		// message to touch OSC
		sprintf(AuxString, "/setup_1 TEST_UDP"); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
		//sprintf(AuxString, "/return_message returnUPD_%f", pg_CurrentClockTime); pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
		break;

		// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
		// +++++++++++++++++ LAUNCH PERFORMANCE ++++++++++++++++++++ 
		// +++++++++++++++++   keystroke (t)  ++++++++++++++++++++++ 
		// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case't':
		pg_launch_performance(0);
		break;
		// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
		// +++++++++++++++++ LAUNCH SCENE ++++++++++++++++++++++++++ 
		// +++++++++++++++++   keystroke (1--9 and 0)  +++++++++++++ 
		// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9': {
			int ind_scene = int(key - '1') % pg_NbScenes[pg_current_configuration_rank];
			if (pg_CurrentSceneIndex < 0) {
				pg_launch_performance(ind_scene);
			}
			else {
				StartNewScene(ind_scene, 0);
			}
		}
		break;
	}
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
// +++++++++++++++++ FLASHES +++++++++++++++++++++++++++++++ 
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
// ======================================== 
// flash triggering according to beat & frequency, weight, and on/off values 
// ======================================== 
bool flash_beat_generation(int flash_frequency) {
	// flashes are synchronized on beats according to their frequency
	if (flash_frequency > 0
		&& flash_frequency <= PG_LOOP_SIZE 
		&& (pg_BeatNo % (PG_LOOP_SIZE / flash_frequency)) == 0) {
		return true;
	}
	return false;
}
bool flash_continuous_generation(int flash_frequency) {
	// flashes are made every frame if frequency is PG_LOOP_SIZE + 1
	//printf("peak %d\n", int(pg_movie_sound_peak));
	if (flash_frequency == (PG_LOOP_SIZE + 1)) {
		return true;
	}
	// flashes are made every video soundtrack peak (sound volume 1) if frequency is PG_LOOP_SIZE + 2
	else if (flash_frequency == (PG_LOOP_SIZE + 2) && (pg_movie_sound_peak || pg_track_sound_peak)) {
		//printf("peak %.5f left %d\n", pg_CurrentClockTime - pg_movie_status.get_initialTime(), pg_movie_status.get_nbFramesLeft());
		return true;
	}
	// flashes are made every video soundtrack onset detected by aubio library if frequency is PG_LOOP_SIZE + 3
	else if (flash_frequency == (PG_LOOP_SIZE + 3) && (pg_movie_sound_onset || pg_track_sound_onset)) {
		//printf("onset %.5f left %d\n", pg_CurrentClockTime - pg_movie_status.get_initialTime(), pg_movie_status.get_nbFramesLeft());
		return true;
	}
	return false;
}

void pg_flash_control(bool (*control_function)(int)) {
	if ((*control_function)(flashPixel_freq)) {
		flashPixel = flashPixel_duration;
	}

	if ((*control_function)(flashPixel_freq)) {
		flashPixel = flashPixel_duration;
	}

#if defined(var_flashParticleInit_freq) && defined(var_part_initialization) && defined(var_part_timeToTargt)
	if (ScenarioVarConfigurations[_flashParticleInit_freq][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_part_timeToTargt][pg_current_configuration_rank]) {
		if ((*control_function)(flashParticleInit_freq)) {
			part_initialization = unsigned int(floor(rand_0_1 * pg_particle_initial_pos_speed_texID[pg_current_configuration_rank].size())) % pg_particle_initial_pos_speed_texID[pg_current_configuration_rank].size();
			pg_targetFrameNo = pg_FrameNo + int(part_timeToTargt);
		}
	}
#endif

#if defined(var_nb_CATypes)
	if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]) {
#if defined(var_flashTrkCA_freq_0)
		if (ScenarioVarConfigurations[_flashTrkCA_freq_0][pg_current_configuration_rank]) {
			if ((*control_function)(flashTrkCA_freq_0)) {
				flashTrkCA_weights[0] = 1.0;
				flashTrkCA_weights_duration[0] = PG_FBO_PINGPONG_SIZE - 1;
				// printf( "flashTrkCA 0 (%.2f)\n" , flashTrkCA_weights[0] );
			}
		}
#endif
#if defined(var_flashTrkCA_freq_1)
		if (ScenarioVarConfigurations[_flashTrkCA_freq_1][pg_current_configuration_rank]) {
			if ((*control_function)(flashTrkCA_freq_1)) {
				flashTrkCA_weights[1] = 1.0;
				flashTrkCA_weights_duration[1] = PG_FBO_PINGPONG_SIZE - 1;
				// printf( "flashTrkCA 1 (%.2f)\n" , flashTrkCA_weights[1] );
			}
		}
#endif
#if defined(var_flashTrkCA_freq_2)
		if (ScenarioVarConfigurations[_flashTrkCA_freq_2][pg_current_configuration_rank]) {
			if ((*control_function)(flashTrkCA_freq_2)) {
				flashTrkCA_weights[2] = 1.0;
				flashTrkCA_weights_duration[2] = PG_FBO_PINGPONG_SIZE - 1;
				// printf( "flashTrkCA 2 (%.2f)\n" , flashTrkCA_weights[2] );
			}
		}
#endif
#if defined(var_flashTrkCA_freq_3)
		if (ScenarioVarConfigurations[_flashTrkCA_freq_3][pg_current_configuration_rank]) {
			if ((*control_function)(flashTrkCA_freq_3)) {
				flashTrkCA_weights[3] = 1.0;
				flashTrkCA_weights_duration[3] = PG_FBO_PINGPONG_SIZE - 1;
				// printf( "flashTrkCA 3 (%.2f)\n" , flashTrkCA_weights[3] );
			}
		}
#endif
	}
#endif

#if defined(var_flashTrkPart_freq_0) 
	if (ScenarioVarConfigurations[_flashTrkPart_freq_0][pg_current_configuration_rank]) {
		if ((*control_function)(flashTrkPart_freq_0)) {
			flashTrkPart_weights[0] = 1.0;
			flashTrkPart_weights_duration[0] = PG_FBO_PINGPONG_SIZE - 1;
			// printf( "flashTrkPart 0 (%.2f)\n" , flashTrkPart_weights[0] );
		}
	}
#endif
#if defined(var_flashTrkPart_freq_1)
	if (ScenarioVarConfigurations[_flashTrkPart_freq_1][pg_current_configuration_rank]) {
		if ((*control_function)(flashTrkPart_freq_1)) {
			flashTrkPart_weights[1] = 1.0;
			flashTrkPart_weights_duration[1] = PG_FBO_PINGPONG_SIZE - 1;
			// printf( "flashTrkPart 1 (%.2f)\n" , flashTrkPart_weights[1] );
		}
	}
#endif
#if defined(var_flashTrkPart_freq_2)
	if (ScenarioVarConfigurations[_flashTrkPart_freq_2][pg_current_configuration_rank]) {
		if ((*control_function)(flashTrkPart_freq_2)) {
			flashTrkPart_weights[2] = 1.0;
			flashTrkPart_weights_duration[2] = PG_FBO_PINGPONG_SIZE - 1;
			// printf( "flashTrkPart 2 (%.2f)\n" , flashTrkPart_weights[2] );
		}
	}
#endif
#if defined(var_flashTrkPart_freq_3)
	if (ScenarioVarConfigurations[_flashTrkPart_freq_3][pg_current_configuration_rank]) {
		if ((*control_function)(flashTrkPart_freq_3)) {
			flashTrkPart_weights[3] = 1.0;
			flashTrkPart_weights_duration[3] = PG_FBO_PINGPONG_SIZE - 1;
			// printf( "flashTrkPart 3 (%.2f)\n" , flashTrkPart_weights[3] );
		}
	}
#endif

#if defined(var_flashTrkBG_freq_1)
	if (ScenarioVarConfigurations[_flashTrkBG_freq_1][pg_current_configuration_rank]) {
		if ((*control_function)(flashTrkBG_freq_1)) {
			// should only be flashed every second frame because of the way the pixels are spreaded
			// otherwise the pixels are not emitted
			if (control_function != flash_continuous_generation || pg_FrameNo % 2 == 0) {
				flashTrkBG_weights[1] = 1.0;
				flashTrkBG_weights_duration[1] = PG_FBO_PINGPONG_SIZE - 1;
				//printf( "flashTrkBG_freq_1\n" );
			}
		}
	}
#endif
#if defined(var_flashTrkBG_freq_2)
	if (ScenarioVarConfigurations[_flashTrkBG_freq_2][pg_current_configuration_rank]) {
		if ((*control_function)(flashTrkBG_freq_2)) {
			// should only be flashed every second frame because of the way the pixels are spreaded
			// otherwise the pixels are not emitted
			if (control_function != flash_continuous_generation || pg_FrameNo % 2 == 0) {
				flashTrkBG_weights[2] = 1.0;
				flashTrkBG_weights_duration[2] = PG_FBO_PINGPONG_SIZE - 1;
				// printf( "flashTrkBG (%d)\n" , flashTrkBG );
			}
		}
	}
#endif
#if defined(var_flashTrkBG_freq_3)
	if (ScenarioVarConfigurations[_flashTrkBG_freq_3][pg_current_configuration_rank]) {
		if ((*control_function)(flashTrkBG_freq_3)) {
			// should only be flashed every second frame because of the way the pixels are spreaded
			// otherwise the pixels are not emitted
			if (control_function != flash_continuous_generation || pg_FrameNo % 2 == 0) {
				flashTrkBG_weights[3] = 1.0;
				flashTrkBG_weights_duration[3] = PG_FBO_PINGPONG_SIZE - 1;
				// printf( "flashTrkBG (%d)\n" , flashTrkBG );
			}
		}
	}
#endif

#if defined(var_nb_CATypes)
	if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]) {
		if ((*control_function)(flashCABG_freq)) {
			flashCABG_weight = 1.0;
			flashCABG_weight_duration = PG_FBO_PINGPONG_SIZE - 1;
			// printf( "flashCABG_freq (%d)\n" , flashCABG_freq );
		}
	}
#endif

#if defined(var_flashCAPart_freq)
	if (ScenarioVarConfigurations[_flashCAPart_freq][pg_current_configuration_rank]) {
		if ((*control_function)(flashCAPart_freq)) {
			flashCAPart_weight = 1.0;
			flashCAPart_weight_duration = PG_FBO_PINGPONG_SIZE - 1;
			// printf( "flashCAPart_freq (%d)\n" , flashCAPart_freq );
		}
	}
#endif
#if defined(var_flashPartBG_freq)
	if (ScenarioVarConfigurations[_flashPartBG_freq][pg_current_configuration_rank]) {
		if ((*control_function)(flashPartBG_freq)) {
			flashPartBG_weight = 1.0;
			flashPartBG_weight_duration = PG_FBO_PINGPONG_SIZE - 1;
			// printf( "flashPartBG_freq (%d)\n" , flashPartBG_freq );
		}
	}
#endif
#if defined(var_flashPartCA_freq) 
	if (ScenarioVarConfigurations[_flashPartCA_freq][pg_current_configuration_rank]) {
		if ((*control_function)(flashPartCA_freq)) {
			flashPartCA_weight = 1.0;
			flashPartCA_weight_duration = PG_FBO_PINGPONG_SIZE - 1;
			// printf( "flashPartCA_freq (%d)\n" , flashPartCA_freq );
		}
	}
#endif

#if defined(var_Contact_flashchangeClipLeft_freq) && defined(var_Contact_flashchangeClip2Left_freq) \
			&& defined(var_Contact_flashchangeClipRight_freq) && defined(var_Contact_flashchangeClip2Right_freq) \
			&& defined(var_Contact_flashchangeScreenLayout_freq) && defined(var_Contact_flashchange_mesh_palette_freq) && defined(var_Contact_flashchange_mesh_anime_freq) \
			&& defined(var_Contact_flashchangeRightHandPose_freq) && defined(var_Contact_flashchangeLeftHandPose_freq)
	//std::vector<int> ContAct_clip_ranges_min;
	//std::vector<int> ContAct_clip_ranges_max;
	int clip_no_low = 0;
	int clip_no_high = pg_nbClips - 1;

	if (ScenarioVarConfigurations[_Contact_flashchangeClipLeft_freq][pg_current_configuration_rank]) {

#if defined(var_Contact_clip_in_range)
		if (ScenarioVarConfigurations[_Contact_clip_in_range][pg_current_configuration_rank]) {
			if (ContAct_clip_ranges_min.size() > 0 && ContAct_clip_ranges_min.size() == ContAct_clip_ranges_max.size()) {
				// CLIP IS SELECTED IN A RANGE (BEGIN AND END OF RANGE ARE INCLUDED)
				int range_selected = int(rand_0_1 * ContAct_clip_ranges_min.size()) % ContAct_clip_ranges_min.size();
				int clip_no_low = ContAct_clip_ranges_min[range_selected];
				int clip_no_high = ContAct_clip_ranges_max[range_selected];
				int clip_no = clip_no_low + int(rand_0_1 * (clip_no_high - clip_no_low + 1)) % (clip_no_high - clip_no_low + 1);
				clip_no = max(min(clip_no, clip_no_high), clip_no_low) % pg_nbClips;
			}
		}
#endif

		if ((*control_function)(Contact_flashchangeClipLeft_freq)) {
			int clipSide = _clipLeft;
			int clipRank = 0;
			int clip_no = clip_no_low + int(rand_0_1 * (clip_no_high - clip_no_low + 1)) % (clip_no_high - clip_no_low + 1);
			clip_no = max(min(clip_no, clip_no_high), clip_no_low) % pg_nbClips;
			if (clipSide < _clipLR && clipSide >= 0 && clipRank < PG_NB_PARALLEL_CLIPS && clipRank >= 0 && pg_nbClips > 0 && clip_no >= 0) {
				clip_no = clip_no % pg_nbClips;
				pg_play_clip_no(clipRank, clipSide, clip_no);
			}
		}
		if ((*control_function)(Contact_flashchangeClip2Left_freq)) {
			int clipSide = _clipLeft;
			int clipRank = 1;
			int clip_no_low = 0;
			int clip_no_high = 26;
			int clip_no = clip_no_low + int(rand_0_1 * (clip_no_high - clip_no_low + 1)) % (clip_no_high - clip_no_low + 1);
			clip_no = max(min(clip_no, clip_no_high), clip_no_low) % pg_nbClips;
			if (clipSide < _clipLR && clipSide >= 0 && clipRank < PG_NB_PARALLEL_CLIPS && clipRank >= 0 && pg_nbClips > 0 && clip_no >= 0) {
				clip_no = clip_no % pg_nbClips;
				pg_play_clip_no(clipRank, clipSide, clip_no);
			}
		}
		if ((*control_function)(Contact_flashchangeClipRight_freq)) {
			int clipSide = _clipRight;
			int clipRank = 0;
			int clip_no_low = 0;
			int clip_no_high = 26;
			int clip_no = clip_no_low + int(rand_0_1 * (clip_no_high - clip_no_low + 1)) % (clip_no_high - clip_no_low + 1);
			clip_no = max(min(clip_no, clip_no_high), clip_no_low) % pg_nbClips;
			if (clipSide < _clipLR && clipSide >= 0 && clipRank < PG_NB_PARALLEL_CLIPS && clipRank >= 0 && pg_nbClips > 0 && clip_no >= 0) {
				clip_no = clip_no % pg_nbClips;
				pg_play_clip_no(clipRank, clipSide, clip_no);
			}
		}
		if ((*control_function)(Contact_flashchangeClip2Right_freq)) {
			int clipSide = _clipRight;
			int clipRank = 1;
			int clip_no_low = 0;
			int clip_no_high = 26;
			int clip_no = clip_no_low + int(rand_0_1 * (clip_no_high - clip_no_low + 1)) % (clip_no_high - clip_no_low + 1);
			clip_no = max(min(clip_no, clip_no_high), clip_no_low) % pg_nbClips;
			if (clipSide < _clipLR && clipSide >= 0 && clipRank < PG_NB_PARALLEL_CLIPS && clipRank >= 0 && pg_nbClips > 0 && clip_no >= 0) {
				clip_no = clip_no % pg_nbClips;
				pg_play_clip_no(clipRank, clipSide, clip_no);
			}
		}
		if ((*control_function)(Contact_flashchangeScreenLayout_freq)) {
			// screen layout is between O and 5
			// O: Left / 1: RIght
			// 2: L+R full size / 3: L+R half size side by side
			// 4: 4 screens / 5: L+R half size on top of each other
			int layout = int(rand_0_1 * 6) % 6;
			(*((int*)ScenarioVarPointers[_ContAct_screenLayout])) = layout;
			ContAct_screenLayout = layout;
		}
		if ((*control_function)(Contact_flashchange_mesh_palette_freq)) {
			int level = int(rand_0_1 * 9) % 9;
			(*((int*)ScenarioVarPointers[_Contact_mesh_palette])) = level;
			Contact_mesh_palette = level;
		}
		if ((*control_function)(Contact_flashchange_mesh_anime_freq)) {
			int anime = int(rand_0_1 * (_lastMesh_Anime + 1)) % (_lastMesh_Anime + 1);
			(*((int*)ScenarioVarPointers[_Contact_mesh_anime])) = anime;
			Contact_mesh_anime = anime;
		}
		if ((*control_function)(Contact_flashchange_mesh_motion_freq)) {
			int motion = int(rand_0_1 * (_lastMesh_Motion + 1)) % (_lastMesh_Motion + 1);
			(*((int*)ScenarioVarPointers[_Contact_mesh_motion])) = motion;
			Contact_mesh_motion = motion;
		}
		bool fixedLeftPose = false;
		bool fixedRightPose = false;
		if ((*control_function)(Contact_flashchangeRightHandPose_freq)) {
			fixedRightPose = true;
		}
		if ((*control_function)(Contact_flashchangeLeftHandPose_freq)) {
			fixedLeftPose = true;
		}
		if (fixedRightPose || fixedLeftPose) {
			int chosen_mesh_LibraryPose = -1;
			// bianry animation between two indentical poses
			(*((int*)ScenarioVarPointers[_Contact_mesh_anime])) = 1;
			Contact_mesh_anime = 1;
			// two poses are memorized: twice the randomly selected pose;
			for (int indMeshFile = 0; indMeshFile < min(2, pg_nb_Mesh_files); indMeshFile++) {
				if ((indMeshFile == 0 && fixedLeftPose) || (indMeshFile == 1 && fixedRightPose)) {
					if (chosen_mesh_LibraryPose == -1) {
						chosen_mesh_LibraryPose = int(rand_0_1 * pg_nb_LibraryPoses[indMeshFile]) % pg_nb_LibraryPoses[indMeshFile];
					}
					pg_nb_AnimationPoses[indMeshFile] = min(2, PG_MAX_ANIMATION_POSES);
					copyLibraryPoseToAnimationPose(indMeshFile, chosen_mesh_LibraryPose, 0);
					copyLibraryPoseToAnimationPose(indMeshFile, chosen_mesh_LibraryPose, 1);
					//printf("ind Mesh %d chosen library pose %d \n", indMeshFile, chosen_mesh_LibraryPose);
					// all the weights are set to zero except the first pose weight
					for (int indPose = 0; indPose < pg_nb_AnimationPoses[indMeshFile]; indPose++) {
						pg_interpolation_weight_AnimationPose[indMeshFile][indPose] = 0.f;
					}
					pg_interpolation_weight_AnimationPose[indMeshFile][0] = 1.f;
				}
			}
		}
	}
#endif

#if defined(var_flashchange_invertAllLayers_freq)
	if (ScenarioVarConfigurations[_flashchange_invertAllLayers_freq][pg_current_configuration_rank]) {
		if ((*control_function)(flashchange_invertAllLayers_freq)) {
			invertAllLayers = !invertAllLayers;
			*((bool*)ScenarioVarPointers[_invertAllLayers]) = invertAllLayers;
		}
	}
#endif
	// random selection of an image in the list of available ones
#if defined(var_flashchange_diaporama_freq)
	if (ScenarioVarConfigurations[_flashchange_diaporama_freq][pg_current_configuration_rank]) {
		if ((*control_function)(flashchange_diaporama_freq)) {
			if (pg_nbCompressedImageDirs[pg_current_configuration_rank] > 0) {
				// goes to the first photo diaporama if it is not already selected and if there is one 
				if (photo_diaporama < 0 && nb_photo_albums > 0) {
					photo_diaporama = 0;
				}
				int cnt = 0;
				int new_dir = -1;
				do {
					new_dir = int(rand_0_1 * pg_nbCompressedImageDirs[pg_current_configuration_rank]) % pg_nbCompressedImageDirs[pg_current_configuration_rank];
				} while (cnt++ < 10 && (new_dir == pg_CurrentDiaporamaDir || new_dir == 0)); // 0 is Fatima hand
				pg_CurrentDiaporamaDir = new_dir;
				//printf("pg_CurrentDiaporamaDir %d\n", pg_CurrentDiaporamaDir);
				sprintf(AuxString, "/diaporama_shortName %03d", pg_CurrentDiaporamaDir);
				pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
				pg_launch_diaporama();
			}
		}
	}
#endif
	// random selection of an image in the list of available ones
	// first selects all the available ones in a random order
	// second selects randomly one among the possible ones
#if defined(var_Argenteuil_flashchange_diaporama_freq)
	if (ScenarioVarConfigurations[_Argenteuil_flashchange_diaporama_freq][pg_current_configuration_rank]) {
		if ((*control_function)(Argenteuil_flashchange_diaporama_freq)) {
			if (pg_nbCompressedImageDirs[pg_current_configuration_rank] > 0) {
				// first pass generates a permuation of the n images
				if (var_Argenteuil_flashchange_diaporama_pass == -1) {
					// 0 discarded because is Fatima hand
					for (int ind = 1; ind < pg_nbCompressedImageDirs[pg_current_configuration_rank]; ind++) {
						imageRanksPermutation.push_back(ind);
					}
					// using built-in random generator:
					std::random_device rd;
					std::mt19937 g(rd());
					std::shuffle(imageRanksPermutation.begin(), imageRanksPermutation.end(), g);
					var_Argenteuil_flashchange_diaporama_pass = 0;
				}
				// first n paths selects the next permutation
				if (var_Argenteuil_flashchange_diaporama_pass < pg_nbCompressedImageDirs[pg_current_configuration_rank] - 1) {
					pg_CurrentDiaporamaDir = imageRanksPermutation[var_Argenteuil_flashchange_diaporama_pass];
				}
				else {
					// goes to the first photo diaporama if it is not already selected and if there is one 
					if (photo_diaporama < 0 && nb_photo_albums > 0) {
						photo_diaporama = 0;
					}
					int cnt = 0;
					int new_dir = -1;
					do {
						new_dir = int(rand_0_1 * pg_nbCompressedImageDirs[pg_current_configuration_rank]) % pg_nbCompressedImageDirs[pg_current_configuration_rank];
					} while (cnt++ < 10 && (new_dir == pg_CurrentDiaporamaDir || new_dir == 0)); // 0 is Fatima hand
					pg_CurrentDiaporamaDir = new_dir;
				}

				//printf("pg_CurrentDiaporamaDir %d\n", pg_CurrentDiaporamaDir);
				sprintf(AuxString, "/diaporama_shortName %03d", pg_CurrentDiaporamaDir);
				pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
				pg_launch_diaporama();

				// next pass
				var_Argenteuil_flashchange_diaporama_pass++;
			}
		}
	}
#endif

#if defined(var_flashchange_BGcolor_freq)
	if (ScenarioVarConfigurations[_flashchange_BGcolor_freq][pg_current_configuration_rank]) {
		if ((*control_function)(flashchange_BGcolor_freq)) {
			float BG_hue = rand_0_1;
			HSVtoRGB(BG_hue, 1.f, 1.f, &BG_r, &BG_g, &BG_b);
			//printf("RGB %.2f -> %.2f %.2f %.2f \n", BG_hue, BG_r, BG_g, BG_b);
		}
		else if (flashchange_BGcolor_freq == 0) {
			BG_r = 0.f;
			BG_g = 0.f;
			BG_b = 0.f;
		}
	}
#endif

#if defined(var_flashchange_freeze_freq)
	if (ScenarioVarConfigurations[_flashchange_freeze_freq][pg_current_configuration_rank]) {
		if ((*control_function)(flashchange_freeze_freq)) {
			freeze = !freeze;
			*((bool*)ScenarioVarPointers[_freeze]) = freeze;
		}
	}
#endif


}

///////////////////////////////////////////////////////////////////////////////////
// beat reception and corresponding events triggering
#if defined(var_fingers)
void NumberOfInteractionFingers(int nb_fingers) {
	if (nb_fingers == 1) {
		sprintf(AuxString, "/multixy/5/visible 0"); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_MultiTouch_send");
		sprintf(AuxString, "/multixy/4/visible 0"); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_MultiTouch_send");
		sprintf(AuxString, "/multixy/3/visible 0"); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_MultiTouch_send");
		sprintf(AuxString, "/multixy/2/visible 0"); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_MultiTouch_send");
		//printf("fingers 2-5 invisible\n");
		CurrentMousePos_x[4] = PG_OUT_OF_SCREEN_CURSOR;
		CurrentMousePos_y[4] = PG_OUT_OF_SCREEN_CURSOR;
		CurrentMousePos_x[3] = PG_OUT_OF_SCREEN_CURSOR;
		CurrentMousePos_y[3] = PG_OUT_OF_SCREEN_CURSOR;
		CurrentMousePos_x[2] = PG_OUT_OF_SCREEN_CURSOR;
		CurrentMousePos_y[2] = PG_OUT_OF_SCREEN_CURSOR;
		CurrentMousePos_x[1] = PG_OUT_OF_SCREEN_CURSOR;
		CurrentMousePos_y[1] = PG_OUT_OF_SCREEN_CURSOR;
	}
	else if(nb_fingers == 5) {
		sprintf(AuxString, "/multixy/5/visible 1"); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_MultiTouch_send");
		sprintf(AuxString, "/multixy/4/visible 1"); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_MultiTouch_send");
		sprintf(AuxString, "/multixy/3/visible 1"); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_MultiTouch_send");
		sprintf(AuxString, "/multixy/2/visible 1"); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_MultiTouch_send");
		//printf("fingers 2-5 visible\n");
	}
}
#endif



///////////////////////////////////////////////////////////////////////////////////
// beat reception and corresponding events triggering
void ReceiveBeat(void) {
#ifdef PG_WITH_SOUND_LEVELS_GUI_FEEDBACK
	sprintf(AuxString, "/loop_beat %d", pg_BeatNo % PG_LOOP_SIZE); pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
#endif

#if defined(var_path_record_1) && defined(var_path_replay_trackNo_1)
	// loop start 
	if ((pg_BeatNo % PG_LOOP_SIZE) == 0) {
		for (int ind = 1; ind <= PG_NB_PATHS; ind++) {
			// source track recording is on -> source track start 
			if (synchr_start_recording_path[ind]) {
				pg_path_recording_onOff(ind);
				// sets to 0 the recording message since recording has started 
				synchr_start_recording_path[ind] = false;
			}


			// track reading is on -> track read start 
			if (synchr_start_path_replay_trackNo[ind] >= 0) {
				pg_path_replay_trackNo_onOff(ind, synchr_start_path_replay_trackNo[ind]);
				synchr_start_path_replay_trackNo[ind] = -1;
			}
		}
	}
#endif

#if defined(var_flashCameraTrkBeat)
	if (ScenarioVarConfigurations[_flashCameraTrkBeat][pg_current_configuration_rank]) {
		// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
		// camera flash
		if (is_flashCameraTrk
			&& ((pg_BeatNo % PG_LOOP_SIZE) == flashCameraTrkBeat || flashCameraTrkBeat == 9)
			) {
			is_flashCameraTrk = false;
			flashCameraTrk_weight = 1.0f;
			flashCameraTrk_threshold = std::min(std::max(0.0f, 1.0f - flashCameraTrk_decay * flashCameraTrkBright), 1.0f);
			//printf("flashCameraTrk_weight %.3f decay %.2f threshold %.3f\n", 
			//	flashCameraTrk_weight , flashCameraTrk_decay, flashPhotoTrk_threshold);
		}
	}
#endif

#if defined(var_flashPhotoTrkBeat) && defined(var_flashPhotoTrkBright) && defined(var_flashPhotoTrkLength) && defined(var_flashPhotoChangeBeat)
	if (ScenarioVarConfigurations[_flashPhotoTrkBeat][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_flashPhotoTrkBright][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_flashPhotoTrkLength][pg_current_configuration_rank]
		&& ScenarioVarConfigurations[_flashPhotoChangeBeat][pg_current_configuration_rank]) {
		// photo flash
		// weight is the current brightness of the lighting at each frame  until it reaches the threshold value and is then stopped 
		if (is_flashPhotoTrk
			&& ((pg_BeatNo % PG_LOOP_SIZE) == flashPhotoTrkBeat || flashPhotoTrkBeat == 0)) {
			is_flashPhotoTrk = false;
			pg_Make_flashPhoto();
		}
	}
#endif

	pg_flash_control(flash_beat_generation);

#if defined(var_flashPhotoChangeBeat)
	if (ScenarioVarConfigurations[_flashPhotoChangeBeat][pg_current_configuration_rank]) {
		// photo change flash
		if (flashPhotoChangeBeat > 0 && ((pg_BeatNo % PG_LOOP_SIZE) == flashPhotoChangeBeat)) {
			// goes to the first photo diaporama if it is not already selected and if there is one 
			if (photo_diaporama < 0 && nb_photo_albums[pg_current_configuration_rank] > 0) {
				photo_diaporama = 0;
			}

			// random selection and loopiing
			pg_CurrentDiaporamaDir = (pg_CurrentDiaporamaDir + int(rand_0_1 * pg_nbCompressedImageDirs[pg_current_configuration_rank])) % pg_nbCompressedImageDirs[pg_current_configuration_rank];
			//printf("pg_CurrentDiaporamaDir %d\n", pg_CurrentDiaporamaDir);

			sprintf(AuxString, "/diaporama_shortName %03d", pg_CurrentDiaporamaDir);
			pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			pg_launch_diaporama();
		}
	}
#endif

#if defined(TVW)
	// updates display messages according to text_swap_freq (4)
	// for a swap duration of message_swap_duration
	if (AbsoluteInitialScenarioTime != InitialRealTime - 1000000.f
		&& pg_CurrentDiaporamaDir != -1
		&& (pg_BeatNo % PG_LOOP_SIZE / 2 == 0)) {
		//printf("DisplayText1Front %d index 1/2 %d/%d dir %d dir size %d/%d\n", int(DisplayText1Front), IndDisplayText1, IndDisplayText2, pg_CurrentDiaporamaDir, DisplayTextFirstInChapter[pg_CurrentDiaporamaDir], DisplayTextFirstInChapter[pg_CurrentDiaporamaDir + 1]);
		if (DisplayText1Front) {
			IndDisplayText2 = (IndDisplayText2 + 2);
			if (IndDisplayText2 > DisplayTextFirstInChapter[pg_CurrentDiaporamaDir + 1]) {
				IndDisplayText2 -= (DisplayTextFirstInChapter[pg_CurrentDiaporamaDir + 1] - DisplayTextFirstInChapter[pg_CurrentDiaporamaDir]);
			}
			DisplayText1Front = false;
			LengthDisplayText2 = (float)pg_displayMessage_update(2);
			DisplayText1Alpha = 1.0f;
			DisplayText2Alpha = 0.0f;
		}
		else {
			IndDisplayText1 = (IndDisplayText1 + 2);
			if (IndDisplayText1 > DisplayTextFirstInChapter[pg_CurrentDiaporamaDir + 1]) {
				IndDisplayText1 -= (DisplayTextFirstInChapter[pg_CurrentDiaporamaDir + 1] - DisplayTextFirstInChapter[pg_CurrentDiaporamaDir]);
			}
			DisplayText1Front = true;
			LengthDisplayText1 = (float)pg_displayMessage_update(1);
			DisplayText1Alpha = 0.0f;
			DisplayText2Alpha = 1.0f;
		}
		DisplayTextSwapInitialTime = pg_CurrentClockTime;
	}

	// updates display images according to image_swap_freq
	// for a swap duration of image_swap_duration
	// printf("image_swap_freq %d pg_BeatNo %d \n",image_swap_freq,pg_BeatNo);
	if (AbsoluteInitialScenarioTime != InitialRealTime - 1000000.f
		&& pg_CurrentDiaporamaDir != -1
		// && image_swap_freq > 0
		&& ((pg_CurrentClockTime - LastImageSwap) >= photo_diaporama_plateau)) {
		int nextCompressedImage;
		if ((nextCompressedImage
			= nextFileIndexMemoryLoop(pg_CurrentDiaporamaDir,
				&pg_CurrentDiaporamaFile, true)) != NULL_ID) {
			if (pg_swap_image(nextCompressedImage)) {
			}
		}
	}
#endif

#if defined(var_Caverne_BackColor)
	if (ScenarioVarConfigurations[_Caverne_BackColor][pg_current_configuration_rank]) {
		if (Caverne_BackColor) {
			Caverne_BackColorRed = rand_0_1;
			Caverne_BackColorGreen = rand_0_1;
			Caverne_BackColorBlue = rand_0_1;
			// color saturation
			float max_col = max(Caverne_BackColorRed, max(Caverne_BackColorGreen, Caverne_BackColorBlue));
			Caverne_BackColorRed += 1.f - max_col;
			Caverne_BackColorGreen += 1.f - max_col;
			Caverne_BackColorBlue += 1.f - max_col;
			// color debrillance
			float brillance = min(Caverne_BackColorRed, min(Caverne_BackColorGreen, Caverne_BackColorBlue));
			if (Caverne_BackColorRed == brillance) {
				Caverne_BackColorRed = 0.f;
			}
			else if (Caverne_BackColorRed != 1.f) {
				Caverne_BackColorRed -= brillance / 2.f;
			}
			if (Caverne_BackColorGreen == brillance) {
				Caverne_BackColorGreen = 0.f;
			}
			else if (Caverne_BackColorGreen != 1.f) {
				Caverne_BackColorGreen -= brillance / 2.f;
			}
			if (Caverne_BackColorBlue == brillance) {
				Caverne_BackColorBlue = 0.f;
			}
			else if (Caverne_BackColorBlue != 1.f) {
				Caverne_BackColorBlue -= brillance / 2.f;
			}

			// background flash
			Caverne_BackColorFlash = true;
			Caverne_BackColorFlash_prec = false;
		}
		else {
			Caverne_BackColorRed = 0.f;
			Caverne_BackColorGreen = 0.f;
			Caverne_BackColorBlue = 0.f;
		}
	}
#endif

#ifdef PG_LIGHTS_DMX_IN_PG
	for (int ind = 0; ind < pg_nb_light_groups[pg_current_configuration_rank]; ind++) {
		if (pg_light_groups[pg_current_configuration_rank][ind].get_group_hasBeatCommand()) {
			pg_light_groups[pg_current_configuration_rank][ind].update_beatCommand();
		}
	}
#endif

#if defined(var_penStrokeAtBeat)
	if (ScenarioVarConfigurations[_penStrokeAtBeat][pg_current_configuration_rank]) {
		if (penStrokeAtBeat) {
			FourFrameStrokeNb = 5;
			FourFrameStroke_x = int(640 + 2 * rand_0_1);
			FourFrameStroke_y = int(180 + 2 * rand_0_1);
		}
	}
#endif

#if defined(var_Argenteuil_flash_move_track1_freq)
	if (ScenarioVarConfigurations[_Argenteuil_flash_move_track1_freq][pg_current_configuration_rank]) {
		if (Argenteuil_flash_move_track1_freq > 0 && ((pg_BeatNo % PG_LOOP_SIZE) == Argenteuil_flash_move_track1_freq)) {
			Argenteuil_track_x_transl_1 = 200.f + (rand_0_1 - 0.5f) * 300.f;
			Argenteuil_track_y_transl_1 = 100.f + (rand_0_1 - 0.5f) * 150.f;
		}
	}
#endif
}

///////////////////////////////////////////////////////////////////////////////////
// photo flash launching
#if defined(var_flashPhotoTrkBright)
void pg_Make_flashPhoto(void) {
	flashPhotoTrk_weight = 1.0f;
	flashPhotoTrk_nbFrames = 0;
	flashPhotoTrk_threshold = std::min(std::max(0.0f, 1.0f - flashPhotoTrk_decay * flashPhotoTrkBright), 1.0f);
	// invertAllLayers = !invertAllLayers;
	//photo_scale = rand_0_1 * 0.5f + 0.5f;
	//photo_offsetX = rand_0_1 * 1.5f - 0.5f;
	//photo_offsetY = rand_0_1 * 1.5f - 0.5f;
	// pg_CurrentDiaporamaDir = int(floor(9 + rand_0_1 * 14.9));
	pg_CurrentDiaporamaDir = int(floor(rand_0_1 * pg_nbCompressedImageDirs[pg_current_configuration_rank])) % pg_nbCompressedImageDirs[pg_current_configuration_rank];
	pg_launch_diaporama();
	//printf("flashPhotoTrk_weight %.3f decay %.2f threshold %.3f\n",
	//	flashPhotoTrk_weight, flashPhotoTrk_decay, flashPhotoTrk_threshold);
}
#endif

void pg_Make_flashCamera(void) {
	is_flashCameraTrk = true;
	flashCameraTrk_weight = 0.0f;
	// printf("start flash\n");
	//    break;
}

///////////////////////////////////////////////////////////////////////////////////
// UDP BASED COMMANDS
///////////////////////////////////////////////////////////////////////////////////
void pg_aliasScript(string address_string, string string_argument_0,
	float float_arguments[MAX_OSC_ARGUMENTS], int nb_arguments) {
#if (defined(var_pen_hue) && defined(var_pen_sat) && defined(var_pen_value)) || (defined(var_repop_huePart) && defined(var_repop_satPart) && defined(var_repop_valuePart))
		float control_color[3] = {0};
#endif

	// unregistered command (either scenario variable or program defined command)
	if (pg_OSC_addresses_hashMap.find(address_string) == pg_OSC_addresses_hashMap.end()) {
		// touch OSC sends OSC commands for each tab change, we have decided to suffix their address with _DISPLAY
		string touchOSC_tab_command_ending("_DISPLAY");
		unsigned int touchOSC_tab_command_ending_length = touchOSC_tab_command_ending.length();
		// touch OSC sends OSC commands for MSS and sensor that is forwarded to pg_sensors.py, we have decided to prefix their address with mss_
		string MSS_sensor_command_beginning("mss_");
		string XMM_sensor_command_beginning("xmm_");
		// light OSC address begins with light
		string DMX_command_beginning("light");
		unsigned int DMX_command_beginning_length = DMX_command_beginning.length();
		// TouchOSC tab change
		if (address_string.length() >= touchOSC_tab_command_ending_length
			&& (0 == address_string.compare(address_string.length() - touchOSC_tab_command_ending_length,
				touchOSC_tab_command_ending_length, touchOSC_tab_command_ending))) {
			// OKAY this is a tab change in touchOSC
		}
#if defined(PG_LIGHTS_CONTROL_IN_PYTHON)
		// OSC message for lighting
		else if (address_string.length() > DMX_command_beginning_length
			&& (0 == address_string.compare(0, DMX_command_beginning_length, DMX_command_beginning))
			&& pg_nb_light_groups[pg_current_configuration_rank] > 0) {
			// this is a light change command that has to be turned into a DMX command according to the address and the value
			// addresses are /light/[0-9]+/(dimmer|color|strobe|grey)
			// splits the argument separated by /
			std::vector<std::string> address_tags;
			address_tags = split_string(address_string, '/');
			//printf("light command %s %s\n", address_tags[0].c_str(), address_tags[1].c_str());
				// light group parameters control
			if (address_tags.size() == 3 && address_tags[0].compare("light") == 0
				&& std::all_of(address_tags[1].begin(), address_tags[1].end(), ::isdigit)) {
				int light_group = stoi(address_tags[1]);
				if (light_group > pg_nb_lights[pg_current_configuration_rank] || light_group <= 0) {
					sprintf(ErrorStr, "Unregistered light group %s/%d in light command (max: %d)!", address_tags[1].c_str(), light_group, pg_nb_light_groups[pg_current_configuration_rank]); ReportError(ErrorStr);
				}
				else if(pg_nb_light_groups[pg_current_configuration_rank] > 0) {
					if (pg_inverse_light_param_hashMap.find(address_tags[2]) == pg_inverse_light_param_hashMap.end()) {
						sprintf(ErrorStr, "Unknown light command (%s)!", address_tags[2].c_str()); ReportError(ErrorStr);
					}
					else {
						if (nb_arguments != 1) {
							sprintf(ErrorStr, "light set command (%s) expects %d arguments not %d!", address_string.c_str(), 1, nb_arguments); ReportError(ErrorStr);
						}
						else {
							//printf("sets %s for light group %d %.2f\n", address_tags[2].c_str(), light_group, float_arguments[0]);
							pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val(pg_inverse_light_param_hashMap[address_tags[2]], float_arguments[0]);
							sprintf(AuxString, "/%s %.5f", address_string.c_str(), float_arguments[0]); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
							//printf("TouchOSX % s\n", AuxString);
						}
					}
				}
#ifdef PG_LIGHTS_DMX_IN_PYTHON
				// all light value commands are forwarded to python for light DMX commands in Python
				sprintf(AuxString, "/%s %.4f", address, float_arguments[0]); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_Python_send");
#endif
			}
			// light group parameters control
			else if (address_tags.size() == 3 && address_tags[0].compare("light_pulse") == 0
				&& std::all_of(address_tags[1].begin(), address_tags[1].end(), ::isdigit)) {
				int light_group = stoi(address_tags[1]);
				//printf("light pulse %d %.2f\n", light_group, float_arguments[0]);
				if (light_group > pg_nb_light_groups[pg_current_configuration_rank] || light_group <= 0) {
					sprintf(ErrorStr, "Unregistered light group %s/%d in light command (max: %d)!", address_tags[1].c_str(), light_group, pg_nb_light_groups[pg_current_configuration_rank]); ReportError(ErrorStr);
				}
				else if(pg_nb_light_groups[pg_current_configuration_rank] > 0) {
					if (pg_inverse_light_param_hashMap.find(address_tags[2]) == pg_inverse_light_param_hashMap.end()) {
						sprintf(ErrorStr, "Unknown light command (%s)!", address_tags[2].c_str()); ReportError(ErrorStr);
					}
					else {
						if (nb_arguments != 1) {
							sprintf(ErrorStr, "light pulse command (%s) expects %d arguments not %d!", address_string.c_str(), 1, nb_arguments); ReportError(ErrorStr);
						}
						else {
							switch (pg_inverse_light_param_hashMap[address_tags[2]]) {
							case _dimmer:
								//printf("sets dimmer pulse for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_dimmer, float_arguments[0]);
								break;
							case _strobe:
								//printf("sets strobe for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_strobe, float_arguments[0]);
								break;
							case _zoom:
								//printf("sets zoom for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_zoom, float_arguments[0]);
								break;
							case _pan:
								//printf("sets pan for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_pan, float_arguments[0]);
								break;
							case _tilt:
								//printf("sets tilt for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_tilt, float_arguments[0]);
								break;
							case _hue:
								//printf("sets hue for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_hue, float_arguments[0]);
								break;
							case _red:
								//printf("sets red for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_red, float_arguments[0]);
								break;
							case _green:
								//printf("sets green for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_green, float_arguments[0]);
								break;
							case _blue:
								//printf("sets blue for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_blue, float_arguments[0]);
								break;
							case _grey:
								//printf("sets grey for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_grey, float_arguments[0]);
								break;
							case _palette_color:
								//printf("sets palette for light group %d %.2f\n", light_group, float_arguments[0]);
								pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val_pulse(_palette_color, float_arguments[0]);
								break;
							}
							sprintf(AuxString, "/%s %.5f", address_string.c_str(), float_arguments[0]); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
							//printf("TouchOSX % s\n", AuxString);
						}
					}
				}
#ifdef PG_LIGHTS_DMX_IN_PYTHON
				// all light value commands are forwarded to python for light DMX commands in Python
				sprintf(AuxString, "/%s %.4f", address, float_arguments[0]); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_Python_send");
#endif
			}
			// light control command
			else if (address_tags.size() == 2 && address_tags[0].compare("light_control") == 0) {
			//printf("address tag %s %s\n", address_tags[0].c_str(), address_tags[1].c_str());
#if defined(PG_LIGHTS_DMX_IN_PG)
				// switching off all lights
				if (address_tags[1].compare("zero_light") == 0) {
					pg_SendDMXZeros();
					if (pg_nb_light_groups[pg_current_configuration_rank] > 0) {
						for (const auto& myPair : pg_light_param_hashMap) {
							int light_param = myPair.first;
							string light_param_string = myPair.second;
							sprintf(AuxString, "/light/%s %.4f", light_param_string.c_str(),
								pg_light_groups[pg_current_configuration_rank][pg_interface_light_group].get_group_val(pg_light_command_hashMap_IDs(light_param), 0));
							pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						}
					}
#if defined(var_light1_grey) && defined(var_light1_color) && defined(var_light1_dimmer) && defined(var_light1_strobe) && defined(var_light1_grey_pulse) && defined(var_light1_color_pulse) && defined(var_light1_dimmer_pulse) && defined(var_light1_strobe_pulse) 
					BrokenInterpolationVar[_light1_grey][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light1_grey]) = 0.;
					BrokenInterpolationVar[_light1_color][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light1_color]) = 0.;
					BrokenInterpolationVar[_light1_dimmer][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light1_dimmer]) = 0.;
					BrokenInterpolationVar[_light1_strobe][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light1_strobe]) = 0.;
#endif
#if defined(var_light2_grey) && defined(var_light2_color) && defined(var_light2_dimmer) && defined(var_light2_strobe) && defined(var_light2_grey_pulse) && defined(var_light2_color_pulse) && defined(var_light2_dimmer_pulse) && defined(var_light2_strobe_pulse) 
					BrokenInterpolationVar[_light2_grey][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light2_grey]) = 0.;
					BrokenInterpolationVar[_light2_color][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light2_color]) = 0.;
					BrokenInterpolationVar[_light2_dimmer][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light2_dimmer]) = 0.;
					BrokenInterpolationVar[_light2_strobe][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light2_strobe]) = 0.;
#endif
#if defined(var_light3_grey) && defined(var_light3_color) && defined(var_light3_dimmer) && defined(var_light3_strobe) && defined(var_light3_grey_pulse) && defined(var_light3_color_pulse) && defined(var_light3_dimmer_pulse) && defined(var_light3_strobe_pulse) 
					BrokenInterpolationVar[_light3_grey][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light3_grey]) = 0.;
					BrokenInterpolationVar[_light3_color][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light3_color]) = 0.;
					BrokenInterpolationVar[_light3_dimmer][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light3_dimmer]) = 0.;
					BrokenInterpolationVar[_light3_strobe][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light3_strobe]) = 0.;
#endif
#if defined(var_light4_grey) && defined(var_light4_color) && defined(var_light4_dimmer) && defined(var_light4_strobe) && defined(var_light4_grey_pulse) && defined(var_light4_color_pulse) && defined(var_light4_dimmer_pulse) && defined(var_light4_strobe_pulse) 
					BrokenInterpolationVar[_light4_grey][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light4_grey]) = 0.;
					BrokenInterpolationVar[_light4_color][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light4_color]) = 0.;
					BrokenInterpolationVar[_light4_dimmer][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light4_dimmer]) = 0.;
					BrokenInterpolationVar[_light4_strobe][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light4_strobe]) = 0.;
#endif
#if defined(var_light5_grey) && defined(var_light5_color) && defined(var_light5_dimmer) && defined(var_light5_strobe) && defined(var_light5_grey_pulse) && defined(var_light5_color_pulse) && defined(var_light5_dimmer_pulse) && defined(var_light5_strobe_pulse) 
					BrokenInterpolationVar[_light5_grey][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light5_grey]) = 0.;
					BrokenInterpolationVar[_light5_color][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light5_color]) = 0.;
					BrokenInterpolationVar[_light5_dimmer][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light5_dimmer]) = 0.;
					BrokenInterpolationVar[_light5_strobe][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light5_strobe]) = 0.;
#endif
#if defined(var_light6_grey) && defined(var_light6_color) && defined(var_light6_dimmer) && defined(var_light6_strobe) && defined(var_light6_grey_pulse) && defined(var_light6_color_pulse) && defined(var_light6_dimmer_pulse) && defined(var_light6_strobe_pulse) 
					BrokenInterpolationVar[_light6_grey][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light6_grey]) = 0.;
					BrokenInterpolationVar[_light6_color][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light6_color]) = 0.;
					BrokenInterpolationVar[_light6_dimmer][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light6_dimmer]) = 0.;
					BrokenInterpolationVar[_light6_strobe][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light6_strobe]) = 0.;
#endif
#if defined(var_light7_grey) && defined(var_light7_color) && defined(var_light7_dimmer) && defined(var_light7_strobe) && defined(var_light7_grey_pulse) && defined(var_light7_color_pulse) && defined(var_light7_dimmer_pulse) && defined(var_light7_strobe_pulse) 
					BrokenInterpolationVar[_light7_grey][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light7_grey]) = 0.;
					BrokenInterpolationVar[_light7_color][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light7_color]) = 0.;
					BrokenInterpolationVar[_light7_dimmer][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light7_dimmer]) = 0.;
					BrokenInterpolationVar[_light7_strobe][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light7_strobe]) = 0.;
#endif
#if defined(var_light8_grey) && defined(var_light8_color) && defined(var_light8_dimmer) && defined(var_light8_strobe) && defined(var_light8_grey_pulse) && defined(var_light8_color_pulse) && defined(var_light8_dimmer_pulse) && defined(var_light8_strobe_pulse) 
					BrokenInterpolationVar[_light8_grey][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light8_grey]) = 0.;
					BrokenInterpolationVar[_light8_color][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light8_color]) = 0.;
					BrokenInterpolationVar[_light8_dimmer][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light8_dimmer]) = 0.;
					BrokenInterpolationVar[_light8_strobe][pg_current_configuration_rank] = true;
					*((float*)ScenarioVarPointers[_light8_strobe]) = 0.;
#endif
				}
				// light group change in the interface, reships the parameter values
				else if (address_tags[1].compare("light_group") == 0) {
					if (nb_arguments != 1) {
						sprintf(ErrorStr, "light light_group command (%s) expects %d arguments not %d!", address_string.c_str(), 1, nb_arguments); ReportError(ErrorStr);
					}
					else if(pg_nb_light_groups[pg_current_configuration_rank] > 0) {
						if (int(float_arguments[0]) < pg_nb_light_groups[pg_current_configuration_rank]) {
							pg_interface_light_group = int(float_arguments[0]);
							//printf("light_group command (%s) %d!", address_string.c_str(), pg_interface_light_group); 
							// interface control values updating according to the current light group focus
							// update for all the parameters
							pg_lightGUI_all_values_and_pulse_update();
							// update for the looped parameters
							pg_lightGUI_all_loop_update();
						}
						//else {
						//	sprintf(AuxString, "/light_control/light_group %d", pg_interface_light_group);
						//	pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						//}
					}
				}
				// single channel value change single precision
				else if (address_tags[1].compare("channel_value") == 0) {
					if (nb_arguments != 3) {
						sprintf(ErrorStr, "light channel_value command (%s) expects %d arguments not %d!", address_string.c_str(), 3, nb_arguments); ReportError(ErrorStr);
					}
					else {
						//printf("Store DMX channel/val/port %d %.2f %d\n", int(float_arguments[0]), float_arguments[1], int(float_arguments[2]));
						pg_StoreDMX(int(float_arguments[0]), float_arguments[1], int(float_arguments[2]), false);
						pg_SendDMX();
					}
				}
				// single channel value change double precision
				else if (address_tags[1].compare("channel_fine_value") == 0) {
					if (nb_arguments != 3) {
						sprintf(ErrorStr, "light channel_fine_value command (%s) expects %d arguments not %d!", address_string.c_str(), 3, nb_arguments); ReportError(ErrorStr);
					}
					else {
						//printf("Store DMX *fine* channel/val/port %d %.2f %d\n", int(float_arguments[0]), float_arguments[1], int(float_arguments[2]));
						pg_StoreDMX(int(float_arguments[0]), float_arguments[1], int(float_arguments[2]), true);
						pg_SendDMX();
					}
				}
				// random value assignment to a light parameter
				else if (address_tags[1].compare(0, string("random_").size(), "random_") == 0) {
					string command = address_tags[1].substr(string("random_").size());
					int light_group = int(float_arguments[0]);
					if (light_group <= pg_nb_light_groups[pg_current_configuration_rank] && light_group > 0) {
						float val = rand_0_1;
						//printf("sets random value %s for light group %d %.2f\n", command.c_str(), light_group, val);
						pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_val(pg_inverse_light_param_hashMap[command], val);
						sprintf(AuxString, "/light/%d/%s %.4f", light_group, command.c_str(), val); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
					}
				}
				// onOff assignment to a light parameter
				else if (address_tags[1].compare(0, string("onOff_").size(), "onOff_") == 0) {
					string command = address_tags[1].substr(string("onOff_").size());
					int light_group = int(float_arguments[0]);
					bool is_on = (float_arguments[1] == 1.f);
					if (light_group <= pg_nb_light_groups[pg_current_configuration_rank] && light_group > 0) {
						//printf("sets onOff value %s for light group %d %d\n", command.c_str(), light_group, int(is_on));
						pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_onOff(pg_inverse_light_param_hashMap[command], is_on);
						sprintf(AuxString, "/light-control/onOff_%s %.2f %.2f", command.c_str(), float(light_group), float(is_on)); pg_send_message_udp((char*)"ff", AuxString, (char*)"udp_TouchOSC_send");
					}
				}
				// beat based onOff change assignment to a light parameter
				else if (address_tags[1].compare(0, string("beatOnOff_").size(), "beatOnOff_") == 0) {
					string command = address_tags[1].substr(string("beatOnOff_").size());
					int light_group = int(float_arguments[0]);
					bool is_on = (float_arguments[1] == 1.f);
					if (light_group <= pg_nb_light_groups[pg_current_configuration_rank] && light_group > 0) {
						//printf("sets beat on/off %s for light group %d %d\n", command.c_str(), light_group, int(is_on));
						pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_beatOnOff(pg_inverse_light_param_hashMap[command], is_on);
					}
				}
				// beat based random value assignment to a light parameter
				else if (address_tags[1].compare(0, string("beatRandom_").size(), "beatRandom_") == 0) {
					string command = address_tags[1].substr(string("beatRandom_").size());
					int light_group = int(float_arguments[0]);
					bool is_on = (float_arguments[1] == 1.f);
					if (light_group <= pg_nb_light_groups[pg_current_configuration_rank] && light_group > 0) {
						//printf("sets beat random %s for light group %d %d\n", command.c_str(), light_group, int(is_on));
						pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_beatRandom(pg_inverse_light_param_hashMap[command], is_on);
					}
				}
				// loop assignment to a light parameter
				else if (address_tags[1].compare(0, string("loop_").size(), "loop_") == 0) {
					if (nb_arguments != 7) {
						sprintf(ErrorStr, "light loop command (%s) expects %d arguments not %d!", address_string.c_str(), 7, nb_arguments); ReportError(ErrorStr);
					}
					else {
						string command = address_tags[1].substr(string("loop_").size());
						//sendOSC('/light_control/loop_tilt', self.values.x, light_group, curve, parallel, min, max, speed, { true })
						bool on_off = (float_arguments[0] == 1.f);
						int light_group = int(float_arguments[1]);
						int curve_type = int(float_arguments[2]);
						int parallel_vs_alternate = int(float_arguments[3]);
						float min_val = float_arguments[4];
						float max_val = float_arguments[5];
						double speed_val = double(float_arguments[6]);
						if (light_group <= pg_nb_light_groups[pg_current_configuration_rank] && light_group > 0) {
							printf("%s loop for light group %d oOff %d curve %d // %d  vals min max speed %.3f %.3f %.3f\n", command.c_str(), light_group, on_off, curve_type, parallel_vs_alternate, min_val, max_val, speed_val);
							pg_light_groups[pg_current_configuration_rank][light_group - 1].set_group_loop(pg_inverse_light_param_hashMap[command], on_off, curve_type, parallel_vs_alternate, min_val, max_val, speed_val);
						}
					}
				}
				else {
					switch (nb_arguments) {
					case 0:
						sprintf(AuxString, "/%s", address_string.c_str());
						pg_send_message_udp((char*)"", AuxString, (char*)"udp_Python_send");
						break;
					case 1:
						sprintf(AuxString, "/%s %.6f", address_string.c_str(), float_arguments[0]);
						pg_send_message_udp((char*)"f", AuxString, (char*)"udp_Python_send");
						break;
					case 2:
						sprintf(AuxString, "/%s %.6f %.6f", address_string.c_str(), float_arguments[0], float_arguments[1]);
						pg_send_message_udp((char*)"ff", AuxString, (char*)"udp_Python_send");
						break;
					case 3:
						sprintf(AuxString, "/%s %.6f %.6f %.6f", address_string.c_str(), float_arguments[0], float_arguments[1], float_arguments[2]);
						pg_send_message_udp((char*)"fff", AuxString, (char*)"udp_Python_send");
						break;
					default:
						sprintf(AuxString, "/%s %.6f %.6f %.6f %.6f", address_string.c_str(), float_arguments[0], float_arguments[1], float_arguments[2], float_arguments[3]);
						pg_send_message_udp((char*)"ffff", AuxString, (char*)"udp_Python_send");
						break;
					}
				}
			}
#endif 
#ifdef PG_LIGHTS_DMX_IN_PYTHON
				// all light control commands are forwarded to python for light_scene management
			sprintf(AuxString, "/%s %.4f", address, float_arguments[0]); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_Python_send");
#endif
		}
#endif
		// OSC message for sensors
		else if ((address_string.length() >= MSS_sensor_command_beginning.length()
			&& (0 == address_string.compare(0, MSS_sensor_command_beginning.length(), MSS_sensor_command_beginning)))
			|| (address_string.length() >= XMM_sensor_command_beginning.length()
				&& (0 == address_string.compare(0, XMM_sensor_command_beginning.length(), XMM_sensor_command_beginning)))) {
			// OKAY this is a MSS and sensor command that is forwarded to pg_sensors.py
			// printf("MSS and sensor command %s\n", address);
			if (nb_arguments == 1) {
				sprintf(AuxString, "/%s %.5f", address_string.c_str(), float_arguments[0]); pg_send_message_udp((char*)"f", AuxString, (char*)"udp_MSS_sensor_send");
			}
			else if (nb_arguments == 2) {
				sprintf(AuxString, "/%s %.5f %.5f", address_string.c_str(), float_arguments[0], float_arguments[1]); pg_send_message_udp((char*)"ff", AuxString, (char*)"udp_MSS_sensor_send");
			}
			else {
				sprintf(AuxString, "/%s", address_string.c_str()); pg_send_message_udp((char*)"", AuxString, (char*)"udp_MSS_sensor_send");
			}
		}
		else {
			sprintf(ErrorStr, "Unknown command (%s)!", address_string.c_str()); ReportError(ErrorStr);
		}
		return;
	}

	// command from the scenario file
	if (pg_OSC_addresses_hashMap[address_string] < _MaxInterpVarIDs) {
		if (ScenarioVarConfigurations[pg_OSC_addresses_hashMap[address_string]][pg_current_configuration_rank]) {
			ScenarioValue arg_val(float_arguments[0], "");
			pg_update_variable(_PG_GUI_COMMAND,
				pg_OSC_addresses_hashMap[address_string], arg_val);
		}
		return;
	}

	// special command not in the scenario file
	switch (pg_OSC_addresses_hashMap[address_string]) {

	// ====================================== 
	// test UDP connection                    
	// ====================================== 
	case _testUDP: {
		// from TouchOSC, Lola's sound program or Usine
		pg_writeMessageOnScreen("*** OK ***");
		sprintf(AuxString, "/setup UDP_test_received"); pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
#ifdef KOMPARTSD
		pg_IPClient * client;
		if ((client = pg_UDP_client((char *)"udp_Usine_send"))) {
			// sends a message to Usine for confirming UDP connection between porphyrograph and Usine
			if (testUDP_KOMPARTSD) {
				sprintf(AuxString, "/testUDP 1");
			}
			else {
				sprintf(AuxString, "/testUDP 0");
			}
			testUDP_KOMPARTSD = !testUDP_KOMPARTSD;
			pg_send_message_udp((char *)"i", (char *)AuxString, client);
			// sends the new scene to Usine for sample selection
			for (int ind = 0; ind < 4; ind++) {
				sprintf(AuxString, "/new_scene_%d 0", ind);
				pg_send_message_udp((char *)"i", (char *)AuxString, client);
			}
		}
#endif
		break;
	}
	case _QT_connected: {
		pg_writeMessageOnScreen("*** QT ***");
		break;
	}

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ PD CONNECTION CONFIRMATION ++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _PD_connected: {
		// from Yukao's PD
		pg_send_message_udp((char *)"s", (char *)"/PD_connected 1", (char *)"udp_TouchOSC_send");
		pg_writeMessageOnScreen("*** PD ***");
		break;
	}
	case _return_message: {
		pg_writeMessageOnScreen(string_argument_0);
		break;
	}

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ LAUNCH TIMER ++++++++++++++++++++++++++ 
	// +++++++++++++++++   keystroke (t)  ++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _launch: {
		pg_launch_performance(0);
		break;
	}

#ifdef PG_WITH_PUREDATA
				  // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ SOUND RESET ++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _reset_sound: {
		pg_send_message_udp((char *)"i", (char *)"/reset_sound 1", (char *)"udp_PD_send");
		break;
	}

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ CONNECTS PD ++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _connect_PD: {
		pg_send_message_udp((char *)"i", (char *)"/connect 1", (char *)"udp_PD_send");

		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ QUITS +++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++   keystroke (ESC)  ++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _quit: {
		pg_quit();
		break;
	}

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ VIDEO & PHOTO FLASH +++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _flashCamera: {
		pg_Make_flashCamera();
		break;
	}
	case _Note1: 
	case _Note2:
	case _Note3: 
	{
		int argt0 = int(round(float_arguments[0]));
		if (argt0 >= 0) {
			pg_MIDINote = argt0;
		}
		else {
			pg_MIDINote = 0;
		}

#if defined(FORET)
		if (rand_0_1 < 0.3) {
			// goes to the first photo diaporama if it is not already selected and if there is one 
			if (photo_diaporama < 0 && nb_photo_albums > 0) {
				photo_diaporama = 0;
			}
			pg_CurrentDiaporamaDir = (pg_CurrentDiaporamaDir + 1) % (pg_nbCompressedImageDirs[pg_current_configuration_rank] - 1);
			printf("pg_CurrentDiaporamaDir %d\n", pg_CurrentDiaporamaDir);
			if (pg_CurrentDiaporamaDir == 2 || pg_CurrentDiaporamaDir == 9 || pg_CurrentDiaporamaDir == 11 || pg_CurrentDiaporamaDir == 16) {
				master_scale_pulse = 0.15f;
			}
			else {
				master_scale_pulse = 0.f;
			}
			*((float*)ScenarioVarPointers[_master_scale_pulse]) = master_scale_pulse;
			sprintf(AuxString, "/diaporama_shortName %03d", pg_CurrentDiaporamaDir);
			pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
			pg_launch_diaporama();
		}
		break;
#endif
#if defined(var_MIDIwithBrush)
		if (ScenarioVarConfigurations[_MIDIwithBrush][pg_current_configuration_rank]) {
			if (MIDIwithBrush) {
				pen_brush = int(nb_pen_brushes[pg_current_configuration_rank] * 3 * rand_0_1) % (nb_pen_brushes[pg_current_configuration_rank] * 3);
				BrokenInterpolationVar[_pen_brush] = true;
				printf("new brush %d\n", pen_brush);
			}
		}
#endif
#if defined(var_MIDIwithColor)
		if (ScenarioVarConfigurations[_MIDIwithColor][pg_current_configuration_rank]) {
			if (MIDIwithColor) {
				if (nb_pen_colorPresets[pg_current_configuration_rank] > 0) {
					current_pen_colorPreset = int(nb_pen_colorPresets[pg_current_configuration_rank] * rand_0_1) % nb_pen_colorPresets[pg_current_configuration_rank];
					printf("new palette %d\n", current_pen_colorPreset);
#if defined(var_pen_color)
					if (ScenarioVarConfigurations[_pen_color][pg_current_configuration_rank]) {
						BrokenInterpolationVar[_pen_color] = true;
						*((float*)ScenarioVarPointers[_pen_color]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].color;
					}
#endif
					// sprintf(AuxString, "/pen_color %.3f", pen_colorPresets_values[current_pen_colorPreset]);
					// pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
					// sprintf(AuxString, "/message palette%s", pen_colorPresets_names[current_pen_colorPreset].c_str()); pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");
					sprintf(AuxString, "/pen_colorPreset %d", current_pen_colorPreset); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
#endif
#if defined(var_MIDIwithCameraFlash)
		if (ScenarioVarConfigurations[_MIDIwithCameraFlash][pg_current_configuration_rank]) {
			if (MIDIwithCameraFlash) {
				printf("Flash camera\n");
				pg_Make_flashCamera();
			}
		}
#endif
#if defined(var_MIDIwithPhotoFlash) && defined(var_flashPhotoTrkBright)
		if (ScenarioVarConfigurations[_MIDIwithPhotoFlash][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_flashPhotoTrkBright][pg_current_configuration_rank]) {
			if (MIDIwithPhotoFlash) {
				printf("Flash photo\n");
				pg_Make_flashPhoto();
			}
		}
#endif
#if defined(var_MIDIwithBeat)
		if (ScenarioVarConfigurations[_MIDIwithBeat][pg_current_configuration_rank]) {
			if (MIDIwithBeat) {
				pg_BeatNo++;
				printf("beat %d\n", pg_BeatNo);
				ReceiveBeat();
			}
		}
#endif
#if defined(var_MIDIwithStroke)
		if (ScenarioVarConfigurations[_MIDIwithStroke][pg_current_configuration_rank]) {
			if (MIDIwithStroke) {
				FourFrameStrokeNb = 5;
				FourFrameStroke_x = int(workingWindow_width * rand_0_1);
				FourFrameStroke_y = int(workingWindow_width * rand_0_1);
			}
		}
#endif
#if defined(var_cameraCaptFreq) && defined(var_flashCameraTrkBright)
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_flashCameraTrkBright][pg_current_configuration_rank]) {
			if (flashCameraTrkBright > 0) {
				is_flashCameraTrk = false;
				flashCameraTrk_weight = flashCameraTrkBright;
				flashCameraTrk_threshold = std::min(std::max(0.0f, 1.0f - flashCameraTrk_decay * flashCameraTrkBright), 1.0f);
				//printf("flashCameraTrk_weight %.3f decay %.2f threshold %.3f\n",
				//	flashCameraTrk_weight, flashCameraTrk_decay, flashPhotoTrk_threshold);
				//printf("start flash\n");
				//    break;
			}
		}
#endif
		break;
	}
	// beats in Alchemy
	case _Velocity1:
	{
#if defined(var_alKemi)
		if (ScenarioVarConfigurations[_alKemi][pg_current_configuration_rank]) {
			int argt0 = int(round(float_arguments[0]));
			if (argt0 > 0) {
				pg_BeatNo++;
				ReceiveBeat();
			}
		}
#endif
		break;
	}

#if defined(var_flashPhotoTrkBeat)
	case _flashPhoto: {
		if (ScenarioVarConfigurations[_flashPhotoTrkBeat][pg_current_configuration_rank]) {
			if (flashPhotoTrkBeat == 0) {
#if defined(var_flashPhotoTrkBright)
				if (ScenarioVarConfigurations[_flashPhotoTrkBright][pg_current_configuration_rank]) {
					pg_Make_flashPhoto();
				}
#endif
			}
			else {
				// will be launched when the beat corresponds
				is_flashPhotoTrk = true;
				flashPhotoTrk_weight = 0.0f;
			}
		}
		// printf("start flash\n");
		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ MUSIC CONTROL +++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// received from pure data or generated by program if auto_sound is on
	case _pulse_spectrum: {
		pulse[0] = float_arguments[0] * sound_volume + sound_min;
		pulse[1] = float_arguments[1] * sound_volume + sound_min;
		pulse[2] = float_arguments[2] * sound_volume + sound_min;
#ifdef PG_WITH_SOUND_LEVELS_GUI_FEEDBACK
		// not used currently  pulse_attack = float_arguments[3] * sound_volume + sound_min;
		sprintf(AuxString, "/pulse_low %.2f", pulse[0]);
		pg_send_message_udp((char *)"f", AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/pulse_medium %.2f", pulse[1]);
		pg_send_message_udp((char *)"f", AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/pulse_high %.2f", pulse[2]);
		pg_send_message_udp((char *)"f", AuxString, (char *)"udp_TouchOSC_send");
#endif

		pulse_average_prec = pulse_average;
		pulse_average = (pulse[0] + pulse[1] + pulse[2]) / 3.f;

#ifdef PG_WITH_SOUND_LEVELS_GUI_FEEDBACK
		sprintf(AuxString, "/pulse %.2f", pulse_average);
		pg_send_message_udp((char *)"f", AuxString, (char *)"udp_TouchOSC_send");
		// printf("%s\n", AuxString);
#endif

#if defined(var_pen_color) && defined(var_pen_grey)
		if (ScenarioVarConfigurations[_pen_color][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_pen_grey][pg_current_configuration_rank]) {
			//printf("pulse %.2f %.2f %.2f avg %.2f\n", pulse[0], pulse[1], pulse[2], pulse_average);
			//printf("pen_color %.2f pen_color_pulse %.2f pen_grey %.2f pen_grey_pulse %.2f pulsed_pen_color  %.2f %.2f %.2f %.2f\n", pen_color, pen_color_pulse, pen_grey, pen_grey_pulse, pulsed_pen_color[0], pulsed_pen_color[1], pulsed_pen_color[2], pulsed_pen_color[3]);
			compute_pulsed_palette_color(pen_color, pen_color_pulse, pen_grey, pen_grey_pulse, pulsed_pen_color, true);
		}
#endif
#if defined(var_pen_hue) & defined(var_pen_sat) && defined(var_pen_value)
		if (ScenarioVarConfigurations[_pen_hue][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_pen_sat][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_pen_value][pg_current_configuration_rank]
				compute_pulsed_HSV_color(pen_hue, pen_hue_pulse, pen_sat, pen_sat_pulse, pen_value, pen_value_pulse, pulsed_pen_color, true);
		}
#endif
#if !defined(LIGHT)
		sprintf(AuxString, "/pen_color/color %02x%02x%02xFF", int(pulsed_pen_color[0] * 255), int(pulsed_pen_color[1] * 255), int(pulsed_pen_color[2] * 255));
		pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
		//printf("%s\n", AuxString);
		compute_pulsed_palette_color(repop_colorCA, repop_colorCA_pulse, repop_greyCA, repop_greyCA_pulse, pulsed_repop_colorCA, false);
		sprintf(AuxString, "/CA_repopColor/color %02x%02x%02xFF", int(pulsed_repop_colorCA[0] * 255), int(pulsed_repop_colorCA[1] * 255), int(pulsed_repop_colorCA[2] * 255)); 
		pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
		compute_pulsed_palette_color(repop_colorBG, repop_colorBG_pulse, repop_greyBG, repop_greyBG_pulse, pulsed_repop_colorBG, false);
		sprintf(AuxString, "/BG_repopColor/color %02x%02x%02xFF", int(pulsed_repop_colorBG[0] * 255), int(pulsed_repop_colorBG[1] * 255), int(pulsed_repop_colorBG[2] * 255)); 
		pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
#endif
#if defined(var_part_initialization) 
		if (ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank]) {
#if defined(var_repop_colorPart) && defined(var_repop_greyPart)
			if (ScenarioVarConfigurations[_repop_colorPart][pg_current_configuration_rank]
				&& ScenarioVarConfigurations[_repop_greyPart][pg_current_configuration_rank]) {
				compute_pulsed_palette_color(repop_colorPart, repop_colorPart_pulse, repop_greyPart, repop_greyPart_pulse, pulsed_repop_colorPart, false);
			}
#endif
#if defined(var_repop_huePart) && defined(var_repop_satPart) && defined(var_repop_valuePart)
			if (ScenarioVarConfigurations[_repop_huePart][pg_current_configuration_rank]
				&& ScenarioVarConfigurations[_repop_satPart][pg_current_configuration_rank]
				&& ScenarioVarConfigurations[_repop_valuePart][pg_current_configuration_rank]) {
				compute_pulsed_HSV_color(repop_huePart, repop_huePart_pulse, repop_satPart, repop_satPart_pulse, repop_valuePart, repop_valuePart_pulse, pulsed_repop_colorPart, false);
			}
#endif
			sprintf(AuxString, "/Part_repopColor/color %02x%02x%02xFF", int(pulsed_repop_colorPart[0] * 255), int(pulsed_repop_colorPart[1] * 255), int(pulsed_repop_colorPart[2] * 255));
			pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
		}
#endif
		break;
	}

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ FLASHES +++++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ======================================== 
	// flash triggering according to beat & frequency, weight, and on/off values 
	// ======================================== 
	// flashes are synchronized on beats according to their frequency
	// received from pure data or generated by program if auto_beat is on
	case _beat: {
		int argt0 = int(round(float_arguments[0]));
		if (argt0 >= 0) {
			pg_BeatNo = argt0;
		}
		else {
			pg_BeatNo++;
		}

		ReceiveBeat();
	}
	break;

	case _MIDINote: {
		int argt0 = int(round(float_arguments[0]));
		if (argt0 >= 0) {
			pg_MIDINote = argt0;
		}
		else {
			pg_MIDINote = 0;
		}
#if defined(var_MIDIwithBrush)
		if (ScenarioVarConfigurations[_MIDIwithBrush][pg_current_configuration_rank]) {
			if (MIDIwithBrush) {
				if (nb_pen_brushes[pg_current_configuration_rank] > 0) {
					pen_brush = int(nb_pen_brushes[pg_current_configuration_rank] * 3 * rand_0_1) % (nb_pen_brushes[pg_current_configuration_rank] * 3);
					BrokenInterpolationVar[_pen_brush] = true;
					printf("new brush %d\n", pen_brush);
				}
			}
		}
#endif
#if defined(var_MIDIwithColor)
		if (ScenarioVarConfigurations[_MIDIwithColor][pg_current_configuration_rank]) {
			if (MIDIwithColor) {
#if !defined(LIGHT)
				//if (nb_pen_colorPresets > 0) {
				//	current_pen_colorPreset = pg_MIDINote % nb_pen_colorPresets[pg_current_configuration_rank];
				//	printf("new palette %d\n", current_pen_colorPreset);
				//	BrokenInterpolationVar[_pen_color] = true;
				//	*((float*)ScenarioVarPointers[_pen_color]) = pg_colorPreset_values[current_pen_colorPreset];
				//	// sprintf(AuxString, "/pen_color %.3f", pen_colorPresets_values[current_pen_colorPreset]);
				//	// pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
				//	// sprintf(AuxString, "/message palette%s", pen_colorPresets_names[current_pen_colorPreset].c_str()); pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");
				//	sprintf(AuxString, "/pen_colorPreset %d", current_pen_colorPreset); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				//}
				if (nb_pen_colorPresets[pg_current_configuration_rank] > 0) {
					current_pen_colorPreset = int(nb_pen_colorPresets[pg_current_configuration_rank] * rand_0_1) % nb_pen_colorPresets[pg_current_configuration_rank];
					printf("new palette %d\n", current_pen_colorPreset);
#if defined(var_pen_color)
					if (ScenarioVarConfigurations[_pen_color][pg_current_configuration_rank]) {
						BrokenInterpolationVar[_pen_color] = true;
						*((float*)ScenarioVarPointers[_pen_color]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].color;
					}
#endif
					sprintf(AuxString, "/pen_colorPreset %d", current_pen_colorPreset); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}			// select hue/sat/value present
				// TODO
#endif
		}
#endif
#if defined(var_MIDIwithCameraFlash)
		if (ScenarioVarConfigurations[_MIDIwithCameraFlash][pg_current_configuration_rank]) {
			if (MIDIwithCameraFlash) {
				printf("Flash camera\n");
				pg_Make_flashCamera();
			}
		}
#endif
#if defined(var_MIDIwithPhotoFlash) && defined(var_flashPhotoTrkBright)
		if (ScenarioVarConfigurations[_MIDIwithPhotoFlash][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_flashPhotoTrkBright][pg_current_configuration_rank]) {
			if (MIDIwithPhotoFlash) {
				printf("Flash photo\n");
				pg_Make_flashPhoto();
			}
		}
#endif
#if defined(var_MIDIwithBeat)
		if (ScenarioVarConfigurations[_MIDIwithBeat][pg_current_configuration_rank]) {
			if (MIDIwithBeat) {
				pg_BeatNo++;
				printf("beat %d\n", pg_BeatNo);
				ReceiveBeat();
			}
		}
#endif
#if defined(var_MIDIwithStroke)
		if (ScenarioVarConfigurations[_MIDIwithStroke][pg_current_configuration_rank]) {
			if (MIDIwithStroke) {
				FourFrameStrokeNb = 5;
				FourFrameStroke_x = int(window_width * rand_0_1);
				FourFrameStroke_y = int(window_height * rand_0_1);
			}
		}
#endif
	}
	break;

	// ======================================== 
	// flash on/off values
	// ======================================== 
#if defined(var_nb_CATypes)
	case _flashTrkCA_onOff: {
		if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]) {
			switch (currentDrawingTrack) {
			case 0:
				if (flashTrkCA_freq_0 > 0) {
					flashTrkCA_freq_0_saved = flashTrkCA_freq_0;
					flashTrkCA_freq_0 = 0;
				}
				else {
					flashTrkCA_freq_0 = flashTrkCA_freq_0_saved;
				}
				break;
#if defined(var_flashTrkCA_freq_1)
			case 1:
				if (flashTrkCA_freq_1 > 0) {
					flashTrkCA_freq_1_saved = flashTrkCA_freq_1;
					flashTrkCA_freq_1 = 0;
				}
				else {
					flashTrkCA_freq_1 = flashTrkCA_freq_1_saved;
				}
				break;
#endif
#if defined(var_flashTrkCA_freq_2)
			case 2:
				if (flashTrkCA_freq_2 > 0) {
					flashTrkCA_freq_2_saved = flashTrkCA_freq_2;
					flashTrkCA_freq_2 = 0;
				}
				else {
					flashTrkCA_freq_2 = flashTrkCA_freq_2_saved;
				}
				break;
#endif
#if defined(var_flashTrkCA_freq_3)
			case 3:
				if (flashTrkCA_freq_3 > 0) {
					flashTrkCA_freq_3_saved = flashTrkCA_freq_3;
					flashTrkCA_freq_3 = 0;
				}
				else {
					flashTrkCA_freq_3 = flashTrkCA_freq_3_saved;
				}
				break;
#endif
			}
		}
		break;
	}
#endif

#if defined(var_flashTrkPart_freq_0)
	case _flashTrkPart_onOff: {
		if (ScenarioVarConfigurations[_flashTrkPart_freq_0][pg_current_configuration_rank]) {
			switch (currentDrawingTrack) {
			case 0:
				if (flashTrkPart_freq_0 > 0) {
					flashTrkPart_freq_0_saved = flashTrkPart_freq_0;
					flashTrkPart_freq_0 = 0;
				}
				else {
					flashTrkPart_freq_0 = flashTrkPart_freq_0_saved;
				}
				break;
#if defined(var_flashTrkPart_freq_1)
			case 1:
				if (flashTrkPart_freq_1 > 0) {
					flashTrkPart_freq_1_saved = flashTrkPart_freq_1;
					flashTrkPart_freq_1 = 0;
				}
				else {
					flashTrkPart_freq_1 = flashTrkPart_freq_1_saved;
				}
				break;
#endif
#if defined(var_flashTrkPart_freq_2)
			case 2:
				if (flashTrkPart_freq_2 > 0) {
					flashTrkPart_freq_2_saved = flashTrkPart_freq_2;
					flashTrkPart_freq_2 = 0;
				}
				else {
					flashTrkPart_freq_2 = flashTrkPart_freq_2_saved;
				}
				break;
#endif
#if defined(var_flashTrkPart_freq_3)
			case 3:
				if (flashTrkPart_freq_3 > 0) {
					flashTrkPart_freq_3_saved = flashTrkPart_freq_3;
					flashTrkPart_freq_3 = 0;
				}
				else {
					flashTrkPart_freq_3 = flashTrkPart_freq_3_saved;
				}
				break;
#endif
			}
		}
		break;
	}
#endif

	// ====================================== 
	// keystroke s: Snapshot                  
	// ====================================== 
	case _snapshot: {
		if (float_arguments[0] > 0) {
			pg_snapshot((char*)"jpg");
			pg_snapshot((char*)"svg");
		}
		break;
	}

#if defined(var_GenerativeNights_planes)
		// ====================================== 
		// relaunches CA initialization, in case it does not work                  
		// ====================================== 
	case _initialBGCapture: {
		if (ScenarioVarConfigurations[_GenerativeNights_planes][pg_current_configuration_rank]) {
			initialBGCapture = true;
		}

		// ====================================== 
		// initial background capture                  
		// ====================================== 
		break;
	}
	case _initCA: {
		if (ScenarioVarConfigurations[_GenerativeNights_planes][pg_current_configuration_rank]) {
			initCA = 1.2f;
		}
		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ TRACK SHIFT +++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _currentVideoTrack_plus: {
		currentVideoTrack = (currentVideoTrack + 1) % PG_NB_TRACKS;
		break;
	}
	case _currentPhotoTrack_plus: {
		currentPhotoTrack = (currentPhotoTrack + 1) % PG_NB_TRACKS;
		break;
	}

#if defined(var_cameraCaptFreq)
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ CAMERA PARAMETERS +++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _cameraWB_R_plus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraWB_R]) += 100.f;
			pg_webCam_capture.set(CAP_PROP_WHITE_BALANCE_RED_V, (*((float*)ScenarioVarPointers[_cameraWB_R])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraWB_R]);
		}
		break;
	}
	case _cameraWB_R_minus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraWB_R]) -= 100.f;
			pg_webCam_capture.set(CAP_PROP_WHITE_BALANCE_RED_V, (*((float*)ScenarioVarPointers[_cameraWB_R])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraWB_R]);
		}
		break;
	}
	case _cameraWB_B_plus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraWB_B]) += 100.f;
			pg_webCam_capture.set(CAP_PROP_WHITE_BALANCE_BLUE_U, (*((float*)ScenarioVarPointers[_cameraWB_B])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraWB_B]);
		}
		break;
	}
	case _cameraWB_B_minus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraWB_B]) -= 100.f;
			pg_webCam_capture.set(CAP_PROP_WHITE_BALANCE_BLUE_U, (*((float*)ScenarioVarPointers[_cameraWB_B])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraWB_B]);
		}
		break;
	}
	case _cameraExposure_plus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraExposure]) += 1.f;
			pg_webCam_capture.set(CAP_PROP_EXPOSURE, (*((float*)ScenarioVarPointers[_cameraExposure])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraExposure]);
		}
		break;
	}
	case _cameraExposure_minus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraExposure]) -= 1.f;
			pg_webCam_capture.set(CAP_PROP_EXPOSURE, (*((float*)ScenarioVarPointers[_cameraExposure])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraExposure]);
		}
		break;
	}
	case _cameraGain_plus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraGain]) += 1.f;
			pg_webCam_capture.set(CAP_PROP_GAIN, (*((float*)ScenarioVarPointers[_cameraGain])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraGain]);
		}
		break;
	}
	case _cameraGain_minus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraGain]) -= 1.f;
			pg_webCam_capture.set(CAP_PROP_GAIN, (*((float*)ScenarioVarPointers[_cameraGain])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraGain]);
		}
		break;
	}
	case _cameraBrightness_plus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraBrightness]) += 10.f;
			pg_webCam_capture.set(CAP_PROP_BRIGHTNESS, (*((float*)ScenarioVarPointers[_cameraBrightness])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraBrightness]);
		}
		break;
	}
	case _cameraBrightness_minus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraBrightness]) -= 10.f;
			pg_webCam_capture.set(CAP_PROP_BRIGHTNESS, (*((float*)ScenarioVarPointers[_cameraBrightness])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraBrightness]);
		}
		break;
	}
	case _cameraSaturation_plus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraSaturation]) += 10.f;
			pg_webCam_capture.set(CAP_PROP_SATURATION, (*((float*)ScenarioVarPointers[_cameraSaturation])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraSaturation]);
		}
		break;
	}
	case _cameraSaturation_minus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraSaturation]) -= 10.f;
			pg_webCam_capture.set(CAP_PROP_SATURATION, (*((float*)ScenarioVarPointers[_cameraSaturation])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraSaturation]);
		}
		break;
	}
	case _cameraContrast_plus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraContrast]) += 10.f;
			pg_webCam_capture.set(CAP_PROP_CONTRAST, (*((float*)ScenarioVarPointers[_cameraContrast])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraContrast]);
		}
		break;
	}
	case _cameraContrast_minus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraContrast]) -= 10.f;
			pg_webCam_capture.set(CAP_PROP_CONTRAST, (*((float*)ScenarioVarPointers[_cameraContrast])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraContrast]);
		}
		break;
	}
	case _cameraGamma_plus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraGamma]) += 10.f;
			pg_webCam_capture.set(CAP_PROP_GAMMA, (*((float*)ScenarioVarPointers[_cameraGamma])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraGamma]);
		}
		break;
	}
	case _cameraGamma_minus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			*((float*)ScenarioVarPointers[_cameraGamma]) -= 10.f;
			pg_webCam_capture.set(CAP_PROP_GAMMA, (*((float*)ScenarioVarPointers[_cameraGamma])));
			CameraCurrent_exposure = *((float*)ScenarioVarPointers[_cameraGamma]);
		}
		break;
	}

	case _reset_on_camera: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			reset_camera = true;
			// the camera weight is set to 1 in 10 frames
			delayedCameraWeight = 11;
		}
		break;
	}

	case _reset_camera_params: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			pg_initWebcamParameters();
		}
		break;
	}
#endif

	case _processing_video: {
		int argt0 = int(round(float_arguments[0]));
		sprintf(AuxString, "/video %d", argt0); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_Processing_send");
		printf("Processing message %s\n", AuxString);
		break;
	}
	case _processing_image: {
		int argt0 = int(round(float_arguments[0]));
		sprintf(AuxString, "/image %d", argt0); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_Processing_send");
		printf("Processing message %s\n", AuxString);
		break;
	}
	case _processing_master: {
		float argt0 = float_arguments[0];
		sprintf(AuxString, "/master %.2f", argt0); pg_send_message_udp((char*)"f", (char*)AuxString, (char*)"udp_Processing_send");
		printf("Processing message %s\n", AuxString);
		break;
	}

#if defined(PIERRES)
	case _TopLeft: {
		VP1KeystoneYTopLeft = -float_arguments[0] + 0;
		VP1KeystoneXTopLeft = float_arguments[1] + 0;
		updateXYKeystonePad();
		break;
	}
	case _BottomLeft: {
		VP1KeystoneYBottomLeft = -float_arguments[0] + 1.f;
		VP1KeystoneXBottomLeft = float_arguments[1] + 0;
		updateXYKeystonePad();
		break;
	}
	case _TopRight: {
		VP1KeystoneYTopRight = -float_arguments[0] + 0;
		VP1KeystoneXTopRight = float_arguments[1] + 1.f;
		updateXYKeystonePad();
		break;
	}
	case _BottomRight: {
		VP1KeystoneYBottomRight = -float_arguments[0] + 1.f;
		VP1KeystoneXBottomRight = float_arguments[1] + 1.f;
		updateXYKeystonePad();
		break;
	}
#endif


	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++ FLASHES BETWEEN LAYERS, CA & PARTICLES ++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
	case _flashPixel:
		flashPixel = flashPixel_duration;
		break;

	case _flashTrkPart:
		flashTrkPart_weights[currentDrawingTrack] = 1.f;
		flashTrkPart_weights_duration[currentDrawingTrack] = PG_FBO_PINGPONG_SIZE - 1;
		break;

	case _flashTrkCA:
		flashTrkCA_weights[currentDrawingTrack] = 1.f;
		flashTrkCA_weights_duration[currentDrawingTrack] = PG_FBO_PINGPONG_SIZE - 1;
		break;

	case _flashCABG:
		flashCABG_weight = 1.f;
		flashCABG_weight_duration = PG_FBO_PINGPONG_SIZE - 1;
		break;
	case _flashCAPart:
		flashCAPart_weight = 1.f;
		flashCAPart_weight_duration = PG_FBO_PINGPONG_SIZE - 1;
		break;

#if defined(var_master_scale) && defined(var_master_offsetX) && defined(var_master_offsetY) && defined(var_photo_diaporama)
	case _flashMaster:
		if (ScenarioVarConfigurations[_master_scale][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_master_offsetX][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_master_offsetY][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_photo_diaporama][pg_current_configuration_rank]) {
			master = 1.f;
			*((float*)ScenarioVarPointers[_master]) = master;
			master_scale = rand_0_1 * float_arguments[1] + 1;
			*((float*)ScenarioVarPointers[_master_scale]) = master_scale;
			master_offsetX = (rand_0_1 - 0.5f) * 300;
			*((float*)ScenarioVarPointers[_master_offsetX]) = master_offsetX;
			master_offsetY = (rand_0_1 - 0.5f) * 150;
			*((float*)ScenarioVarPointers[_master_offsetY]) = master_offsetY;
			photo_threshold = rand_0_1;
			*((float*)ScenarioVarPointers[_photo_threshold]) = photo_threshold;
			photo_gamma = rand_0_1;
			*((float*)ScenarioVarPointers[_photo_gamma]) = photo_gamma;
			photo_satur = rand_0_1;
			*((float*)ScenarioVarPointers[_photo_satur]) = photo_satur;
			invertAllLayers = (rand_0_1 > 0.5f);
			*((bool*)ScenarioVarPointers[_invertAllLayers]) = invertAllLayers;

			flashMaster = max(1, int(rand_0_1 * float_arguments[0]));
		}
		break;
#endif

#if defined(var_path_record_1)
	case _NextRecordReplayPath:
		if (float_arguments[0] > 0) {
			pg_NextRecordReplayPath();
		}
		break;
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ INTERFACE SELECTION +++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	//case _minimal_display: {
	//	pg_send_message_udp((char *)"i", (char *)"/minimal_display 1", (char *)"udp_TouchOSC_send");
	//	break;
	//}
	//case _paths_display: {
	//	pg_send_message_udp((char *)"i", (char *)"/paths_display 1", (char *)"udp_TouchOSC_send");
	//	break;
	//}

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ PEN POSITION ++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _new_scene: {
		if (pg_CurrentSceneIndex < 0) {
			pg_launch_performance(0);
		}
		else {
			StartNewScene(int(float_arguments[0]), 0);
		}
		break;
	}

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ PEN POSITION ++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
#if !defined(LIGHT)
	case _pen_xy: {
		CurrentMousePos_x[0] = int(workingWindow_width * float_arguments[0]);
		CurrentMousePos_y[0] = int(window_height * float_arguments[1]);
		sprintf(AuxString, "/pen_xy %.2f %.2f", float_arguments[0], float_arguments[1]); pg_send_message_udp((char*)"ff", (char*)AuxString, (char*)"udp_TouchOSC_send");
		break;
	}
	case _pen2_xy: {
		CurrentMousePos_x[1] = int(workingWindow_width * float_arguments[0]);
		CurrentMousePos_y[1] = int(window_height * float_arguments[1]);
		sprintf(AuxString, "/pen2_xy %.2f %.2f", float_arguments[0], float_arguments[1]); pg_send_message_udp((char*)"ff", (char*)AuxString, (char*)"udp_TouchOSC_send");
		break;
	}
	case _pen3_xy: {
		CurrentMousePos_x[2] = int(workingWindow_width * float_arguments[0]);
		CurrentMousePos_y[2] = int(window_height * float_arguments[1]);
		sprintf(AuxString, "/pen3_xy %.2f %.2f", float_arguments[0], float_arguments[1]); pg_send_message_udp((char*)"ff", (char*)AuxString, (char*)"udp_TouchOSC_send");
		break;
	}
	case _pen4_xy: {
		CurrentMousePos_x[3] = int(workingWindow_width * float_arguments[0]);
		CurrentMousePos_y[3] = int(window_height * float_arguments[1]);
		sprintf(AuxString, "/pen4_xy %.2f %.2f", float_arguments[0], float_arguments[1]); pg_send_message_udp((char*)"ff", (char*)AuxString, (char*)"udp_TouchOSC_send");
		break;
	}
	case _pen5_xy: {
		CurrentMousePos_x[4] = int(workingWindow_width * float_arguments[0]);
		CurrentMousePos_y[4] = int(window_height * float_arguments[1]);
		sprintf(AuxString, "/pen5_xy %.2f %.2f", float_arguments[0], float_arguments[1]); pg_send_message_udp((char*)"ff", (char*)AuxString, (char*)"udp_TouchOSC_send");
		break;
	}
	case _abs_pen_xy: {
		CurrentMousePos_x[0] = int(float_arguments[0]);
		CurrentMousePos_y[0] = int(float_arguments[1]);
		// printf("pos %.2f %.2f\n", float_arguments[0], float_arguments[1]);
		break;
	}
#endif
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ TRACK COPY +++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _copyTrack_above: {
		copyToNextTrack = +1;
		//sprintf(AuxString, "/message copy_track_%d_to_%d",
		//	currentDrawingTrack, (currentDrawingTrack + 1) % PG_NB_TRACKS);
		//pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");

		break;
	}
	case _copyTrack_under: {
		copyToNextTrack = -1;
		//sprintf(AuxString, "/message copy_track_%d_to_%d", 
		//	currentDrawingTrack , (currentDrawingTrack - 1 + PG_NB_TRACKS) % PG_NB_TRACKS); 
		//pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");


		break;
	}

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ PART EXIT/STROKE/COLOR MODE +++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
#if defined(var_partStroke_mode)
	case _partStroke_mode_0: {
		if (ScenarioVarConfigurations[_partStroke_mode][pg_current_configuration_rank]) {
			*((int*)ScenarioVarPointers[_partStroke_mode]) = 0;

			for (int ind = 0; ind < 3; ind++) {
				if (ind == *((int*)ScenarioVarPointers[_partStroke_mode])) {
					sprintf(AuxString, "/partStroke_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partStroke_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
	case _partStroke_mode_1: {
		if (ScenarioVarConfigurations[_partStroke_mode][pg_current_configuration_rank]) {
			*((int*)ScenarioVarPointers[_partStroke_mode]) = 1;

			for (int ind = 0; ind < 3; ind++) {
				if (ind == *((int*)ScenarioVarPointers[_partStroke_mode])) {
					sprintf(AuxString, "/partStroke_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partStroke_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
	case _partStroke_mode_2: {
		if (ScenarioVarConfigurations[_partStroke_mode][pg_current_configuration_rank]) {
			*((int*)ScenarioVarPointers[_partStroke_mode]) = 2;

			for (int ind = 0; ind < 3; ind++) {
				if (ind == *((int*)ScenarioVarPointers[_partStroke_mode])) {
					sprintf(AuxString, "/partStroke_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partStroke_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
#endif
#if defined(var_partColor_mode)
	case _partColor_mode_0: {
		if (ScenarioVarConfigurations[_partColor_mode][pg_current_configuration_rank]) {
			*((int*)ScenarioVarPointers[_partColor_mode]) = 0;

			for (int ind = 0; ind < 3; ind++) {
				if (ind == *((int*)ScenarioVarPointers[_partColor_mode])) {
					sprintf(AuxString, "/partColor_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partColor_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
	case _partColor_mode_1: {
		if (ScenarioVarConfigurations[_partColor_mode][pg_current_configuration_rank]) {
			*((int*)ScenarioVarPointers[_partColor_mode]) = 1;

			for (int ind = 0; ind < 3; ind++) {
				if (ind == *((int*)ScenarioVarPointers[_partColor_mode])) {
					sprintf(AuxString, "/partColor_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partColor_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
	case _partColor_mode_2: {
		if (ScenarioVarConfigurations[_partColor_mode][pg_current_configuration_rank]) {
			*((int*)ScenarioVarPointers[_partColor_mode]) = 2;

			for (int ind = 0; ind < 3; ind++) {
				if (ind == *((int*)ScenarioVarPointers[_partColor_mode])) {
					sprintf(AuxString, "/partColor_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partColor_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
#endif
#if defined(var_partExit_mode)
	case _partExit_mode_0: {
		if (ScenarioVarConfigurations[_partExit_mode][pg_current_configuration_rank]) {
			*((int*)ScenarioVarPointers[_partExit_mode]) = 0;

			for (int ind = 0; ind < 3; ind++) {
				if (ind == *((int*)ScenarioVarPointers[_partExit_mode])) {
					sprintf(AuxString, "/partExit_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partExit_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
	case _partExit_mode_1: {
		if (ScenarioVarConfigurations[_partExit_mode][pg_current_configuration_rank]) {
			*((int*)ScenarioVarPointers[_partExit_mode]) = 1;

			for (int ind = 0; ind < 3; ind++) {
				if (ind == *((int*)ScenarioVarPointers[_partExit_mode])) {
					sprintf(AuxString, "/partExit_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partExit_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
	case _partExit_mode_2: {
		if (ScenarioVarConfigurations[_partExit_mode][pg_current_configuration_rank]) {
			*((int*)ScenarioVarPointers[_partExit_mode]) = 2;

			for (int ind = 0; ind < 3; ind++) {
				if (ind == *((int*)ScenarioVarPointers[_partExit_mode])) {
					sprintf(AuxString, "/partExit_mode_%d 1", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
				else {
					sprintf(AuxString, "/partExit_mode_%d 0", ind); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
#endif

#ifdef PG_WITH_BLUR
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ BLUR +++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _is_blur_1: {
		is_blur_1 = true;
		nb_blur_frames_1 = 1;
		break;
	}
	case _is_blur_1_plus: {
		is_blur_1 = true;
		nb_blur_frames_1 = 3;
		break;
	}
	case _is_blur_1_plus_plus: {
		is_blur_1 = true;
		nb_blur_frames_1 = 10;
		break;
	}
	case _is_blur_2: {
		is_blur_2 = true;
		nb_blur_frames_2 = 1;
		break;
	}
#endif


#if defined(var_cameraCaptFreq)
				   // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ CAMERA IMAGE CUMUL MODE +++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _cameraCumul_plus: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			cameraCumul = (cameraCumul + 1) % PG_NB_CAMERA_CUMUL_MODES;
			BrokenInterpolationVar[_cameraCumul] = true;
		}
		break;
	}
#endif 

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ BRUSH ID SHIFT ++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _pen_brush_plus:
		if (nb_pen_brushes[pg_current_configuration_rank] > 0) {
			pen_brush = (pen_brush + 1) % (nb_pen_brushes[pg_current_configuration_rank] * 3);
			BrokenInterpolationVar[_pen_brush] = true;
			if (pen_brush >= 1) { // large radius for the image brushes
				pen_radiusMultiplier = 50.0f;
#if defined(FORET) || defined(CORE)
				pen_radiusMultiplier = 1.0f;
#endif
			}
			else {
				pen_radiusMultiplier = 1.0f;
			}

		}
		break;
	case _pen_brush_minus:
		if (nb_pen_brushes[pg_current_configuration_rank] > 0) {
			pen_brush = (pen_brush - 1 + (nb_pen_brushes[pg_current_configuration_rank] * 3)) % (nb_pen_brushes[pg_current_configuration_rank] * 3);
			BrokenInterpolationVar[_pen_brush] = true;
			if (pen_brush >= 1) { // large radius for the image brushes
				pen_radiusMultiplier = 50.0f;
#if defined(FORET) || defined(CORE)
				pen_radiusMultiplier = 1.0f;
#endif
			}
			else {
				pen_radiusMultiplier = 1.0f;
			}

		}
		break;

	case _pen_brush_replay_plus:
		pen_brush_replay += 1;
		*((int*)ScenarioVarPointers[_pen_brush_replay]) = pen_brush_replay;
		break;
	case _pen_brush_replay_minus:
		pen_brush_replay -= 1;
		*((int*)ScenarioVarPointers[_pen_brush_replay]) = pen_brush_replay;
		break;

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ PIXEL MODE +++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	case _pixel_mode_plus: {
		pixel_mode = (pixel_mode + 1) % PG_NB_PIXEL_MODES;
		BrokenInterpolationVar[_pixel_mode] = true;
		break;
	}

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ CA TYPE AND SUBTYPE +++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
#if defined(var_nb_CATypes)
	case _CA1Type_plus: {
		if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]) {
			CA1Type = (CA1Type + 1) % nb_CATypes;
			BrokenInterpolationVar[_CA1Type] = true;
			// printf("CA1Type %d\n", CA1Type);
			*((int*)ScenarioVarPointers[_CA1Type]) = CA1Type;
		}
		break;
	}
	case _CA1Type_minus: {
		if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]) {
			CA1Type = (CA1Type - 1 + nb_CATypes) % nb_CATypes;
			BrokenInterpolationVar[_CA1Type] = true;
			// printf("CA1Type %d\n", CA1Type);
			*((int*)ScenarioVarPointers[_CA1Type]) = CA1Type;
		}
		break;
	}
	case _CA1SubType_plus: {
		if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]) {
			CA1SubType = (CA1SubType + 1) % PG_NB_CA_SUBTYPES;
			BrokenInterpolationVar[_CA1SubType] = true;
			*((int*)ScenarioVarPointers[_CA1SubType]) = CA1SubType;
		}
		break;
	}
	case _CA1SubType_minus: {
		if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]) {
			CA1SubType = (CA1SubType - 1 + PG_NB_CA_SUBTYPES) % PG_NB_CA_SUBTYPES;
			BrokenInterpolationVar[_CA1SubType] = true;
			*((int*)ScenarioVarPointers[_CA1SubType]) = CA1SubType;
		}
		break;
	}
	case _CAonOff: {
		if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]) {
			if (CA1SubType != 0) {
				CASubTypeMem = CA1SubType;
				CA1SubType = 0;
			}
			else {
				CA1SubType = CASubTypeMem;
			}
			BrokenInterpolationVar[_CA1SubType] = true;
			printf("CA1SubType ON/OFF %d\n", CA1SubType);
			*((int*)ScenarioVarPointers[_CA1SubType]) = CA1SubType;
		}
		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ SENSOR LAYOUT AND SAMPLES +++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
#if defined(var_sensor_layout)
	case _sensor_layout_plus: {
		if (ScenarioVarConfigurations[_sensor_layout][pg_current_configuration_rank]) {
			if (ScenarioVarConfigurations[_sensor_layout][pg_current_configuration_rank]) {
				sensor_layout = (sensor_layout + 1) % PG_NB_MAX_SENSOR_LAYOUTS;
				BrokenInterpolationVar[_sensor_layout] = true;
				assignSensorPositions();
			}
		}
		break;
	}
	case _sensor_sample_setUp_plus: {
		if (ScenarioVarConfigurations[_sensor_layout][pg_current_configuration_rank]) {
			if (ScenarioVarConfigurations[_sensor_layout][pg_current_configuration_rank]) {
				sensor_sample_setUp = (sensor_sample_setUp + 1);
				if (sensor_sample_setUp >= PG_NB_MAX_SAMPLE_SETUPS) {
					sensor_sample_setUp -= PG_NB_MAX_SAMPLE_SETUPS;
				}
				BrokenInterpolationVar[_sensor_sample_setUp] = true;
				sensor_sample_setUp_interpolation();
			}
		}
		break;
	}
	case _sensor_activation_plus: {
		if (ScenarioVarConfigurations[_sensor_layout][pg_current_configuration_rank]) {
			if (ScenarioVarConfigurations[_sensor_layout][pg_current_configuration_rank]) {
				sensor_activation = (sensor_activation + 1) % PG_NB_MAX_SENSOR_ACTIVATIONS;
				BrokenInterpolationVar[_sensor_activation] = true;
				assignSensorActivations();
			}
		}
		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ PARTICLE MODES ++++++++++++++++++++++++
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
#if defined(var_partExit_mode)
	case _partExit_mode_plus: {
		if (ScenarioVarConfigurations[_partExit_mode][pg_current_configuration_rank]) {
			partExit_mode = (partExit_mode + 1) % PG_NB_PARTEXIT_MODES;
			BrokenInterpolationVar[_partExit_mode] = true;
		}
		break;
	}
#endif
#if defined(var_partStroke_mode)
	case _partStroke_mode_plus: {
		if (ScenarioVarConfigurations[_partStroke_mode][pg_current_configuration_rank]) {
			partStroke_mode = (partStroke_mode + 1) % PG_NB_PARTSTROKE_MODES;
			BrokenInterpolationVar[_partStroke_mode] = true;
		}
		break;
	}
#endif
#if defined(var_partColor_mode)
	case _partColor_mode_plus: {
		if (ScenarioVarConfigurations[_partColor_mode][pg_current_configuration_rank]) {
			partColor_mode = (partColor_mode + 1) % PG_NB_PARTCOLOR_MODES;
			BrokenInterpolationVar[_partColor_mode] = true;
		}
		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ B/W SWITCH ++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
	case _pen_BW: {
#if defined(var_pen_grey)
		if (ScenarioVarConfigurations[_pen_grey][pg_current_configuration_rank]) {
			if (pen_grey > 0) {
					pen_grey = 0.0f;
			}								
			else {
				pen_grey = 1.0f;
			}
			BrokenInterpolationVar[_pen_grey] = true;
		}
#endif
#if defined(var_pen_value)
		if (ScenarioVarConfigurations[_pen_value][pg_current_configuration_rank]) {

			if (pen_value > 0) {
				pen_value = 0.0f;
			}
			else {
				pen_value = 1.0f;
			}
			BrokenInterpolationVar[_pen_value] = true;
		}
#endif
		break;
	}
	case _repopBG_BW: {
		if (repop_greyBG > 0) {
			repop_greyBG = 0.0f;
		}
		else {
			repop_greyBG = 1.0f;
		}
		BrokenInterpolationVar[_repop_greyBG] = true;
		// printf("repop color %.1f\n", repop_grey);
		break;
	}
#if defined(var_nb_CATypes)
	case _repopCA_BW: {
		if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]) {
			if (repop_greyCA > 0) {
				repop_greyCA = 0.0f;
			}
			else {
				repop_greyCA = 1.0f;
			}
			BrokenInterpolationVar[_repop_greyCA] = true;
			// printf("repop color %.1f\n", repop_grey);
		}
		break;
	}
#endif
#if defined(var_part_initialization)
	case _repopPart_BW: {
		if (ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank]) {
#if defined(var_repop_greyPart)
			if (ScenarioVarConfigurations[_repop_greyPart][pg_current_configuration_rank]) {
				if (repop_greyPart > 0) {
					repop_greyPart = 0.0f;
				}
				else {
					repop_greyPart = 1.0f;
				}
				BrokenInterpolationVar[_repop_greyPart] = true;
			}
#endif
#if defined(var_repop_valuePart)
			if (ScenarioVarConfigurations[_repop_valuePart][pg_current_configuration_rank]) {
				if (repop_valuePart > 0) {
					repop_valuePart = 0.0f;
				}
				else {
					repop_valuePart = 1.0f;
				}
				BrokenInterpolationVar[_repop_valuePart] = true;
			}
#endif
			// printf("repop color %.1f\n", repop_grey);
		}
		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ PRESSURE SWITCH +++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
	case _pressure_onOff: {
#define PG_PRESSURE_STANDARD 10.0f
		if (pen_radius_pressure_coef > 0) {
			pen_radius_pressure_coef = 0.0f;
		}
		else {
			pen_radius_pressure_coef = PG_PRESSURE_STANDARD;
		}
		BrokenInterpolationVar[_pen_radius_pressure_coef] = true;
		break;
	}


	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ DIAPORAMA +++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
#if defined(var_photo_diaporama)
	case _diaporama_random: {
			if (ScenarioVarConfigurations[_photo_diaporama][pg_current_configuration_rank]) {
				diaporama_random();
			}
		}
		break;
	case _diaporama_plus: {
		if (ScenarioVarConfigurations[_photo_diaporama][pg_current_configuration_rank]) {
			if (pg_nbCompressedImageDirs[pg_current_configuration_rank] > 0) {
				// goes to the first photo diaporama if it is not already selected and if there is one 
				if (photo_diaporama < 0 && nb_photo_albums[pg_current_configuration_rank] > 0) {
					photo_diaporama = 0;
				}
				pg_CurrentDiaporamaDir = (pg_CurrentDiaporamaDir + 1) % pg_nbCompressedImageDirs[pg_current_configuration_rank];
				//printf("pg_CurrentDiaporamaDir %d\n", pg_CurrentDiaporamaDir);
				sprintf(AuxString, "/diaporama_shortName %03d", pg_CurrentDiaporamaDir);
				pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
				pg_launch_diaporama();
			}
		}
		break;
	}

	case _diaporama_minus: {
		if (ScenarioVarConfigurations[_photo_diaporama][pg_current_configuration_rank]) {
			if (pg_nbCompressedImageDirs[pg_current_configuration_rank] > 0) {
				pg_CurrentDiaporamaDir = (pg_CurrentDiaporamaDir - 1 + pg_nbCompressedImageDirs[pg_current_configuration_rank]) % pg_nbCompressedImageDirs[pg_current_configuration_rank];
				//printf("pg_CurrentDiaporamaDir %d\n", pg_CurrentDiaporamaDir);
				sprintf(AuxString, "/diaporama_shortName %03d", pg_CurrentDiaporamaDir);
				pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
				pg_launch_diaporama();
			}
		}
		break;
	}
	case _flash_photo_diaporama: {
		if (ScenarioVarConfigurations[_photo_diaporama][pg_current_configuration_rank]) {
			if (pg_nbCompressedImageDirs[pg_current_configuration_rank] > 0 && float_arguments[0] >= 0) {
				pg_CurrentDiaporamaDir = int(float_arguments[0]) % pg_nbCompressedImageDirs[pg_current_configuration_rank];
				pg_CurrentDiaporamaEnd = float_arguments[1] + pg_CurrentClockTime;
				photoWeight = 1.f;
				printf("flash_photo_diaporama %d %.2f %d\n", int(float_arguments[0]), float_arguments[1], pg_FrameNo);
				sprintf(AuxString, "/diaporama_shortName %03d", pg_CurrentDiaporamaDir); pg_send_message_udp((char*)"s", AuxString, (char*)"udp_TouchOSC_send");
				pg_launch_diaporama();
			}
		}
		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ TRACK NO ++++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
#if defined(PG_WITH_JUCE) || defined(PG_WITH_PUREDATA) || defined(PG_WITH_PORTAUDIO)
	case _soundtrack_plus: {
		if (nb_soundtracks[pg_current_configuration_rank] > 0) {
			if (currentlyPlaying_trackNo < 0) {
				PlayTrack(0, 0.);
			}
			else {
				PlayTrack((currentlyPlaying_trackNo + 1) % nb_soundtracks[pg_current_configuration_rank], 0.);
			}
			BrokenInterpolationVar[_playing_soundtrackNo] = true;
			*((int *)ScenarioVarPointers[_playing_soundtrackNo]) = currentlyPlaying_trackNo;
		}
		break;
	}
	case _soundtrack_minus: {
		if (nb_soundtracks[pg_current_configuration_rank] > 0) {
			if (currentlyPlaying_trackNo < 0) {
				PlayTrack(0, 0.);
			}
			else {
				PlayTrack((currentlyPlaying_trackNo + nb_soundtracks[pg_current_configuration_rank] - 1) % nb_soundtracks[pg_current_configuration_rank], 0.);
			}
			BrokenInterpolationVar[_playing_soundtrackNo] = true;
			*((int*)ScenarioVarPointers[_playing_soundtrackNo]) = currentlyPlaying_trackNo;
		}
		break;
	}
	case _soundtrack_seek: {
		int soundTrack_no = int(float_arguments[0]);
		double seek_position = 0.;
		if (nb_arguments >= 2) {
			seek_position = double(float_arguments[1]);
		}

		// seek inside the current track or a new track
		if (soundTrack_no >= 0 && soundTrack_no < nb_soundtracks[pg_current_configuration_rank]) {
			if (currentlyPlaying_trackNo != soundTrack_no) {
				printf("soundtrack_seek: currentlyPlaying_trackNo %d != soundTrack_no %d\n", currentlyPlaying_trackNo, soundTrack_no);
				StopTrack();
				BrokenInterpolationVar[_playing_soundtrackNo] = true;
				*((int*)ScenarioVarPointers[_playing_soundtrackNo]) = soundTrack_no;
				currentlyPlaying_trackNo = soundTrack_no;
			}
			PlayTrack(currentlyPlaying_trackNo, seek_position);
		}
		// stop playing a track
		else if (soundTrack_no < 0) {
			if (playing_soundtrackNo >= 0) {
				printf("soundtrack_seek: playing_soundtrackNo neg %d\n", soundTrack_no);
				StopTrack();
			}
			BrokenInterpolationVar[_playing_soundtrackNo] = true;
			*((int*)ScenarioVarPointers[_playing_soundtrackNo]) = -1;
			currentlyPlaying_trackNo = -1;
		}
		break;
	}
	case _soundtrack_onOff: {
		soundTrack_on = !soundTrack_on;
		soundTrackonOff();
		break;
	}
	case _soundtrack_volume: {
		soundTrack_on = (float_arguments[0] > 0);
		soundTrackvolume(float_arguments[0]);
		break;
	}
#endif

#if defined(var_movieCaptFreq)
	case _movie_loop_onOff: {
		if (ScenarioVarConfigurations[_movieCaptFreq][pg_current_configuration_rank]) {
			movie_loop = !movie_loop;
			sprintf(AuxString, "/movie_loop_onOff %d", int(movie_loop));
			pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
			printf("Movie loop On/Off %d\n", int(movie_loop));
		}
		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ PALETTE NO ++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
#if defined(var_pen_color)
	case _pen_colorPreset_minus: {
		if (ScenarioVarConfigurations[_pen_color][pg_current_configuration_rank]) {
			if (nb_pen_colorPresets[pg_current_configuration_rank] > 0) {
				current_pen_colorPreset = (current_pen_colorPreset - 1 + nb_pen_colorPresets[pg_current_configuration_rank]) % nb_pen_colorPresets[pg_current_configuration_rank];
				// printf( "/new palette %d\n", current_pen_colorPreset);
				BrokenInterpolationVar[_pen_color] = true;
				*((float*)ScenarioVarPointers[_pen_color]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].color;
				BrokenInterpolationVar[_pen_grey] = true;
				*((float*)ScenarioVarPointers[_pen_grey]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].grey;
				BrokenInterpolationVar[_pen_color_a] = true;
				*((float*)ScenarioVarPointers[_pen_color_a]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].alpha;
				// sprintf(AuxString, "/pen_color %.3f", pen_colorPresets_values[current_pen_colorPreset]);
				// pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
				// sprintf(AuxString, "/message palette%s", pen_colorPresets_names[current_pen_colorPreset].c_str()); pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");
				sprintf(AuxString, "/pen_colorPreset %d", current_pen_colorPreset); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
			}
		}

		break;
	}
	case _pen_colorPreset_plus: {
		if (ScenarioVarConfigurations[_pen_color][pg_current_configuration_rank]) {
			if (nb_pen_colorPresets[pg_current_configuration_rank] > 0) {
				current_pen_colorPreset = (current_pen_colorPreset + 1) % nb_pen_colorPresets[pg_current_configuration_rank];
				BrokenInterpolationVar[_pen_color] = true;
				*((float*)ScenarioVarPointers[_pen_color]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].color;
				BrokenInterpolationVar[_pen_grey] = true;
				*((float*)ScenarioVarPointers[_pen_grey]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].grey;
				BrokenInterpolationVar[_pen_color_a] = true;
				*((float*)ScenarioVarPointers[_pen_color_a]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].alpha;
				// sprintf(AuxString, "/pen_color %.3f", pen_colorPresets_values[current_pen_colorPreset]);
				// pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
				// sprintf(AuxString, "/message palette%s", pen_colorPresets_names[current_pen_colorPreset].c_str()); pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");
				sprintf(AuxString, "/pen_colorPreset %d", current_pen_colorPreset); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
			}
		}
		break;
	}
	case _pen_colorPreset: {
		if (ScenarioVarConfigurations[_pen_color][pg_current_configuration_rank]) {
			int presetValue = int(float_arguments[0]);
			if (nb_pen_colorPresets[pg_current_configuration_rank] > 0) {
				current_pen_colorPreset = presetValue % nb_pen_colorPresets[pg_current_configuration_rank];
				BrokenInterpolationVar[_pen_color] = true;
				*((float*)ScenarioVarPointers[_pen_color]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].color;
				BrokenInterpolationVar[_pen_grey] = true;
				*((float*)ScenarioVarPointers[_pen_grey]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].grey;
				BrokenInterpolationVar[_pen_color_a] = true;
				*((float*)ScenarioVarPointers[_pen_color_a]) = pg_colorPreset_values[pg_current_configuration_rank][current_pen_colorPreset].alpha;
				// sprintf(AuxString, "/pen_color %.3f", pen_colorPresets_values[current_pen_colorPreset]);
				// pg_send_message_udp((char *)"s", AuxString, (char *)"udp_TouchOSC_send");
				// sprintf(AuxString, "/message palette%s", pen_colorPresets_names[current_pen_colorPreset].c_str()); pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");
				// printf("************* palette %d\n", current_pen_colorPreset);
				sprintf(AuxString, "/pen_colorPreset %d", current_pen_colorPreset); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
				printf("sent: %s\n", AuxString);
			}
		}
		break;
	}
#endif

#if defined(CAAUDIO) || defined(RIVETS)
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
	// +++++++++++++++++ CA SEEDING ++++++++++++++++++++++++++++
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 

	case _CAseed_dot_center: {
		pg_CAseed_type = _pg_CAseed_dot_center;
		sprintf(AuxString, "/CAseed_dot_center %d", 1); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_dot %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_h_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_v_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_cross %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_X %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_square %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		break;
	}
	case _CAseed_dot: {
		pg_CAseed_type = _pg_CAseed_dot;
		sprintf(AuxString, "/CAseed_dot_center %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_dot %d", 1); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_h_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_v_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_cross %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_X %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_square %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		break;
	}
	case _CAseed_h_line: {
		sprintf(AuxString, "/CAseed_dot_center %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_dot %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_h_line %d", 1); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_v_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_cross %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_X %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_square %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		pg_CAseed_type = _pg_CAseed_h_line;
		break;
	}
	case _CAseed_v_line: {
		sprintf(AuxString, "/CAseed_dot_center %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_dot %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_h_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_v_line %d", 1); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_cross %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_X %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_square %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		pg_CAseed_type = _pg_CAseed_v_line;
		break;
	}
	case _CAseed_cross: {
		sprintf(AuxString, "/CAseed_dot_center %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_dot %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_h_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_v_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_cross %d", 1); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_X %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_square %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		pg_CAseed_type = _pg_CAseed_cross;
		break;
	}
	case _CAseed_X: {
		sprintf(AuxString, "/CAseed_dot_center %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_dot %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_h_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_v_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_cross %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_X %d", 1); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_square %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		pg_CAseed_type = _pg_CAseed_X;
		break;
	}
	case _CAseed_square: {
		sprintf(AuxString, "/CAseed_dot_center %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_dot %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_h_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_v_line %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_cross %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_X %d", 0); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		sprintf(AuxString, "/CAseed_square %d", 1); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		pg_CAseed_type = _pg_CAseed_square;
		break;
	}
	case _CAseed_size: {
		pg_CAseed_size = int(float_arguments[0]);
		sprintf(AuxString, "/CAseed_size %d", pg_CAseed_size); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		break;
	}
	case _CAseed_loc: {
		pg_CAseed_location = pg_CAseed_locations(int(float_arguments[0]) % _pg_Nb_CAseed_locations);
		pg_CAseed_location_to_coordinates(pg_CAseed_location, pg_CAseed_coordinates);
		sprintf(AuxString, "/CAseed_loc %d", pg_CAseed_location); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		break;
	}
	case _CAseed_loc_plus: {
		pg_CAseed_location = pg_CAseed_locations((pg_CAseed_location + 1) % _pg_Nb_CAseed_locations);
		pg_CAseed_location_to_coordinates(pg_CAseed_location, pg_CAseed_coordinates);
		sprintf(AuxString, "/CAseed_loc %d", pg_CAseed_location); pg_send_message_udp((char *)"i", (char *)AuxString, (char *)"udp_TouchOSC_send");
		break;
	}
	case _CAseed_trigger: {
		pg_CAseed_trigger = true;
		break;
	}
#endif

#ifdef CRITON
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
	// +++++++++++++++++ SOUND CONTROL +++++++++++++++++++++++++
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
	case _JUCE_loop_track: {
		pg_send_message_udp((char *)"", (char *)"/JUCE_loop_track", (char *)"udp_SoundJUCE_send");
		break;
	}
	case _JUCE_exit: {
		pg_send_message_udp((char *)"", (char *)"/JUCE_exit", (char *)"udp_SoundJUCE_send");
		break;
	}
	case _fftLevel8: {
		//printf("fft levels: ");
		//for (int indArg = 0; indArg < 8; indArg++) {
		//	printf("%.2f/%.2f ", float_arguments[2 * indArg], float_arguments[2 * indArg + 1]);
		//}
		//printf("\n");
		float totFFTLevel = 0.f;
		for (int indArg = 0; indArg < 8; indArg++) {
			fftFrequencies[indArg] = float_arguments[3 * indArg];
			fftLevels[indArg] = float_arguments[3 * indArg + 1];
			fftPhases[indArg] = float_arguments[3 * indArg + 2];
			totFFTLevel += fftLevels[indArg];
		}
		// normalization of the levels (sum = 0.5 (because cos + 1 used for color))
		totFFTLevel *= 2.f;
		if (totFFTLevel > 0.f) {
			for (int indArg = 0; indArg < 8; indArg++) {
				fftLevels[indArg] /= totFFTLevel;
			}
		}
		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
	// +++++++++++++++++ MOVIE NO ++++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
#if defined(var_movieCaptFreq)
	case _movie_plus: {
		if (ScenarioVarConfigurations[_movieCaptFreq][pg_current_configuration_rank]) {
			if (nb_movies[pg_current_configuration_rank] > 0) {
				playing_movieNo = (playing_movieNo + 1) % nb_movies[pg_current_configuration_rank];
				pg_play_movie_no();
			}
		}
		break;
	}

	case _movie_minus: {
		if (ScenarioVarConfigurations[_movieCaptFreq][pg_current_configuration_rank]) {
			if (nb_movies[pg_current_configuration_rank] > 0) {
				playing_movieNo = (playing_movieNo - 1 + nb_movies[pg_current_configuration_rank]) % nb_movies[pg_current_configuration_rank];
				pg_play_movie_no();
			}
		}
		break;
	}

	// +++++++++++++++++ MOVIE FWD ++++++++++++++++++++++++++++++ 
	case _movie_forward: {
		if (ScenarioVarConfigurations[_movieCaptFreq][pg_current_configuration_rank]) {
			if (currentlyPlaying_movieNo >= 0) {
				pg_movie_forward(int(movieCaptFreq * 10));
			}
		}
		break;
	}
	case _movie_backward: {
		if (ScenarioVarConfigurations[_movieCaptFreq][pg_current_configuration_rank]) {
			if (currentlyPlaying_movieNo >= 0) {
				pg_movie_backward(int(movieCaptFreq * 10));
			}
		}
		break;
	}
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
	// +++++++++++++++++ CLIP NO ++++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
#if defined(var_cameraCaptFreq)
	case _camera_close: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			// release webCam
			if (pg_webCam_capture.isOpened()) {
				pg_webCam_capture.release();
			}
		}
		break;
	}
	case _camera_open: {
		if (ScenarioVarConfigurations[_cameraCaptFreq][pg_current_configuration_rank]) {
			// release webCam
			if (!pg_webCam_capture.isOpened() && cameraNo < 0 && -cameraNo - 1 < nb_webCam) {
				pg_openCameraCaptureAndLoadFrame();
			}
		}
		break;
	}
#endif
#if defined(var_clipCaptFreq)
	case _clip_plus: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			if (clipSide < _clipLR && clipSide >= 0 && pg_nbClips > 0) {
				for (int indClipRank = 0; indClipRank < PG_NB_PARALLEL_CLIPS; indClipRank++) {
					pg_play_clip_no(indClipRank, clipSide, (pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank) + 1) % pg_nbClips);
				}
			}
		}
		break;
	}

	case _clip_minus: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			if (clipSide < _clipLR && clipSide >= 0 && pg_nbClips > 0) {
				for (int indClipRank = 0; indClipRank < PG_NB_PARALLEL_CLIPS; indClipRank++) {
					pg_play_clip_no(indClipRank, clipSide, (pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank) - 1 + pg_nbClips) % pg_nbClips);
				}
			}
		}
		break;
	}

	// +++++++++++++++++ CLIP FWD ++++++++++++++++++++++++++++++ 
	case _clip_forward: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			for (int indClipRank = 0; indClipRank < PG_NB_PARALLEL_CLIPS; indClipRank++) {
				if (clipSide < _clipLR && clipSide >= 0 && pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank) >= 0) {
					pg_clip_status[clipSide].play_offset_position(indClipRank, +0.1);
				}
			}
		}
		break;
	}
	case _clip_backward: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			for (int indClipRank = 0; indClipRank < PG_NB_PARALLEL_CLIPS; indClipRank++) {
				if (clipSide < _clipLR && clipSide >= 0 && pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank) >= 0) {
					pg_clip_status[clipSide].play_offset_position(indClipRank, -0.1);
				}
			}
		}
		break;
	}
#endif

	// +++++++++++++++++ CLIP NUDGE AND SCRATCH ++++++++++++++++++ 
	// jog wheel controls with two arguments
	// x: position of the wheel on the circle (0 at 0 hour and 1 at 12 hours)
	// y: 1 for clockwise rotation, 0 for anticlockwise rotation

	// SCRATCHING
#if defined(var_clip_scratch_factor3)
	case _clip_scratch: {
		float angle_pos = 0.f;
		float prec_angle_pos = 0.f;
		double prec_angle_time = 0.;
		bool is_forward = true;
		int clipSide = int(float_arguments[0]);
		if (clipSide < _clipLR && clipSide >= 0) {
			if (nb_arguments >= 1) {
				angle_pos = float_arguments[1];
			}
			if (nb_arguments >= 2) {
				is_forward = (float_arguments[2] > 0.);
			}
			prec_angle_pos = pg_clip_status[clipSide].get_last_scratch_angle(&prec_angle_time);
			// it is not the first interaction after a release
			if (prec_angle_pos >= 0) {
				float delta_angle = angle_pos - prec_angle_pos;
				// if we go over noon, the angle difference should be increased by 1
				// for clockwise: e.g. angle_pos = 0.1 prec_angle_pos = 0.9 delta_angle = (0.1 -  0.9) + 1. = 0.2
				// otherwise delta_angle = 0.9 - 0.7 = 0.2
				if (is_forward && delta_angle < -0.5f) {
					delta_angle = delta_angle + 1.f;
				}
				// for anti-clockwise: e.g. angle_pos = 0.9 prec_angle_pos = 0.1 delta_angle = (0.9 -  0.1) - 1. = -0.2
				// otherwise delta_angle = 0.7 - 0.9 = -0.2
				else if (!is_forward && delta_angle > 0.5f) {
					delta_angle = delta_angle - 1.f;
				}
				pg_clip_status[clipSide].scratch_offset_position( delta_angle * clip_scratch_factor);
			}
			else {
				// pas d'incidence sur le jeu
			}
			pg_clip_status[clipSide].set_last_scratch_angle(angle_pos, pg_CurrentClockTime);
		}
		break;
	}
	case _clip_scratch_touch_press: {
		int clipSide = int(float_arguments[0]);
		if (clipSide < _clipLR && clipSide >= 0) {
			pg_clip_status[clipSide].set_last_scratch_angle(-1., pg_CurrentClockTime);
			pg_clip_status[clipSide].set_scratch_pressed(true);
		}
		break;
	}
	case _clip_scratch_touch_release: {
		int clipSide = int(float_arguments[0]);
		if (clipSide < _clipLR && clipSide >= 0) {
			pg_clip_status[clipSide].set_last_scratch_angle(-1., pg_CurrentClockTime);
			pg_clip_status[clipSide].set_scratch_pressed(false);
		}
		break;
	}
#endif
	// TEMPO BENDING
#if defined(var_clipCaptFreq) and defined(var_clip_nudge_factor)
	case _clip_nudge: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_clip_nudge_factor][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			for (int indClipRank = 0; indClipRank < PG_NB_PARALLEL_CLIPS; indClipRank++) {
				if (clipSide < _clipLR && clipSide >= 0 && pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank) >= 0) {
					float fps = clipCaptFreq;
					float mult_factor = 1.f;
					if (float_arguments[1] > 0.5f) {
						mult_factor = (1.f + (float_arguments[1] - 0.5f) * clip_nudge_factor);
					}
					else if (float_arguments[1] >= 0.f) {
						float div_factor = (1.f + (0.5f - float_arguments[1]) * clip_nudge_factor);
						if (div_factor != 0) {
							mult_factor = 1.f / div_factor;
						}
					}
					pg_clip_status[clipSide].set_currentFPS(fps * mult_factor);
				}
			}
		}
		break;
	}	 
	case _clip_nudge_touch_press: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_clip_nudge_factor][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			if (clipSide < _clipLR && clipSide >= 0) {
				pg_clip_status[clipSide].set_last_nudge_angle(-1., pg_CurrentClockTime);
			}
		}
		break;
	}
	case _clip_nudge_touch_release: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_clip_nudge_factor][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			if (clipSide < _clipLR && clipSide >= 0) {
				pg_clip_status[clipSide].set_last_nudge_angle(-1., pg_CurrentClockTime);
			}
		}
		break;
	}
#endif

#if defined(var_clipCaptFreq)
	// CUE MANAGEMENT
	case _clip_cue_onOff: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			if (clipSide < _clipLR && clipSide >= 0) {
				for (int indClipRank = 0; indClipRank < PG_NB_PARALLEL_CLIPS; indClipRank++) {
					int indClip = pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank);
					int indCue = int(float_arguments[1]);
					if (indClip >= 0 && indClip < pg_nbClips) {
						int cueFrame = pg_clip_tracks[indClip].set_cue_onOff(indCue, pg_clip_status[clipSide].get_lastFrame(indClipRank));
						// cue on
						if (cueFrame >= 0) {
							sprintf(AuxString, "/clip_cue_onOff_%d_%d_color 1. 0. 0.", clipSide, indCue);
							pg_send_message_udp((char*)"fff", AuxString, (char*)"udp_TouchOSC_send");
							sprintf(AuxString, "/clip_cue_onOff_%d_%d 1.", clipSide, indCue);
							pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						}
						// cue off
						else {
							sprintf(AuxString, "/clip_cue_onOff_%d_%d_color 0. 1. 1.", clipSide, indCue);
							pg_send_message_udp((char*)"fff", AuxString, (char*)"udp_TouchOSC_send");
							sprintf(AuxString, "/clip_cue_onOff_%d_%d 0.", clipSide, indCue);
							pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						}
					}
				}
			}
		}
		break;
	}
						// goto cue: makes a difference whether or not the clip is playing (jump vs call)
	case _clip_cue_jump: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			if (clipSide < _clipLR && clipSide >= 0) {
				int indClip = pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(0);
				//printf("cue jump indclip %d id=nd cue %d\n", indClip, int(float_arguments[1]));
				if (indClip >= 0 && indClip < pg_nbClips) {
					int cue_frame = pg_clip_tracks[indClip].get_cue(int(float_arguments[1]));
					//printf("cue jump frame %d/%d\n", cue_frame, pg_clip_tracks[indClip].get_initialNbFrames());
					if (cue_frame >= 0 && cue_frame < pg_clip_tracks[indClip].get_initialNbFrames()) {
						pg_clip_status[clipSide].set_position(0, cue_frame);
					}
				}
			}
		}
		break;
	}
#if PG_NB_PARALLEL_CLIPS >= 2
	case _clip2_cue_jump: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			if (clipSide < _clipLR && clipSide >= 0) {
				int indClip = pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(1);
				//printf("cue jump indclip %d id=nd cue %d\n", indClip, int(float_arguments[1]));
				if (indClip >= 0 && indClip < pg_nbClips) {
					int cue_frame = pg_clip_tracks[indClip].get_cue(int(float_arguments[1]));
					//printf("cue jump frame %d/%d\n", cue_frame, pg_clip_tracks[indClip].get_initialNbFrames());
					if (cue_frame >= 0 && cue_frame < pg_clip_tracks[indClip].get_initialNbFrames()) {
						pg_clip_status[clipSide].set_position(1, cue_frame);
					}
				}
			}
		}
		break;
	}
#endif
	// goto cue: makes a difference whether or not the clip is playing (jump vs call)
	case _clip_cue_call: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			int clipCueNo = int(float_arguments[1]);
			bool onOff = (float_arguments[2] == 1.f);
			if (clipSide < _clipLR && clipSide >= 0) {
				for (int indClipRank = 0; indClipRank < PG_NB_PARALLEL_CLIPS; indClipRank++) {
					int indClip = pg_clip_status[clipSide].getCurrentlyPlaying_clipNo(indClipRank);
					//printf("cue jump indclip %d id=nd cue %d\n", indClip, int(float_arguments[1]));
					if (indClip >= 0 && indClip < pg_nbClips) {
						int cue_frame = pg_clip_tracks[indClip].get_cue(int(float_arguments[1]));
						//printf("cue jump frame %d/%d\n", cue_frame, pg_clip_tracks[indClip].get_initialNbFrames());
						if (cue_frame >= 0 && cue_frame < pg_clip_tracks[indClip].get_initialNbFrames()) {
							//if (onOff) {
							pg_clip_status[clipSide].set_position(indClipRank, cue_frame);
							//	pg_clip_status[clipSide].clip_play[indClipRank] = true;
							//}
							//else {
							//	pg_clip_status[clipSide].clip_play[indClipRank] = false;
							//}
						}
					}
				}
			}
		}
		break;
	}
	
					   // FX
	case _clip_fx: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			int fxNo = int(float_arguments[1]);
			if (clipSide == _clipLeft) {
				switch (fxNo) {
				case 0:
					fx_dry_wet = float_arguments[2];
					// dry_wet
					break;
				case 1: {
					float val = float_arguments[2];
					if (val < 1.f / 3.f) {
						pg_clip_status[_clipLeft].clip_g_channel_level[0] = 0.f;
						pg_clip_status[_clipRight].clip_g_channel_level[0] = 0.f;
						pg_clip_status[_clipLeft].clip_r_channel_level[0] = 0.f;
						pg_clip_status[_clipRight].clip_r_channel_level[0] = 0.f;
						pg_clip_status[_clipLeft].clip_b_channel_level[0] = 1.f;
						pg_clip_status[_clipRight].clip_b_channel_level[0] = 1.f;
						pg_clip_status[_clipLeft].clip_g_channel_level[1] = 0.f;
						pg_clip_status[_clipRight].clip_g_channel_level[1] = 0.f;
						pg_clip_status[_clipLeft].clip_r_channel_level[1] = 0.f;
						pg_clip_status[_clipRight].clip_r_channel_level[1] = 0.f;
						pg_clip_status[_clipLeft].clip_b_channel_level[1] = 1.f;
						pg_clip_status[_clipRight].clip_b_channel_level[1] = 1.f;
					}
					else if (val < 2.f / 3.f) {
						pg_clip_status[_clipLeft].clip_b_channel_level[0] = 0.f;
						pg_clip_status[_clipRight].clip_b_channel_level[0] = 0.f;
						pg_clip_status[_clipLeft].clip_r_channel_level[0] = 0.f;
						pg_clip_status[_clipRight].clip_r_channel_level[0] = 0.f;
						pg_clip_status[_clipLeft].clip_g_channel_level[0] = 1.f;
						pg_clip_status[_clipRight].clip_g_channel_level[0] = 1.f;
						pg_clip_status[_clipLeft].clip_b_channel_level[1] = 0.f;
						pg_clip_status[_clipRight].clip_b_channel_level[1] = 0.f;
						pg_clip_status[_clipLeft].clip_r_channel_level[1] = 0.f;
						pg_clip_status[_clipRight].clip_r_channel_level[1] = 0.f;
						pg_clip_status[_clipLeft].clip_g_channel_level[1] = 1.f;
						pg_clip_status[_clipRight].clip_g_channel_level[1] = 1.f;
					}
					else {
						pg_clip_status[_clipLeft].clip_b_channel_level[0] = 0.f;
						pg_clip_status[_clipRight].clip_b_channel_level[0] = 0.f;
						pg_clip_status[_clipLeft].clip_g_channel_level[0] = 0.f;
						pg_clip_status[_clipRight].clip_g_channel_level[0] = 0.f;
						pg_clip_status[_clipLeft].clip_r_channel_level[0] = 1.f;
						pg_clip_status[_clipRight].clip_r_channel_level[0] = 1.f;
						pg_clip_status[_clipLeft].clip_b_channel_level[1] = 0.f;
						pg_clip_status[_clipRight].clip_b_channel_level[1] = 0.f;
						pg_clip_status[_clipLeft].clip_g_channel_level[1] = 0.f;
						pg_clip_status[_clipRight].clip_g_channel_level[1] = 0.f;
						pg_clip_status[_clipLeft].clip_r_channel_level[1] = 1.f;
						pg_clip_status[_clipRight].clip_r_channel_level[1] = 1.f;
					}
				}
					  break;
				case 2:
					echo = float_arguments[2];
					*((float*)ScenarioVarPointers[_echo]) = echo * fx_dry_wet;
					break;
				case 3:
					photo_gamma = float_arguments[2];
					*((float*)ScenarioVarPointers[_photo_gamma]) = photo_gamma * fx_dry_wet;
					break;
				}
			}
			else {
				switch (fxNo) {
				case 0:
					fx_dry_wet = float_arguments[2];
					// dry_wet
					break;
				case 1:
					flashTrkBG_freq_2 = max(0, min(9, int(floor(float_arguments[2] * 10 * fx_dry_wet))));
					*((int*)ScenarioVarPointers[_flashTrkBG_freq_2]) = flashTrkBG_freq_2;
					break;
				case 2:
					photo_satur = float_arguments[2];
					*((float*)ScenarioVarPointers[_photo_satur]) = photo_satur * fx_dry_wet;
					break;
				case 3:
					pg_clip_status[_clipLeft].jump_frame_freq = int(float_arguments[2] * 10 * fx_dry_wet);
					pg_clip_status[_clipRight].jump_frame_freq = int(float_arguments[2] * 10 * fx_dry_wet);
					break;
				}
			}
		}
		break;
	}

				 // FX
	case _clip_fx_std: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int fxNo = int(float_arguments[0]);
			switch (fxNo) {
			case 0:
				repop_part = 1.f - repop_part;
				*((float*)ScenarioVarPointers[_repop_part]) = repop_part;
				break;
			case 1:
				pixel_radius = 1.f - pixel_radius;
				*((float*)ScenarioVarPointers[_pixel_radius]) = pixel_radius;
				break;
			case 2:
				pixel_acc = 0.0001f;
				*((float*)ScenarioVarPointers[_pixel_acc]) = pixel_acc;
				break;
			case 3:
				CAdecay = 0.f;
				*((float*)ScenarioVarPointers[_CAdecay]) = CAdecay;
				break;
			case 4:
				part_size_pulse = 0.5f;
				*((float*)ScenarioVarPointers[_part_size_pulse]) = part_size_pulse;
				break;
			}
		}
		break;
	}
				 // EQ
	case _clip_equalizer: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			if (nb_arguments == 3) {
				int eqNo = int(float_arguments[1]);
				if (clipSide < _clipLR && clipSide >= 0) {
					switch (eqNo) {
					case 0:
						pg_clip_status[clipSide].clip_r_channel_level[0] = float_arguments[2];
						sprintf(AuxString, "/clip_eq_red %.2f", pg_clip_status[clipSide].clip_r_channel_level[0]);
						pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						break;
					case 1:
						pg_clip_status[clipSide].clip_g_channel_level[0] = float_arguments[2];
						sprintf(AuxString, "/clip_eq_green %.2f", pg_clip_status[clipSide].clip_g_channel_level[0]);
						pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						break;
					case 2:
						pg_clip_status[clipSide].clip_b_channel_level[0] = float_arguments[2];
						sprintf(AuxString, "/clip_eq_blue %.2f", pg_clip_status[clipSide].clip_b_channel_level[0]);
						pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						break;
					}
				}
			}
			else if (nb_arguments == 4) {
				int clipSide = int(float_arguments[0]);
				if (clipSide < _clipLR && clipSide >= 0) {
					pg_clip_status[clipSide].clip_r_channel_level[0] = float_arguments[1];
					pg_clip_status[clipSide].clip_g_channel_level[0] = float_arguments[2];
					pg_clip_status[clipSide].clip_b_channel_level[0] = float_arguments[3];
					sprintf(AuxString, "/clip_eq_red %.2f", pg_clip_status[clipSide].clip_r_channel_level[0]);
					pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
					sprintf(AuxString, "/clip_eq_green %.2f", pg_clip_status[clipSide].clip_g_channel_level[0]);
					pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
					sprintf(AuxString, "/clip_eq_blue %.2f", pg_clip_status[clipSide].clip_b_channel_level[0]);
					pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
#if PG_NB_PARALLEL_CLIPS >= 2
	// EQ
	case _clip2_equalizer: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			if (nb_arguments == 3) {
				int eqNo = int(float_arguments[1]);
				if (clipSide < _clipLR && clipSide >= 0) {
					switch (eqNo) {
					case 0:
						pg_clip_status[clipSide].clip_r_channel_level[1] = float_arguments[2];
						sprintf(AuxString, "/clip_eq_red %.2f", pg_clip_status[clipSide].clip_r_channel_level[1]);
						pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						break;
					case 1:
						pg_clip_status[clipSide].clip_g_channel_level[1] = float_arguments[2];
						sprintf(AuxString, "/clip_eq_green %.2f", pg_clip_status[clipSide].clip_g_channel_level[1]);
						pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						break;
					case 2:
						pg_clip_status[clipSide].clip_b_channel_level[1] = float_arguments[2];
						sprintf(AuxString, "/clip_eq_blue %.2f", pg_clip_status[clipSide].clip_b_channel_level[1]);
						pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
						break;
					}
				}
			}
			else if (nb_arguments == 4) {
				int clipSide = int(float_arguments[0]);
				if (clipSide < _clipLR && clipSide >= 0) {
					pg_clip_status[clipSide].clip_r_channel_level[1] = float_arguments[1];
					pg_clip_status[clipSide].clip_g_channel_level[1] = float_arguments[2];
					pg_clip_status[clipSide].clip_b_channel_level[1] = float_arguments[3];
					sprintf(AuxString, "/clip_eq_red %.2f", pg_clip_status[clipSide].clip_r_channel_level[1]);
					pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
					sprintf(AuxString, "/clip_eq_green %.2f", pg_clip_status[clipSide].clip_g_channel_level[1]);
					pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
					sprintf(AuxString, "/clip_eq_blue %.2f", pg_clip_status[clipSide].clip_b_channel_level[1]);
					pg_send_message_udp((char*)"f", AuxString, (char*)"udp_TouchOSC_send");
				}
			}
		}
		break;
	}
#endif
	// NEW RANDOM CLIP
	case _clip_new: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			clip_new(0, clipSide, nb_arguments, float_arguments);
		}
		break;
	}
#if PG_NB_PARALLEL_CLIPS >= 2
	case _clip2_new: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			clip_new(1, clipSide, nb_arguments, float_arguments);
		}
		break;
	}
#endif

	// NEW SELECTED CLIP
	case _clip_sample: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			int clip_no = int(float_arguments[1]);
			if (clipSide < _clipLR && clipSide >= 0 && pg_nbClips > 0 && clip_no >= 0) {
				clip_no = clip_no % pg_nbClips;
				pg_play_clip_no(0, clipSide, clip_no);

			}
		}
		break;
	}
	// CLIP IS SELECTED IN A RANGE (BEGIN AND END OF RANGE ARE INCLUDED)
	case _clip_sample_range: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			int clipRank = int(float_arguments[1]);
			int clip_no_low = int(float_arguments[2]);
			int clip_no_high = int(float_arguments[3]);
			int clip_no = clip_no_low + int(rand_0_1 * (clip_no_high - clip_no_low + 1)) % (clip_no_high - clip_no_low + 1);
			clip_no = max(min(clip_no, clip_no_high), clip_no_low) % pg_nbClips;
			if (clipSide < _clipLR && clipSide >= 0 && clipRank < PG_NB_PARALLEL_CLIPS && clipRank >= 0 && pg_nbClips > 0 && clip_no >= 0) {
				clip_no = clip_no % pg_nbClips;
				pg_play_clip_no(clipRank, clipSide, clip_no);
			}
		}
		break;
	}
#if PG_NB_PARALLEL_CLIPS >= 2
   // NEW SELECTED CLIP IN CASE OF TWO DECKS ON EACH SIDE
	case _clip2_sample: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			int clip_no = int(float_arguments[1]);
			if (clipSide < _clipLR && clipSide >= 0 && pg_nbClips > 0 && clip_no >= 0) {
				clip_no = clip_no % pg_nbClips;
				pg_play_clip_no(1, clipSide, clip_no);

			}
		}
		break;
	}
#endif
	// LEFT OR RIGHT CLIP FADE IN/OUT
	case _clip_fader: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
			if (clipSide < _clipLR && clipSide >= 0) {
				// pg_clip_status[clipSide].clip_level[0] = float_arguments[1];
			}
		}
		break;
	}
#if PG_NB_PARALLEL_CLIPS >= 2
	case _clip2_fader: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			int clipSide = int(float_arguments[0]);
		if (clipSide < _clipLR && clipSide >= 0) {
			// pg_clip_status[clipSide].clip_level[1] = float_arguments[1];
		}
		break;
	}
#endif
	// CLIP PLAY STOP
	case _clip_autoplay_left: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			pg_clip_status[_clipLeft].clip_autoplay[0] = (float_arguments[0] == 1.f);
		}
		break;
	}
	case _clip_autoplay_right: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			pg_clip_status[_clipRight].clip_autoplay[0] = (float_arguments[0] == 1.f);
		}
		break;
	}
	case _clip_play_left: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			pg_clip_status[_clipLeft].clip_play[0] = (float_arguments[0] == 1.f);
			if (pg_clip_status[_clipLeft].clip_play[0]) {
				pg_clip_status[_clipLeft].set_lastPlayedFrameTime(0, pg_CurrentClockTime);
			}
		}
		break;
	}
	case _clip_play_right: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			pg_clip_status[_clipRight].clip_play[0] = (float_arguments[0] == 1.f);
			if (pg_clip_status[_clipRight].clip_play[0]) {
				pg_clip_status[_clipRight].set_lastPlayedFrameTime(0, pg_CurrentClockTime);
			}
		}
		break;
	}
#if PG_NB_PARALLEL_CLIPS >= 2
	case _clip2_autoplay_left: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			pg_clip_status[_clipLeft].clip_autoplay[1] = (float_arguments[0] == 1.f);
		}
		break;
	}
	case _clip2_autoplay_right: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			pg_clip_status[_clipRight].clip_autoplay[1] = (float_arguments[0] == 1.f);
		}
		break;
	}
	case _clip2_play_left: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			pg_clip_status[_clipLeft].clip_play[1] = (float_arguments[0] == 1.f);
			if (pg_clip_status[_clipLeft].clip_play[1]) {
				pg_clip_status[_clipLeft].set_lastPlayedFrameTime(1, pg_CurrentClockTime);
			}
		}
		break;
	}
	case _clip2_play_right: {
		if (ScenarioVarConfigurations[_clipCaptFreq][pg_current_configuration_rank]) {
			pg_clip_status[_clipRight].clip_play[1] = (float_arguments[0] == 1.f);
			if (pg_clip_status[_clipRight].clip_play[1]) {
				pg_clip_status[_clipRight].set_lastPlayedFrameTime(1, pg_CurrentClockTime);
			}
		}
		break;
	}
#endif
#endif

	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ SET-UP ++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
	case _resend_all: {
		resend_all_variables = true;
		break;
	}
	case _resend_all_light: {
		resend_all_light_variables = true;
		break;
	}
	case _setupNo: {
		setup(int(round(float_arguments[0])));
		break;
	}
	case _configurationNo: {
		int config_no = int(round(float_arguments[0]));
		if (config_no >= 0 && config_no != pg_current_configuration_rank) {
			config_no = config_no % _NbConfigurations;
			StartNewConfiguration(config_no);
		}
		sprintf(AuxString, "/configurationNo %d", pg_current_configuration_rank);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		break;
	}
	case _setupName: {
		std::string sceneID = string_argument_0;
		std::regex newLines_re("\n+");
		std::regex dquotes_re("\"");
		sceneID = std::regex_replace(sceneID, newLines_re, "");
		sceneID = std::regex_replace(sceneID, dquotes_re, "");
		int ind_scene = FindSceneById(&sceneID);
		if (ind_scene >= 0 && ind_scene < pg_NbScenes[pg_current_configuration_rank]) {
			setup(ind_scene);
		}
		else {
			sprintf(ErrorStr, "Unknown scene ID %s in /setupName OSC command (%d)!", string_argument_0.c_str(), ind_scene); ReportError(ErrorStr);

		}
		break;
	}
	case _setup_plus: {
		if (float_arguments[0] > 0) {
			setup_plus(1);
		}
		break;
	}
	case _interpolation_duration: {
		pg_SceneInterpolationDuration = float_arguments[0];
		sprintf(AuxString, "/interpolation_duration %.2f", pg_SceneInterpolationDuration);
		pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
		break;
	}
	case _master_incay: {
		pg_master_incay_duration = double(float_arguments[0]);
		pg_master_incay_start_time = pg_CurrentClockTime;
		pg_master_incay_start_value = master;
		break;
	}
	case _master_decay: {
		pg_master_decay_duration = double(float_arguments[0]);
		pg_master_decay_start_time = pg_CurrentClockTime;
		pg_master_decay_start_value = master;
		break;
	}
	case _setup_plus_5: {
		setup_plus(5);
		break;
	}
	case _setup_minus: {
		setup_minus(1);
		break;
	}
	case _setup_minus_5: {
		setup_minus(5);
		break;
	}
	case _setup_plus_keep_total_dur: {
		if (pg_CurrentScene) {
			double elapsedTime = (pg_CurrentClockTime - InitialScenarioTime) - pg_CurrentScene->scene_initial_time;
			double deltaTime = pg_Scenario[pg_current_configuration_rank][1 + pg_CurrentSceneIndex].scene_initial_time - (pg_CurrentClockTime - InitialScenarioTime);
			// only accepted if the current scene has been on for a while
			if (elapsedTime > 15
				// if the scene has not begun since a short while
				&& deltaTime > 0
				// and the current scene is not finished 
				&& deltaTime < 60) {
				// and if the scene is not too far from being finished
				int new_scene = ((1 + pg_CurrentSceneIndex) % pg_NbScenes[pg_current_configuration_rank]);

				StartNewScene(new_scene, deltaTime);
			}
		}
		break;
	}

#if defined(var_activeClipArts)
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// +++++++++++++++++ ClipArt GPU +++++++++++++++++++++++++++++++ 
	// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
	// ====================================== 
	case _ClipArt_1_onOff: ClipArt_OnOff(1); break;
	case _ClipArt_2_onOff: ClipArt_OnOff(2); break;
	case _ClipArt_3_onOff: ClipArt_OnOff(3); break;
	case _ClipArt_4_onOff: ClipArt_OnOff(4); break;
	case _ClipArt_5_onOff: ClipArt_OnOff(5); break;
	case _ClipArt_6_onOff: ClipArt_OnOff(6); break;
	case _ClipArt_7_onOff: ClipArt_OnOff(7); break;
	case _ClipArt_8_onOff: ClipArt_OnOff(8); break;
	case _ClipArt_9_onOff: ClipArt_OnOff(9); break;
	case _ClipArt_10_onOff: ClipArt_OnOff(10); break;
	case _ClipArt_11_onOff: ClipArt_OnOff(11); break;
	case _ClipArt_12_onOff: ClipArt_OnOff(12); break;
	case _ClipArt_13_onOff: ClipArt_OnOff(13); break;
	case _ClipArt_14_onOff: ClipArt_OnOff(14); break;
	case _ClipArt_15_onOff: ClipArt_OnOff(15); break;
	case _ClipArt_16_onOff: ClipArt_OnOff(16); break;
	case _ClipArt_17_onOff: ClipArt_OnOff(17); break;
	case _ClipArt_18_onOff: ClipArt_OnOff(18); break;
	case _ClipArt_19_onOff: ClipArt_OnOff(19); break;
	case _ClipArt_20_onOff: ClipArt_OnOff(20); break;

	case _ClipArt_onOff: ClipArt_OnOff(int(float_arguments[0])); break;
	case _ClipArt_off: ClipArt_Off(int(float_arguments[0])); break;
	case _ClipArt_on: ClipArt_On(int(float_arguments[0])); break;

	case _ClipArt_SubPath_1_onOff: ClipArt_SubPathOnOff(1); break;
	case _ClipArt_SubPath_2_onOff: ClipArt_SubPathOnOff(2); break;
	case _ClipArt_SubPath_3_onOff: ClipArt_SubPathOnOff(3); break;
	case _ClipArt_SubPath_4_onOff: ClipArt_SubPathOnOff(4); break;

	case _ClipArt_scale: 
		pg_ClipArt_Scale[pg_current_configuration_rank][pg_last_activated_ClipArt] = float_arguments[0]; 
		printf("ClipArt GPU scale %.2f\n", float_arguments[0]);
		break;
	case _ClipArt_rotate: 
		pg_ClipArt_Rotation[pg_current_configuration_rank][pg_last_activated_ClipArt] = float_arguments[0]; 
		printf("ClipArt GPU rotate %.2f\n", float_arguments[0]);
		break;
	case _ClipArt_xy:
		pg_ClipArt_Translation_X[pg_current_configuration_rank][pg_last_activated_ClipArt] = float_arguments[0] * workingWindow_width;
		pg_ClipArt_Translation_Y[pg_current_configuration_rank][pg_last_activated_ClipArt] = float_arguments[1] * window_height;
		printf("ClipArt GPU translate %.2fx%.2f\n", float_arguments[0] * workingWindow_width, float_arguments[1] * window_height);
		break;
	case _ClipArt_x:
		pg_ClipArt_Translation_X[pg_current_configuration_rank][pg_last_activated_ClipArt] = float_arguments[0] * workingWindow_width;
		printf("ClipArt GPU translate %.2fx%.2f\n", pg_ClipArt_Translation_X[pg_current_configuration_rank][pg_last_activated_ClipArt], pg_ClipArt_Translation_Y[pg_current_configuration_rank][pg_last_activated_ClipArt]);
		break;
	case _ClipArt_y:
		pg_ClipArt_Translation_Y[pg_current_configuration_rank][pg_last_activated_ClipArt] = float_arguments[0] * window_height;
		printf("ClipArt GPU translate %.2fx%.2f\n", pg_ClipArt_Translation_X[pg_current_configuration_rank][pg_last_activated_ClipArt], pg_ClipArt_Translation_Y[pg_current_configuration_rank][pg_last_activated_ClipArt]);
		break;
	case _ClipArt_nat_color:
		for (int indPath = 0; indPath < pg_nb_paths_in_ClipArt[pg_current_configuration_rank][pg_last_activated_ClipArt]; indPath++) {
			pg_ClipArt_Colors[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath] = ClipArt_nat;
		}
		break;
	case _ClipArt_white_color: 
		for (int indPath = 0; indPath < pg_nb_paths_in_ClipArt[pg_current_configuration_rank][pg_last_activated_ClipArt]; indPath++) {
			pg_ClipArt_Colors[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath] = ClipArt_white;
		}
		break;
	case _ClipArt_red_color: 
		for (int indPath = 0; indPath < pg_nb_paths_in_ClipArt[pg_current_configuration_rank][pg_last_activated_ClipArt]; indPath++) {
			pg_ClipArt_Colors[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath] = ClipArt_red;
		}
		break;
	case _ClipArt_green_color:
		for (int indPath = 0; indPath < pg_nb_paths_in_ClipArt[pg_current_configuration_rank][pg_last_activated_ClipArt]; indPath++) {
			pg_ClipArt_Colors[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath] = ClipArt_green;
		}
		break;
	case _ClipArt_blue_color:
		for (int indPath = 0; indPath < pg_nb_paths_in_ClipArt[pg_current_configuration_rank][pg_last_activated_ClipArt]; indPath++) {
			pg_ClipArt_Colors[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath] = ClipArt_blue;
		}
		break;
	case _ClipArt_yellow_color:
		for (int indPath = 0; indPath < pg_nb_paths_in_ClipArt[pg_current_configuration_rank][pg_last_activated_ClipArt]; indPath++) {
			pg_ClipArt_Colors[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath] = ClipArt_yellow;
		}
		break;
	case _ClipArt_cyan_color:
		for (int indPath = 0; indPath < pg_nb_paths_in_ClipArt[pg_current_configuration_rank][pg_last_activated_ClipArt]; indPath++) {
			pg_ClipArt_Colors[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath] = ClipArt_cyan;
		}
		break;
	case _ClipArt_magenta_color:
		for (int indPath = 0; indPath < pg_nb_paths_in_ClipArt[pg_current_configuration_rank][pg_last_activated_ClipArt]; indPath++) {
			pg_ClipArt_Colors[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath] = ClipArt_magenta;
		}
			break;
	case _ClipArt_black_color:
		for (int indPath = 0; indPath < pg_nb_paths_in_ClipArt[pg_current_configuration_rank][pg_last_activated_ClipArt]; indPath++) {
			pg_ClipArt_Colors[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath] = ClipArt_black;
		}
		break;
	case _ClipArt_translations:
		for(int indImage = 0; indImage < pg_nb_ClipArt[pg_current_configuration_rank] && (2 * indImage + 1) < nb_arguments; indImage++) {
			pg_ClipArt_Translation_X[pg_current_configuration_rank][indImage] = float_arguments[2 * indImage] * workingWindow_width;
			pg_ClipArt_Translation_Y[pg_current_configuration_rank][indImage] = float_arguments[2 * indImage + 1] * window_height;
		}
		// printf("ClipArt GPU translate %.2fx%.2f\n", float_arguments[0] * workingWindow_width, float_arguments[1] * window_height);
		break;
#endif

#if defined(var_activeMeshes)
	case _Mesh_onOff: Mesh_OnOff(int(float_arguments[0]) + 1); break;
#endif
#if defined(var_mobileMeshes)
	case _Mesh_mobile_onOff: Mesh_mobile_OnOff(int(float_arguments[0]) + 1); break;
#endif

#if defined(var_Caverne_Mesh_Profusion)
	case _Caverne_Mesh_Profusion_on: for (int indMesh = 7; indMesh < pg_nb_Mesh_files; indMesh++) { Caverne_Mesh_Profusion_On(indMesh); }; break;
	case _Caverne_Mesh_Profusion_off: for (int indMesh = 7; indMesh < pg_nb_Mesh_files; indMesh++) { Caverne_Mesh_Profusion_Off(indMesh); }; break;
	case _Caverne_Mesh_7Solids_on: for (int indMesh = 0; indMesh < 7; indMesh++) { Mesh_On(indMesh + 1); Mesh_mobile_Off(indMesh + 1); }; break;
	case _Caverne_Mesh_7Solids_off: for (int indMesh = 0; indMesh < 7; indMesh++) { Mesh_Off(indMesh + 1); Mesh_mobile_Off(indMesh + 1); }; break;
	case _Caverne_BackColor_onOff: Caverne_BackColor = !Caverne_BackColor; break;
#endif
#if defined(var_activeMeshes)
	case _Mesh_light_x: mesh_light_x = float_arguments[0]; printf("MESH light x %.2f\n", float_arguments[0]);  break;
	case _Mesh_light_y: mesh_light_y = float_arguments[0]; printf("MESH light y %.2f\n", float_arguments[0]);  break;
	case _Mesh_light_z: mesh_light_z = float_arguments[0]; printf("MESH light z %.2f\n", float_arguments[0]);  break;
#endif
	case _take_snapshot:
		pg_draw_scene(_Jpg, false);
		sprintf(AuxString, "/snapshot_ID Snap_%04d", indJpgSnapshot); pg_send_message_udp((char *)"s", (char *)AuxString, (char *)"udp_TouchOSC_send");
		break;
	case _muteRightScreen_onOff:
		muteRightScreen = !muteRightScreen;
		break;
	case _isClearAllLayers:
		isClearAllLayers = 1;
		break;
	case _StylusvsRubber:
		if (float_arguments[0] > 0) {
			CurrentCursorStylusvsRubber = pg_Stylus;
		}
		else {
			CurrentCursorStylusvsRubber = pg_Rubber;
		}
		// drawing type initialization
		ExclusiveButtonsAndLabelsOnOff(StylusvsRubberButtonsPaths, StylusvsRubberButtonLabelsPaths, StylusvsRubberButtonValues, false, CurrentCursorStylusvsRubber);
		break;
#if defined(var_pen_hue) && defined(var_pen_sat) && defined(var_pen_value)
	case _pen_hue_sat_value:
		if (ScenarioVarConfigurations[_pen_hue][pg_current_configuration_rank]) {
			pen_hue = float_arguments[0];
			BrokenInterpolationVar[_pen_hue][pg_current_configuration_rank] = true;
			*((float*)ScenarioVarPointers[_pen_hue]) = pen_hue;
			pen_sat = float_arguments[1];
			BrokenInterpolationVar[_pen_sat][pg_current_configuration_rank] = true;
			*((float*)ScenarioVarPointers[_pen_sat]) = pen_sat;
			pen_value = float_arguments[2];
			BrokenInterpolationVar[_pen_value][pg_current_configuration_rank] = true;
			*((float*)ScenarioVarPointers[_pen_value]) = pen_value;
			HSVtoRGB(pen_hue, pen_sat, pen_value, &control_color[0], &control_color[1], &control_color[2]);
			sprintf(AuxString, "/pen_color/color %02x%02x%02xFF", int(control_color[0] * 255), int(control_color[1] * 255), int(control_color[2] * 255)); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
			//printf("color2 msg %s\n", AuxString);
		}
		break;
#endif
#if defined(var_repop_huePart) && defined(var_repop_satPart) && defined(var_repop_valuePart)
	case _repop_hue_sat_valuePart:
		if (ScenarioVarConfigurations[_repop_huePart][pg_current_configuration_rank]) {
			repop_huePart = float_arguments[0];
			BrokenInterpolationVar[_repop_huePart] = true;
			*((float*)ScenarioVarPointers[_repop_huePart]) = repop_huePart;
			repop_satPart = float_arguments[1];
			BrokenInterpolationVar[_repop_satPart] = true;
			*((float*)ScenarioVarPointers[_repop_satPart]) = repop_satPart;
			repop_valuePart = float_arguments[2];
			BrokenInterpolationVar[_repop_valuePart] = true;
			*((float*)ScenarioVarPointers[_repop_valuePart]) = repop_valuePart;
			HSVtoRGB(repop_huePart, repop_satPart, repop_valuePart, &control_color[0], &control_color[1], &control_color[2]);
			sprintf(AuxString, "/part_color/color %02x%02x%02xFF", int(control_color[0] * 255), int(control_color[1] * 255), int(control_color[2] * 255)); pg_send_message_udp((char*)"s", (char*)AuxString, (char*)"udp_TouchOSC_send");
			//printf("color2 msg %s\n", AuxString);
		}
		break;
#endif
#if defined(var_path_replay_trackNo_1)
	case _path_replay_stopAll:
		for (int pathNo = 1; pathNo <= PG_NB_PATHS; pathNo++) {
			if (is_path_replay[pathNo]) {
				pg_path_replay_trackNo_onOff(pathNo, -1);
				//sprintf(AuxString, "/path_replay_trackNo_%d 0", pathNo);
				//pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
				//printf("replay off track was currently read (%s)\n", AuxString);
			}
		}
		break;
	case _path_replay_playAll:
		printf("play all tracks %.3f\n", pg_CurrentClockTime);
		for (int pathNo = 1; pathNo <= PG_NB_PATHS; pathNo++) {
			if (!is_path_replay[pathNo] && pg_Path_Status[pathNo].path_nbRecordedFrames > 0) {
				pg_path_replay_trackNo_onOff(pathNo, 1);
				//sprintf(AuxString, "/path_replay_trackNo_%d 1", pathNo);
				//pg_send_message_udp((char*)"i", AuxString, (char*)"udp_TouchOSC_send");
				//printf("replay off track was currently read (%s)\n", AuxString);
			}
		}
		break;
#endif
	case _clear_path_group:
		clear_path_group();
		break;
#ifdef PG_METAWEAR
	case _mw_mss_pos: {
		int ind_sensor = int(float_arguments[0]);
		if (ind_sensor < PG_MW_NB_MAX_SENSORS) {
			for (int i = 0; i < 3; i++) {
				pg_mw_sensors[ind_sensor].mw_mss_pos[i] = float_arguments[i + 1];
			}
			//printf("update position sensor #%d %.2f %.2f %.2f\n", ind_sensor, 
			//	pg_mw_sensors[ind_sensor].mw_mss_pos[0], pg_mw_sensors[ind_sensor].mw_mss_pos[1], pg_mw_sensors[ind_sensor].mw_mss_pos[2]);
			pg_mw_sensors[ind_sensor].mw_mss_pos_update = true;
		}
		else {
			sprintf(ErrorStr, "unregistered sensor #%d (max %d)!", ind_sensor, PG_MW_NB_MAX_SENSORS); ReportError(ErrorStr);
		}
	}
	break;
#endif

	default: {
			sprintf(ErrorStr, "Command not found (%s)!", address_string.c_str()); ReportError(ErrorStr);
			break;
		}
	}
}

#if defined(var_activeClipArts)
void ClipArt_OnOff(int indImage) {
	if (indImage <= pg_nb_ClipArt[pg_current_configuration_rank] && activeClipArts != -1) { // activeClipArts == -1 <=> all ClipArt always visible
		bool isImageOn = activeClipArts & (1 << (indImage - 1));
		if (isImageOn) {
			activeClipArts = activeClipArts & ~(1 << (indImage - 1));
		}
		else {
			activeClipArts |= (1 << (indImage - 1));
			pg_last_activated_ClipArt = indImage - 1;
		}
		BrokenInterpolationVar[_activeClipArts] = true;
		*((int*)ScenarioVarPointers[_activeClipArts]) = activeClipArts;
		sprintf(AuxString, "/ClipArt_%d_onOff %d", indImage, (!isImageOn)); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	}
}

void ClipArt_Off(int indImage) {
	if (indImage <= pg_nb_ClipArt[pg_current_configuration_rank] && activeClipArts != -1) { // activeClipArts == -1 <=> all ClipArt always visible
		bool isImageOn = activeClipArts & (1 << (indImage - 1));
		if (isImageOn) {
			activeClipArts = activeClipArts & ~(1 << (indImage - 1));
			BrokenInterpolationVar[_activeClipArts] = true;
			*((int*)ScenarioVarPointers[_activeClipArts]) = activeClipArts;
			sprintf(AuxString, "/ClipArt_%d_onOff %d", indImage, (!isImageOn)); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
		}
	}
}

void ClipArt_On(int indImage) {
	if (indImage <= pg_nb_ClipArt[pg_current_configuration_rank] && activeClipArts != -1) { // activeClipArts == -1 <=> all ClipArt always visible
		bool isImageOn = activeClipArts & (1 << (indImage - 1));
		if (!isImageOn) {
			activeClipArts |= (1 << (indImage - 1));
			pg_last_activated_ClipArt = indImage - 1;
			BrokenInterpolationVar[_activeClipArts] = true;
			*((int*)ScenarioVarPointers[_activeClipArts]) = activeClipArts;
			sprintf(AuxString, "/ClipArt_%d_onOff %d", indImage, (!isImageOn)); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
		}
	}
}
#endif

#if defined(var_activeMeshes)
void Mesh_OnOff(int indImage) {
	if (indImage <= pg_nb_Mesh_files) {
		bool isImageOn = activeMeshes & (1 << (indImage - 1));
		if (isImageOn) {
			activeMeshes = activeMeshes & ~(1 << (indImage - 1));
		}
		else {
			activeMeshes |= (1 << (indImage - 1));
			pg_last_activated_Mesh = indImage - 1;
		}
		BrokenInterpolationVar[_activeMeshes][pg_current_configuration_rank] = true;
		*((int*)ScenarioVarPointers[_activeMeshes]) = activeMeshes;
		sprintf(AuxString, "/Mesh_%d_onOff %d", indImage, (!isImageOn)); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	}
}
void Mesh_On(int indImage) {
	if (indImage <= pg_nb_Mesh_files) {
		bool isImageOn = activeMeshes & (1 << (indImage - 1));
		if (!isImageOn) {
			activeMeshes |= (1 << (indImage - 1));
			pg_last_activated_Mesh = indImage - 1;
		}
		BrokenInterpolationVar[_activeMeshes][pg_current_configuration_rank] = true;
		*((int*)ScenarioVarPointers[_activeMeshes]) = activeMeshes;
		sprintf(AuxString, "/Mesh_%d_onOff %d", indImage, 1); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	}
}
void Mesh_Off(int indImage) {
	if (indImage <= pg_nb_Mesh_files) {
		bool isImageOn = activeMeshes & (1 << (indImage - 1));
		if (isImageOn) {
			activeMeshes = activeMeshes & ~(1 << (indImage - 1));
		}
		BrokenInterpolationVar[_activeMeshes][pg_current_configuration_rank] = true;
		*((int*)ScenarioVarPointers[_activeMeshes]) = mobileMeshes;
		sprintf(AuxString, "/Mesh_%d_onOff %d", indImage, 0); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	}
}
#if defined(var_Caverne_Mesh_Profusion)
void Caverne_Mesh_Profusion_On(int indImage) {
	pg_CaverneActveMesh[indImage] = !pg_CaverneActveMesh[indImage];
	pg_CaverneMeshBirthTime[indImage] = pg_CurrentClockTime;
	pg_CaverneMeshDeathTime[indImage] = pg_CurrentClockTime + 100000.f;
}
void Caverne_Mesh_Profusion_Off(int indImage) {
	pg_CaverneMeshDeathTime[indImage] = pg_CurrentClockTime + pg_CaverneMeshWakeupTime[indImage] / 3.f;
}
#endif
#endif
#if defined(var_mobileMeshes)
void Mesh_mobile_OnOff(int indImage) {
	if (indImage <= pg_nb_Mesh_files) {
		bool isImageOn = mobileMeshes & (1 << (indImage - 1));
		printf("Mesh on %d\n", isImageOn);
		if (isImageOn) {
			mobileMeshes = mobileMeshes & ~(1 << (indImage - 1));
		}
		else {
			mobileMeshes |= (1 << (indImage - 1));
			pg_last_activated_Mesh = indImage - 1;
		}
		BrokenInterpolationVar[_mobileMeshes][pg_current_configuration_rank] = true;
		*((int*)ScenarioVarPointers[_mobileMeshes]) = mobileMeshes;
		sprintf(AuxString, "/Mesh_mobile_%d_onOff %d", indImage, (!isImageOn)); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	}
}
void Mesh_mobile_Off(int indImage) {
	if (indImage <= pg_nb_Mesh_files) {
		bool isImageOn = mobileMeshes & (1 << (indImage - 1));
		if (isImageOn) {
			mobileMeshes = mobileMeshes & ~(1 << (indImage - 1));
			pg_Mesh_Translation_X[indImage - 1] = pg_Mesh_Translation_Ini_X[indImage - 1];
			pg_Mesh_Translation_Y[indImage - 1] = pg_Mesh_Translation_Ini_Y[indImage - 1];
			pg_Mesh_Translation_Z[indImage - 1] = pg_Mesh_Translation_Ini_Z[indImage - 1];
			pg_Mesh_Rotation_X[indImage - 1] = pg_Mesh_Rotation_Ini_X[indImage - 1];
			pg_Mesh_Rotation_Y[indImage - 1] = pg_Mesh_Rotation_Ini_Y[indImage - 1];
			pg_Mesh_Rotation_Z[indImage - 1] = pg_Mesh_Rotation_Ini_Z[indImage - 1];
		}
		BrokenInterpolationVar[_mobileMeshes][pg_current_configuration_rank] = true;
		*((int*)ScenarioVarPointers[_mobileMeshes]) = mobileMeshes;
		sprintf(AuxString, "/Mesh_mobile_%d_onOff %d", indImage, 0); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	}
}
void Mesh_mobile_On(int indImage) {
	if (indImage <= pg_nb_Mesh_files) {
		bool isImageOn = mobileMeshes & (1 << (indImage - 1));
		if (!isImageOn) {
			mobileMeshes |= (1 << (indImage - 1));
			pg_last_activated_Mesh = indImage - 1;
		}
		BrokenInterpolationVar[_mobileMeshes][pg_current_configuration_rank] = true;
		*((int*)ScenarioVarPointers[_mobileMeshes]) = mobileMeshes;
		sprintf(AuxString, "/Mesh_mobile_%d_onOff %d", indImage, 1); pg_send_message_udp((char*)"i", (char*)AuxString, (char*)"udp_TouchOSC_send");
	}
}
#endif

void ClipArt_SubPathOnOff(int indPath) {
	if (indPath - 1 < pg_nb_paths_in_ClipArt[pg_current_configuration_rank][pg_last_activated_ClipArt]) {
		pg_ClipArt_SubPath[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath - 1] 
			= !pg_ClipArt_SubPath[pg_current_configuration_rank][pg_last_activated_ClipArt][indPath - 1];
	}
}

//////////////////////////////////////////////////////////////
// PULSE COLOR FUNCTIONS
//////////////////////////////////////////////////////////////
void compute_pulsed_palette_color(float color, float color_pulse, float grey, float grey_pulse, float pulsed_color[3], bool is_pen_color) {
	float lowPalette[3];
	int indLowPalette[3];
	int indUpperPalette[3];
	float pulsed_color_percentage[3];
	float bandpass_3color_palette[3][3];

	// computes the corresponding low and high palette and the percentages of contribution of each of them
	for (int indColorBandPass = 0; indColorBandPass < 3; indColorBandPass++) {
		float pulsed_color;
		if (color_pulse != 0) {
			pulsed_color = color + pulse[indColorBandPass] * color_pulse;
		}
		else {
			pulsed_color = color;
		}
		pulsed_color *= nb_pen_palette_colors[pg_current_configuration_rank];
		pulsed_color_percentage[indColorBandPass] = modf(pulsed_color, &(lowPalette[indColorBandPass]));
		while (lowPalette[indColorBandPass] < 0) {
			lowPalette[indColorBandPass] += nb_pen_palette_colors[pg_current_configuration_rank];
		}
		indLowPalette[indColorBandPass] = int(lowPalette[indColorBandPass]) % nb_pen_palette_colors[pg_current_configuration_rank];
		indUpperPalette[indColorBandPass] = (indLowPalette[indColorBandPass] + 1) % nb_pen_palette_colors[pg_current_configuration_rank];
	}

	// the base palette is obtained by interpolating the two closest palettes according to color
	//printf("pulsed_color_percentage %.2f %.2f %.2f / %.2f\n", pulsed_color_percentage[0], pulsed_color_percentage[1], pulsed_color_percentage[2], color_pulse);
	//printf("ind low palettes %d %d %d\n", indLowPalette[0], indLowPalette[1], indLowPalette[2]);
	//printf("ind high palettes %d %d %d\n", indUpperPalette[0], indUpperPalette[1], indUpperPalette[2]);
	for (int indColorBandPass = 0; indColorBandPass < 3; indColorBandPass++) {
		for (int indChannel = 0; indChannel < 3; indChannel++) {
			bandpass_3color_palette[indColorBandPass][indChannel]
				= (1.f - pulsed_color_percentage[indColorBandPass]) * pen_palette_colors_values[pg_current_configuration_rank][indLowPalette[indColorBandPass]][indColorBandPass * 3 + indChannel]
				+ pulsed_color_percentage[indColorBandPass] * pen_palette_colors_values[pg_current_configuration_rank][indUpperPalette[indColorBandPass]][indColorBandPass * 3 + indChannel];
			bandpass_3color_palette[indColorBandPass][indChannel] = min(1.f, bandpass_3color_palette[indColorBandPass][indChannel]);
		}
	}

	// stores the bandpass colors that will be shown in the palette interface in the Master shader for color visualization by user
	if (is_pen_color) {
		for (int indColorBandPass = 0; indColorBandPass < 3; indColorBandPass++) {
			for (int indChannel = 0; indChannel < 3; indChannel++) {
				pen_bandpass_3color_palette[indColorBandPass][indChannel] = bandpass_3color_palette[indColorBandPass][indChannel];
			}
		}
	}
	//printf("pen color %.2f palette low/upper/perc %d/%d/%.2f -> colors %.1f %.1f %.1f       %.1f %.1f %.1f        %.1f %.1f %.1f\n", 
	//	pen_color, indLowPenPalette, indUpperPenPalette, percentage, 
	//	bandpass_3color_palette[0][0], bandpass_3color_palette[0][1], bandpass_3color_palette[0][2], 
	//  bandpass_3color_palette[1][0], bandpass_3color_palette[1][1], bandpass_3color_palette[1][2], 
	//  bandpass_3color_palette[2][0], bandpass_3color_palette[2][1], bandpass_3color_palette[2][2]);
	// calculating the color from base luminance + palette colors modulated by the three frequence ranges
	for (int indChannel = 0; indChannel < 3; indChannel++) {
		// adding a base luminance
		pulsed_color[indChannel] = grey + pulse_average * grey_pulse;
		if (pulse_average != 0) {
			for (int indColorBandPass = 0; indColorBandPass < 3; indColorBandPass++) {
#if defined(var_alKemi)
				if (ScenarioVarConfigurations[_alKemi][pg_current_configuration_rank]) {
					if (ScenarioVarConfigurations[_alKemi][pg_current_configuration_rank]) {
						pulsed_color[indChannel]
							+= color_spectrum_coef * bandpass_3color_palette[indColorBandPass][indChannel] * (pulse[indColorBandPass] / (3.f * pulse_average));
					}
					else {
						pulsed_color[indChannel]
							+= bandpass_3color_palette[indColorBandPass][indChannel] * (pulse[indColorBandPass] / (3.f * pulse_average));
					}
				}
				else
#endif
				{
					pulsed_color[indChannel]
						+= (bandpass_3color_palette[indColorBandPass][indChannel] / 3.f) + (pulse[indColorBandPass] * color_pulse / pulse_average);
				}
			}
		}
		else {
			for (int indColorBandPass = 0; indColorBandPass < 3; indColorBandPass++) {
#if defined(var_alKemi)
				if (ScenarioVarConfigurations[_alKemi][pg_current_configuration_rank]) {
					if (ScenarioVarConfigurations[_alKemi][pg_current_configuration_rank]) {
						pulsed_color[indChannel]
							+= color_spectrum_coef * bandpass_3color_palette[indColorBandPass][indChannel] / 3.f;
					}
					else {
						pulsed_color[indChannel]
							+= bandpass_3color_palette[indColorBandPass][indChannel] / 3.f;
					}
				}
				else
#endif
				{
					pulsed_color[indChannel]
						+= bandpass_3color_palette[indColorBandPass][indChannel] / 3.f;
				}
			}
		}
		pulsed_color[indChannel] = min(1.f, pulsed_color[indChannel]);
	}
	float value = (pulsed_color[0] < pulsed_color[1]) ? pulsed_color[1] : pulsed_color[0];
	value = (value < pulsed_color[2]) ? pulsed_color[2] : value;
	// printf( "pulsed_color: %f %f %f\n" , pulsed_color[0] , pulsed_color[1] , pulsed_color[2] );

	// color_pulse negative => saturation of the pulsed color
	if (color_pulse < 0 && value > 0) {
		for (int indChannel = 0; indChannel < 3; indChannel++) {
			pulsed_color[indChannel] /= value;
		}
	}

	// the colors for drawing are inverted in case of inverted rendering, so that the drawing colors are not seen inverted
	if (invertAllLayers) {
		pulsed_color[0] = value - pulsed_color[0];
		pulsed_color[1] = value - pulsed_color[1];
		pulsed_color[2] = value - pulsed_color[2];
		float new_value = (pulsed_color[0] < pulsed_color[1]) ? pulsed_color[1] : pulsed_color[0];
		new_value = (new_value < pulsed_color[2]) ? pulsed_color[2] : new_value;
		// the new value should be the same as the intial one, the difference is subtracted from the channels
		pulsed_color[0] += value - new_value;
		pulsed_color[1] += value - new_value;
		pulsed_color[2] += value - new_value;
	}
}

// from https://www.codespeedy.com/hsv-to-rgb-in-cpp/

void HSVtoRGB(float h, float s, float v, float* r, float* g, float* b) {
	if (h > 1.f || h < 0 || s>1.f || s < 0 || v>1.f || v < 0) {
		//std::cout << "The givem HSV values are not in valid range" << std::endl;
		h = max(min(h, 1.f), 0.f);
		s = max(min(s, 1.f), 0.f);
		v = max(min(v, 1.f), 0.f);
	}
	float H = h * 360.f;
	float C = s * v;
	float X = C * float(1.f - abs(fmod(H / 60.0f, 2) - 1));
	float m = v - C;
	if (H >= 0 && H < 60.f) {
		*r = C, * g = X, * b = 0;
	}
	else if (H >= 60.f && H < 120.f) {
		*r = X, * g = C, * b = 0;
	}
	else if (H >= 120.f && H < 180.f) {
		*r = 0, * g = C, * b = X;
	}
	else if (H >= 180.f && H < 240.f) {
		*r = 0, * g = X, * b = C;
	}
	else if (H >= 240.f && H < 300.f) {
		*r = X, * g = 0, * b = C;
	}
	else {
		*r = C, * g = 0, * b = X;
	}
	*r += m;
	*g += m;
	*b += m;
	//cout << "R : " << R << endl;
	//cout << "G : " << G << endl;
	//cout << "B : " << B << endl;
}

void RGBtoHSV(float r, float g, float b, float* h, float* s, float* v) {
	if (r > 1.f || r < 0 || g > 1.f || g < 0 || b > 1.f || b < 0) {
		//std::cout << "The givem RGB values are not in valid range" << std::endl;
		r = max(min(r, 1.f), 0.f);
		g = max(min(g, 1.f), 0.f);
		b = max(min(b, 1.f), 0.f);
	}

	float maxval, minval;

	maxval = max(max(r, g), b);
	minval = min(min(r, g), b);

	float difference = maxval - minval;

	if (difference == 0)
		*h = 0.;
	else if (r == maxval)
		*h = fmod(((60.f * ((g - b) / difference)) + 360.f), 360.0f);
	else if (g = maxval)
		*h = fmod(((60.f * ((b - r) / difference)) + 120.f), 360.0f);
	else if (b = maxval)
		*h = fmod(((60.f * ((r - g) / difference)) + 240.f), 360.0f);

	if (maxval == 0)
		*s = 0.;
	else
		*s = (difference / maxval);

	*v = maxval;

	//cout << "H : " << *h << endl;
	//cout << "S : " << *s << endl;
	//cout << "V : " << *v << endl;
}

void compute_pulsed_HSV_color(float hue, float hue_pulse, float sat, float sat_pulse, float value, float value_pulse, float pulsed_color[3], bool is_pen_color) {
	float pulsed_hue = hue + pulse_average * hue_pulse;
	float pulsed_sat = sat + pulse_average * sat_pulse;
	float pulsed_value = value + pulse_average * value_pulse;

	// ciruclar hue, keeps the value between 0 and 1
	if (pulsed_hue < 0) {
		float intpart;
		pulsed_hue = modf(pulsed_hue, &intpart) + 1.f;
	}
	else if (pulsed_hue > 1.f) {
		float intpart;
		pulsed_hue = modf(pulsed_hue, &intpart);
	}

	pulsed_sat = max(0.f, min(pulsed_sat, 1.f));
	pulsed_value = max(0.f, min(pulsed_value, 1.f));

	HSVtoRGB(pulsed_hue, pulsed_sat, pulsed_value, &pulsed_color[0], &pulsed_color[1], &pulsed_color[2]);
	//printf("pulsed color RGB %.2f %.2f %.2f \n", pulsed_color[0], pulsed_color[1], pulsed_color[2]);

	// the hues for drawing are inverted in case of inverted rendering, so that the drawing hues are not seen inverted
	if (invertAllLayers) {
		pulsed_color[0] = pulsed_value - pulsed_color[0];
		pulsed_color[1] = pulsed_value - pulsed_color[1];
		pulsed_color[2] = pulsed_value - pulsed_color[2];
		float new_value = (pulsed_color[0] < pulsed_color[1]) ? pulsed_color[1] : pulsed_color[0];
		new_value = (new_value < pulsed_color[2]) ? pulsed_color[2] : new_value;
		// the new value should be the same as the intial one, the difference is subtracted from the channels
		pulsed_color[0] += pulsed_value - new_value;
		pulsed_color[1] += pulsed_value - new_value;
		pulsed_color[2] += pulsed_value - new_value;
	}
}

#ifdef PG_LIGHTS_CONTROL_IN_PG
void pg_UpdateLightGroups_from_LightVars() {
	bool oneLightChanged = false;
#if defined(var_light1_grey) && defined(var_light1_color) && defined(var_light1_dimmer) && defined(var_light1_strobe) && defined(var_light1_grey_pulse) && defined(var_light1_color_pulse) && defined(var_light1_dimmer_pulse) && defined(var_light1_strobe_pulse) 
	if (light1_grey != light1_grey_prec || light1_grey_pulse != light1_grey_pulse_prec
		|| light1_color != light1_color_prec || light1_color_pulse != light1_color_pulse_prec
		|| light1_dimmer != light1_dimmer_prec || light1_dimmer_pulse != light1_dimmer_pulse_prec
		|| light1_strobe != light1_strobe_prec || light1_strobe_pulse != light1_strobe_pulse_prec
		|| ((light1_grey_pulse != 0 || light1_color_pulse != 0 || light1_dimmer_pulse != 0 || light1_strobe_pulse != 0)
			&& (pulse_light_prec[0] != pulse[0] || pulse_light_prec[1] != pulse[1] || pulse_light_prec[2] != pulse[2]))
#if defined(var_Caverne_BackColor)
		// video background and light color are the same and randomly changed
		|| Caverne_BackColorRed != Caverne_BackColorRed_prec
		|| Caverne_BackColorGreen != Caverne_BackColorGreen_prec
		|| Caverne_BackColorBlue != Caverne_BackColorBlue_prec
#endif
		) {
		float rgb_color[_rgb];
		if (pg_nb_light_groups > 0) {
			compute_pulsed_palette_color(light1_color, light1_color_pulse, light1_grey, light1_grey_pulse, rgb_color, false);
			pg_light_groups[0].set_color(rgb_color);
			pg_light_groups[0].set_group_val(_dimmer, light1_dimmer * (1.f + pulse_average * light1_dimmer_pulse));
			pg_light_groups[0].set_group_val(_strobe, light1_strobe * (1.f + pulse_average * light1_strobe_pulse));
			light1_color_prec = light1_color;
			light1_color_pulse_prec = light1_color_pulse;
			light1_grey_prec = light1_grey;
			light1_grey_pulse_prec = light1_grey_pulse;
			light1_dimmer_prec = light1_dimmer;
			light1_dimmer_pulse_prec = light1_dimmer_pulse;
			light1_strobe_prec = light1_strobe;
			light1_strobe_pulse_prec = light1_strobe_pulse;
		}
#if defined(var_Caverne_BackColor)
		if (ScenarioVarConfigurations[_Caverne_BackColor][pg_current_configuration_rank]) {
			// video background and light color are the same and randomly changed
			if (Caverne_BackColor && pg_nb_light_groups > 0) {
				pg_light_groups[0].set_color(Caverne_BackColorRed, Caverne_BackColorGreen, Caverne_BackColorBlue);
				Caverne_BackColorRed_prec = Caverne_BackColorRed;
				Caverne_BackColorGreen_prec = Caverne_BackColorGreen;
				Caverne_BackColorBlue_prec = Caverne_BackColorBlue;
			}
		}
#endif
		oneLightChanged = true;
	}
#endif
#if defined(var_light2_grey) && defined(var_light2_color) && defined(var_light2_dimmer) && defined(var_light2_strobe) && defined(var_light2_grey_pulse) && defined(var_light2_color_pulse) && defined(var_light2_dimmer_pulse) && defined(var_light2_strobe_pulse) 
	if (light2_grey != light2_grey_prec || light2_grey_pulse != light2_grey_pulse_prec
		|| light2_color != light2_color_prec || light2_color_pulse != light2_color_pulse_prec
		|| light2_dimmer != light2_dimmer_prec || light2_dimmer_pulse != light2_dimmer_pulse_prec
		|| light2_strobe != light2_strobe_prec || light2_strobe_pulse != light2_strobe_pulse_prec
		|| ((light2_grey_pulse != 0 || light2_color_pulse != 0 || light2_dimmer_pulse != 0 || light2_strobe_pulse != 0)
			&& (pulse_light_prec[0] != pulse[0] || pulse_light_prec[1] != pulse[1] || pulse_light_prec[2] != pulse[2]))) {
		float rgb_color[_rgb];
		compute_pulsed_palette_color(light2_color, light2_color_pulse, light2_grey, light2_grey_pulse, rgb_color, false);
		pg_light_groups[1].set_color(rgb_color);
		pg_light_groups[1].set_group_val(_dimmer,  light2_dimmer * (1.f + pulse_average * light2_dimmer_pulse));
		pg_light_groups[1].set_group_val(_strobe,  light2_strobe * (1.f + pulse_average * light2_strobe_pulse));
		light2_color_prec = light2_color;
		light2_color_pulse_prec = light2_color_pulse;
		light2_grey_prec = light2_grey;
		light2_grey_pulse_prec = light2_grey_pulse;
		light2_dimmer_prec = light2_dimmer;
		light2_dimmer_pulse_prec = light2_dimmer_pulse;
		light2_strobe_prec = light2_strobe;
		light2_strobe_pulse_prec = light2_strobe_pulse;
		oneLightChanged = true;
	}
#endif
#if defined(var_light3_grey) && defined(var_light3_color) && defined(var_light3_dimmer) && defined(var_light3_strobe) && defined(var_light3_grey_pulse) && defined(var_light3_color_pulse) && defined(var_light3_dimmer_pulse) && defined(var_light3_strobe_pulse) 
	if (light3_grey != light3_grey_prec || light3_grey_pulse != light3_grey_pulse_prec
		|| light3_color != light3_color_prec || light3_color_pulse != light3_color_pulse_prec
		|| light3_dimmer != light3_dimmer_prec || light3_dimmer_pulse != light3_dimmer_pulse_prec
		|| light3_strobe != light3_strobe_prec || light3_strobe_pulse != light3_strobe_pulse_prec
		|| ((light3_grey_pulse != 0 || light3_color_pulse != 0 || light3_dimmer_pulse != 0 || light3_strobe_pulse != 0)
			&& (pulse_light_prec[0] != pulse[0] || pulse_light_prec[1] != pulse[1] || pulse_light_prec[2] != pulse[2]))) {
		float rgb_color[_rgb];
		compute_pulsed_palette_color(light3_color, light3_color_pulse, light3_grey, light3_grey_pulse, rgb_color, false);
		pg_light_groups[2].set_color(rgb_color);
		pg_light_groups[2].set_group_val(_dimmer,  light3_dimmer * (1.f + pulse_average * light3_dimmer_pulse));
		pg_light_groups[2].set_group_val(_strobe,  light3_strobe * (1.f + pulse_average * light3_strobe_pulse));
		light3_color_prec = light3_color;
		light3_color_pulse_prec = light3_color_pulse;
		light3_grey_prec = light3_grey;
		light3_grey_pulse_prec = light3_grey_pulse;
		light3_dimmer_prec = light3_dimmer;
		light3_dimmer_pulse_prec = light3_dimmer_pulse;
		light3_strobe_prec = light3_strobe;
		light3_strobe_pulse_prec = light3_strobe_pulse;
		oneLightChanged = true;
	}
#endif
#if defined(var_light4_grey) && defined(var_light4_color) && defined(var_light4_dimmer) && defined(var_light4_strobe) && defined(var_light4_grey_pulse) && defined(var_light4_color_pulse) && defined(var_light4_dimmer_pulse) && defined(var_light4_strobe_pulse) 
	if (light4_grey != light4_grey_prec || light4_grey_pulse != light4_grey_pulse_prec
		|| light4_color != light4_color_prec || light4_color_pulse != light4_color_pulse_prec
		|| light4_dimmer != light4_dimmer_prec || light4_dimmer_pulse != light4_dimmer_pulse_prec
		|| light4_strobe != light4_strobe_prec || light4_strobe_pulse != light4_strobe_pulse_prec
		|| ((light4_grey_pulse != 0 || light4_color_pulse != 0 || light4_dimmer_pulse != 0 || light4_strobe_pulse != 0)
			&& (pulse_light_prec[0] != pulse[0] || pulse_light_prec[1] != pulse[1] || pulse_light_prec[2] != pulse[2]))) {
		float rgb_color[_rgb];
		compute_pulsed_palette_color(light4_color, light4_color_pulse, light4_grey, light4_grey_pulse, rgb_color, false);
		pg_light_groups[3].set_color(rgb_color);
		pg_light_groups[3].set_group_val(_dimmer,  light4_dimmer * (1.f + pulse_average * light4_dimmer_pulse));
		pg_light_groups[3].set_group_val(_strobe,  light4_strobe * (1.f + pulse_average * light4_strobe_pulse));
		light4_color_prec = light4_color;
		light4_color_pulse_prec = light4_color_pulse;
		light4_grey_prec = light4_grey;
		light4_grey_pulse_prec = light4_grey_pulse;
		light4_dimmer_prec = light4_dimmer;
		light4_dimmer_pulse_prec = light4_dimmer_pulse;
		light4_strobe_prec = light4_strobe;
		light4_strobe_pulse_prec = light4_strobe_pulse;
		oneLightChanged = true;
	}
#endif
#if defined(var_light5_grey) && defined(var_light5_color) && defined(var_light5_dimmer) && defined(var_light5_strobe) && defined(var_light5_grey_pulse) && defined(var_light5_color_pulse) && defined(var_light5_dimmer_pulse) && defined(var_light5_strobe_pulse) 
	if (light5_grey != light5_grey_prec || light5_grey_pulse != light5_grey_pulse_prec
		|| light5_color != light5_color_prec || light5_color_pulse != light5_color_pulse_prec
		|| light5_dimmer != light5_dimmer_prec || light5_dimmer_pulse != light5_dimmer_pulse_prec
		|| light5_strobe != light5_strobe_prec || light5_strobe_pulse != light5_strobe_pulse_prec
		|| ((light5_grey_pulse != 0 || light5_color_pulse != 0 || light5_dimmer_pulse != 0 || light5_strobe_pulse != 0)
			&& (pulse_light_prec[0] != pulse[0] || pulse_light_prec[1] != pulse[1] || pulse_light_prec[2] != pulse[2]))) {
		float rgb_color[_rgb];
		compute_pulsed_palette_color(light5_color, light5_color_pulse, light5_grey, light5_grey_pulse, rgb_color, false);
		pg_light_groups[4].set_color(rgb_color);
		pg_light_groups[4].set_group_val(_dimmer,  light5_dimmer * (1.f + pulse_average * light5_dimmer_pulse));
		pg_light_groups[4].set_group_val(_strobe,  light5_strobe * (1.f + pulse_average * light5_strobe_pulse));
		light5_color_prec = light5_color;
		light5_color_pulse_prec = light5_color_pulse;
		light5_grey_prec = light5_grey;
		light5_grey_pulse_prec = light5_grey_pulse;
		light5_dimmer_prec = light5_dimmer;
		light5_dimmer_pulse_prec = light5_dimmer_pulse;
		light5_strobe_prec = light5_strobe;
		light5_strobe_pulse_prec = light5_strobe_pulse;
		oneLightChanged = true;
	}
#endif
#if defined(var_light6_grey) && defined(var_light6_color) && defined(var_light6_dimmer) && defined(var_light6_strobe) && defined(var_light6_grey_pulse) && defined(var_light6_color_pulse) && defined(var_light6_dimmer_pulse) && defined(var_light6_strobe_pulse) 
	if (light6_grey != light6_grey_prec || light6_grey_pulse != light6_grey_pulse_prec
		|| light6_color != light6_color_prec || light6_color_pulse != light6_color_pulse_prec
		|| light6_dimmer != light6_dimmer_prec || light6_dimmer_pulse != light6_dimmer_pulse_prec
		|| light6_strobe != light6_strobe_prec || light6_strobe_pulse != light6_strobe_pulse_prec
		|| ((light6_grey_pulse != 0 || light6_color_pulse != 0 || light6_dimmer_pulse != 0 || light6_strobe_pulse != 0)
			&& (pulse_light_prec[0] != pulse[0] || pulse_light_prec[1] != pulse[1] || pulse_light_prec[2] != pulse[2]))) {
		float rgb_color[_rgb];
		compute_pulsed_palette_color(light6_color, light6_color_pulse, light6_grey, light6_grey_pulse, rgb_color, false);
		pg_light_groups[5].set_color(rgb_color);
		pg_light_groups[5].set_group_val(_dimmer,  light6_dimmer * (1.f + pulse_average * light6_dimmer_pulse));
		pg_light_groups[5].set_group_val(_strobe,  light6_strobe * (1.f + pulse_average * light6_strobe_pulse));
		light6_color_prec = light6_color;
		light6_color_pulse_prec = light6_color_pulse;
		light6_grey_prec = light6_grey;
		light6_grey_pulse_prec = light6_grey_pulse;
		light6_dimmer_prec = light6_dimmer;
		light6_dimmer_pulse_prec = light6_dimmer_pulse;
		light6_strobe_prec = light6_strobe;
		light6_strobe_pulse_prec = light6_strobe_pulse;
		oneLightChanged = true;
	}
#endif
#if defined(var_light7_grey) && defined(var_light7_color) && defined(var_light7_dimmer) && defined(var_light7_strobe) && defined(var_light7_grey_pulse) && defined(var_light7_color_pulse) && defined(var_light7_dimmer_pulse) && defined(var_light7_strobe_pulse) 
	if (light7_grey != light7_grey_prec || light7_grey_pulse != light7_grey_pulse_prec
		|| light7_color != light7_color_prec || light7_color_pulse != light7_color_pulse_prec
		|| light7_dimmer != light7_dimmer_prec || light7_dimmer_pulse != light7_dimmer_pulse_prec
		|| light7_strobe != light7_strobe_prec || light7_strobe_pulse != light7_strobe_pulse_prec
		|| ((light7_grey_pulse != 0 || light7_color_pulse != 0 || light7_dimmer_pulse != 0 || light7_strobe_pulse != 0)
			&& (pulse_light_prec[0] != pulse[0] || pulse_light_prec[1] != pulse[1] || pulse_light_prec[2] != pulse[2]))
		) {
		float rgb_color[_rgb];
		compute_pulsed_palette_color(light7_color, light7_color_pulse, light7_grey, light7_grey_pulse, rgb_color, false);
		pg_light_groups[6].set_color(rgb_color);
		pg_light_groups[6].set_group_val(_dimmer,  light7_dimmer * (1.f + pulse_average * light7_dimmer_pulse));
		pg_light_groups[6].set_group_val(_strobe,  light7_strobe * (1.f + pulse_average * light7_strobe_pulse));
		light7_color_prec = light7_color;
		light7_color_pulse_prec = light7_color_pulse;
		light7_grey_prec = light7_grey;
		light7_grey_pulse_prec = light7_grey_pulse;
		light7_dimmer_prec = light7_dimmer;
		light7_dimmer_pulse_prec = light7_dimmer_pulse;
		light7_strobe_prec = light7_strobe;
		light7_strobe_pulse_prec = light7_strobe_pulse;
		oneLightChanged = true;
	}
#endif
#if defined(var_light8_grey) && defined(var_light8_color) && defined(var_light8_dimmer) && defined(var_light8_strobe) && defined(var_light8_grey_pulse) && defined(var_light8_color_pulse) && defined(var_light8_dimmer_pulse) && defined(var_light8_strobe_pulse) 
	if (light8_grey != light8_grey_prec || light8_grey_pulse != light8_grey_pulse_prec
		|| light8_color != light8_color_prec || light8_color_pulse != light8_color_pulse_prec
		|| light8_dimmer != light8_dimmer_prec || light8_dimmer_pulse != light8_dimmer_pulse_prec
		|| light8_strobe != light8_strobe_prec || light8_strobe_pulse != light8_strobe_pulse_prec
		|| ((light8_grey_pulse != 0 || light8_color_pulse != 0 || light8_dimmer_pulse != 0 || light8_strobe_pulse != 0)
			&& (pulse_light_prec[0] != pulse[0] || pulse_light_prec[1] != pulse[1] || pulse_light_prec[2] != pulse[2]))
#if defined(var_Caverne_BackColor)
		// video background and light color are the same and randomly changed
		|| (Caverne_BackColor && Caverne_BackColorFlash != Caverne_BackColorFlash_prec)
#endif
		) {
		float rgb_color[_rgb];
		compute_pulsed_palette_color(light8_color, light8_color_pulse, light8_grey, light8_grey_pulse, rgb_color, false);
		pg_light_groups[7].set_color(rgb_color);
		pg_light_groups[7].set_group_val(_dimmer,  light8_dimmer * (1.f + pulse_average * light8_dimmer_pulse));
		pg_light_groups[7].set_group_val(_strobe,  light8_strobe * (1.f + pulse_average * light8_strobe_pulse));
		light8_color_prec = light8_color;
		light8_color_pulse_prec = light8_color_pulse;
		light8_grey_prec = light8_grey;
		light8_grey_pulse_prec = light8_grey_pulse;
		light8_dimmer_prec = light8_dimmer;
		light8_dimmer_pulse_prec = light8_dimmer_pulse;
		light8_strobe_prec = light8_strobe;
		light8_strobe_pulse_prec = light8_strobe_pulse;
#if defined(var_Caverne_BackColor)
		if (ScenarioVarConfigurations[_Caverne_BackColor][pg_current_configuration_rank]) {
			// video background and light color are the same and randomly changed
			if (Caverne_BackColor && Caverne_BackColorFlash != Caverne_BackColorFlash_prec) {
				if (Caverne_BackColorFlash) {
					pg_light_groups[7].set_group_val(_dimmer, 0.2f * pg_light_groups[0].get_group_val(_dimmer));
					Caverne_BackColorFlash = false;
					Caverne_BackColorFlash_prec = true;
				}
				else {
					Caverne_BackColorFlash = false;
					Caverne_BackColorFlash_prec = false;
					pg_light_groups[7].set_group_val(_dimmer, 0.f);
				}
			}
		}
#endif
		oneLightChanged = true;
	}
#endif

	if (oneLightChanged) {
#if defined(var_Caverne_BackColor)
		if (ScenarioVarConfigurations[_Caverne_BackColor][pg_current_configuration_rank]) {
			//printf("pg_light_groups[7].get_group_val(_dimmer) %.2f           pg_light_groups[0].get_color()[0] %.2f\n", pg_light_groups[7].get_group_val(_dimmer), pg_light_groups[0].get_color()[0]);
		}
#endif
		pulse_light_prec[0] = pulse[0];
		pulse_light_prec[1] = pulse[1];
		pulse_light_prec[2] = pulse[2];
	}
}
#endif

void pg_update_pulsed_colors(void) {
	////////////////////////////////////////////////////////////////////////////////////////////////////
	// PEN PULSED COLOR
	// blending the two closest palettes of the pulsed pen color
#if defined(var_pen_color) && defined(var_pen_grey)
	if (ScenarioVarConfigurations[_pen_color][pg_current_configuration_rank]) {
		if (pen_color != pen_color_prec || pen_color_pulse != pen_color_pulse_prec
			|| pen_grey != pen_grey_prec || pen_grey_pulse != pen_grey_pulse_prec
			|| ((pen_grey_pulse != 0 || pen_color_pulse != 0)
				&& (pulse_prec[0] != pulse[0] || pulse_prec[1] != pulse[1] || pulse_prec[2] != pulse[2]))) {
			compute_pulsed_palette_color(pen_color, pen_color_pulse, pen_grey, pen_grey_pulse, pulsed_pen_color, true);
			pen_color_prec = pen_color;
			pen_color_pulse_prec = pen_color_pulse;
			pen_grey_prec = pen_grey;
			pen_grey_pulse_prec = pen_grey_pulse;
			pulse_prec[0] = pulse[0];
			pulse_prec[1] = pulse[1];
			pulse_prec[2] = pulse[2];
		}
	}
#endif
#if defined(var_pen_hue)
	if (ScenarioVarConfigurations[_pen_hue][pg_current_configuration_rank]) {
		&& defined(var_pen_sat) && defined(var_pen_value)
			if (pen_hue != pen_hue_prec || pen_hue_pulse != pen_hue_pulse_prec
				|| pen_sat != pen_sat_prec || pen_sat_pulse != pen_sat_pulse_prec
				|| pen_value != pen_value_prec || pen_value_pulse != pen_value_pulse_prec
				|| ((pen_sat_pulse != 0 || pen_value_pulse != 0 || pen_hue_pulse != 0)
					&& (pulse_prec[0] != pulse[0] || pulse_prec[1] != pulse[1] || pulse_prec[2] != pulse[2]))) {
				compute_pulsed_HSV_color(pen_hue, pen_hue_pulse, pen_sat, pen_sat_pulse, pen_value, pen_value_pulse, pulsed_pen_color, true);
				pen_hue_prec = pen_hue;
				pen_hue_pulse_prec = pen_hue_pulse;
				pen_sat_prec = pen_sat;
				pen_sat_pulse_prec = pen_sat_pulse;
				pen_value_prec = pen_value;
				pen_value_pulse_prec = pen_value_pulse;
				pulse_prec[0] = pulse[0];
				pulse_prec[1] = pulse[1];
				pulse_prec[2] = pulse[2];
			}
	}
#endif
	pulsed_pen_color[3] = 1.f;


	/***************************** SHOULD BE REACTIVATED WHEN THE INTERFACE CAN DISPLAY COLORS */
	//sprintf(AuxString, "/pen_colorPenPalette %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f",
	//	pen_bandpass_3color_palette[0][0], pen_bandpass_3color_palette[0][1], pen_bandpass_3color_palette[0][2], 
	//  pen_bandpass_3color_palette[1][0], pen_bandpass_3color_palette[1][1], pen_bandpass_3color_palette[1][2], 
	//  pen_bandpass_3color_palette[2][0], pen_bandpass_3color_palette[2][1], pen_bandpass_3color_palette[2][2]);
	//pg_send_message_udp((char *)"fffffffff", AuxString, (char *)"udp_TouchOSC_send");
	//sprintf(AuxString, "/pulsed_pen_color %.5f %.5f %.5f",
	//	pulsed_pen_color[0], pulsed_pen_color[1], pulsed_pen_color[2]);
	//pg_send_message_udp((char *)"fff", AuxString, (char *)"udp_TouchOSC_send");


	////////////////////////////////////////////////////////////////////////////////////////////////////
	// REPOP PULSED COLOR
	// blending the two closest palettes of the pulsed Repop color
	if (repop_colorBG != repop_colorBG_prec || repop_colorBG_pulse != repop_colorBG_pulse_prec
		|| repop_greyBG != repop_greyBG_prec || repop_greyBG_pulse != repop_greyBG_pulse_prec
		|| ((repop_greyBG_pulse != 0 || repop_colorBG_pulse != 0)
			&& (pulse_prec[0] != pulse[0] || pulse_prec[1] != pulse[1] || pulse_prec[2] != pulse[2]))) {
		compute_pulsed_palette_color(repop_colorBG, repop_colorBG_pulse, repop_greyBG, repop_greyBG_pulse, pulsed_repop_colorBG, false);
		repop_colorBG_prec = repop_colorBG;
		repop_colorBG_pulse_prec = repop_colorBG_pulse;
		repop_greyBG_prec = repop_greyBG;
		repop_greyBG_pulse_prec = repop_greyBG_pulse;
		pulse_prec[0] = pulse[0];
		pulse_prec[1] = pulse[1];
		pulse_prec[2] = pulse[2];
	}


	////////////////////////////////////////////////////////////////////////////////////////////////////
	// LIGHT PULSED COLOR
	// blending the two closest palettes of the pulsed Repop color
	//printf("%.2f %.2f\n", light1_dimmer, light1_dimmer_prec);
#ifdef PG_LIGHTS_CONTROL_IN_PG
	if (pg_FrameNo % 10 == 0) {
		pg_UpdateLightGroups_from_LightVars();
	}
#endif

#if defined(var_nb_CATypes)
	if (ScenarioVarConfigurations[_nb_CATypes][pg_current_configuration_rank]) {
		if (repop_colorCA != repop_colorCA_prec || repop_colorCA_pulse != repop_colorCA_pulse_prec
			|| repop_greyCA != repop_greyCA_prec || repop_greyCA_pulse != repop_greyCA_pulse_prec
			|| ((repop_greyCA_pulse != 0 || repop_colorCA_pulse != 0)
				&& (pulse_prec[0] != pulse[0] || pulse_prec[1] != pulse[1] || pulse_prec[2] != pulse[2]))) {
			compute_pulsed_palette_color(repop_colorCA, repop_colorCA_pulse, repop_greyCA, repop_greyCA_pulse, pulsed_repop_colorCA, false);
			repop_colorCA_prec = repop_colorCA;
			repop_colorCA_pulse_prec = repop_colorCA_pulse;
			repop_greyCA_prec = repop_greyCA;
			repop_greyCA_pulse_prec = repop_greyCA_pulse;
			pulse_prec[0] = pulse[0];
			pulse_prec[1] = pulse[1];
			pulse_prec[2] = pulse[2];
		}
	}
#endif
#if defined(var_part_initialization)
	if (ScenarioVarConfigurations[_part_initialization][pg_current_configuration_rank]) {
#if defined(var_repop_colorPart) && defined(var_repop_greyPart)
		if (ScenarioVarConfigurations[_repop_colorPart][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_repop_greyPart][pg_current_configuration_rank]) {
			if (repop_colorPart != repop_colorPart_prec || repop_colorPart_pulse != repop_colorPart_pulse_prec
				|| repop_greyPart != repop_greyPart_prec || repop_greyPart_pulse != repop_greyPart_pulse_prec
				|| ((repop_greyPart_pulse != 0.f || repop_colorPart_pulse != 0.f)
					&& (pulse_prec[0] != pulse[0] || pulse_prec[1] != pulse[1] || pulse_prec[2] != pulse[2]))) {
				compute_pulsed_palette_color(repop_colorPart, repop_colorPart_pulse, repop_greyPart, repop_greyPart_pulse, pulsed_repop_colorPart, false);
				repop_colorPart_prec = repop_colorPart;
				repop_colorPart_pulse_prec = repop_colorPart_pulse;
				repop_greyPart_prec = repop_greyPart;
				repop_greyPart_pulse_prec = repop_greyPart_pulse;
				pulse_prec[0] = pulse[0];
				pulse_prec[1] = pulse[1];
				pulse_prec[2] = pulse[2];
			}
		}
#endif
#if defined(var_repop_huePart) && defined(var_repop_satPart) && defined(var_repop_valuePart)
		if (ScenarioVarConfigurations[_repop_huePart][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_repop_satPart][pg_current_configuration_rank]
			&& ScenarioVarConfigurations[_repop_valuePart][pg_current_configuration_rank]) {
			if (repop_huePart != repop_huePart_prec || repop_huePart_pulse != repop_huePart_pulse_prec
				|| repop_satPart != repop_satPart_prec || repop_satPart_pulse != repop_satPart_pulse_prec
				|| repop_valuePart != repop_valuePart_prec || repop_valuePart_pulse != repop_valuePart_pulse_prec
				|| ((repop_satPart_pulse != 0.f || repop_valuePart_pulse != 0.f || repop_huePart_pulse != 0.f)
					&& (pulse_prec[0] != pulse[0] || pulse_prec[1] != pulse[1] || pulse_prec[2] != pulse[2]))) {
				compute_pulsed_HSV_color(repop_huePart, repop_huePart_pulse, repop_satPart, repop_satPart_pulse, repop_valuePart, repop_valuePart_pulse, pulsed_repop_colorPart, false);
				repop_huePart_prec = repop_huePart;
				repop_huePart_pulse_prec = repop_huePart_pulse;
				repop_satPart_prec = repop_satPart;
				repop_satPart_pulse_prec = repop_satPart_pulse;
				repop_valuePart_prec = repop_valuePart;
				repop_valuePart_pulse_prec = repop_valuePart_pulse;
				pulse_prec[0] = pulse[0];
				pulse_prec[1] = pulse[1];
				pulse_prec[2] = pulse[2];
			}
		}
#endif
	}
#endif

	/***************************** SHOULD BE REACTIVATED WHEN THE INTERFACE CAN DISPLAY COLORS */
	//sprintf(AuxString, "/repop_colorRepopPalette %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f %.5f",
	//  pen_bandpass_3color_palette[0][0], pen_bandpass_3color_palette[0][1], pen_bandpass_3color_palette[0][2], 
	//  pen_bandpass_3color_palette[1][0], pen_bandpass_3color_palette[1][1], pen_bandpass_3color_palette[1][2], 
	//  pen_bandpass_3color_palette[2][0], pen_bandpass_3color_palette[2][1], pen_bandpass_3color_palette[2][2]);
	//pg_send_message_udp((char *)"fffffffff", AuxString, (char *)"udp_TouchOSC_send");
	//sprintf(AuxString, "/pulsed_repop_color %.5f %.5f %.5f",
	//	pulsed_repop_color[0], pulsed_repop_color[1], pulsed_repop_color[2]);
	//pg_send_message_udp((char *)"fff", AuxString, (char *)"udp_TouchOSC_send");
}

//////////////////////////////////////////////////////////////
// TRACK LIB FUNCTIONS
//////////////////////////////////////////////////////////////

#if defined(var_path_record_1) 
void pg_path_recording_onOff(int indPath ) {
  // switches between recording on/off 
  bool is_path_record = false;
  switch (indPath) {
  case 1:
	  is_path_record = !pg_Path_Status[1].isActiveRecording;
	  *((bool *)ScenarioVarPointers[_path_record_1]) = is_path_record;
	  break;
#if defined(var_path_record_2) 
  case 2:
	  is_path_record = !pg_Path_Status[2].isActiveRecording;
	  *((bool *)ScenarioVarPointers[_path_record_2]) = is_path_record;
	  break;
#endif
#if defined(var_path_record_3) 
  case 3:
	  is_path_record = !pg_Path_Status[3].isActiveRecording;
	  *((bool *)ScenarioVarPointers[_path_record_3]) = is_path_record;
	  break;
#endif
#if defined(var_path_record_4) 
  case 4:
	  is_path_record = !pg_Path_Status[4].isActiveRecording;
	  *((bool*)ScenarioVarPointers[_path_record_4]) = is_path_record;
	  break;
#endif
#if defined(var_path_record_5) 
  case 5:
	  is_path_record = !pg_Path_Status[5].isActiveRecording;
	  *((bool*)ScenarioVarPointers[_path_record_5]) = is_path_record;
	  break;
#endif
#if defined(var_path_record_6) 
  case 6:
	  is_path_record = !pg_Path_Status[6].isActiveRecording;
	  *((bool*)ScenarioVarPointers[_path_record_6]) = is_path_record;
	  break;
#endif
#if defined(var_path_record_7) 
  case 7:
	  is_path_record = !pg_Path_Status[7].isActiveRecording;
	  *((bool*)ScenarioVarPointers[_path_record_7]) = is_path_record;
	  break;
#endif
#if defined(var_path_record_8) 
  case 8:
	  is_path_record = !pg_Path_Status[8].isActiveRecording;
	  *((bool*)ScenarioVarPointers[_path_record_8]) = is_path_record;
	  break;
#endif
#if defined(var_path_record_9) 
  case 9:
	  is_path_record = !pg_Path_Status[9].isActiveRecording;
	  *((bool*)ScenarioVarPointers[_path_record_9]) = is_path_record;
	  break;
#endif
#if defined(var_path_record_10) 
  case 10:
	  is_path_record = !pg_Path_Status[10].isActiveRecording;
	  *((bool*)ScenarioVarPointers[_path_record_10]) = is_path_record;
	  break;
#endif
#if defined(var_path_record_11) 
  case 11:
	  is_path_record = !pg_Path_Status[11].isActiveRecording;
	  *((bool*)ScenarioVarPointers[_path_record_11]) = is_path_record;
	  break;
#endif
  }

  // starts recording source 
  if( is_path_record ) {
	// is reading -> has to stop reading 
	// printf("Launches recording indPath %d: is replay %d\n", indPath, is_path_replay[indPath]);
	// printf("Replay indPath %d: %d\n", indPath, is_path_replay[indPath]);
	if( is_path_replay[indPath]) {
		// printf("Stops Replay indPath %d: %d\n", indPath, is_path_replay[indPath]);
		pg_path_replay_trackNo_stop(indPath);
	}

	// launches source recording 
	pg_path_recording_start(indPath);
	sprintf(AuxString, "/path_record_%d 1", indPath);
	pg_send_message_udp((char *)"i", AuxString, (char *)"udp_TouchOSC_send");

	// recording can only be made with one finger
#if defined(var_fingers)
	if (ScenarioVarConfigurations[_fingers][pg_current_configuration_rank]) {
		NumberOfInteractionFingers(1);
	}
#endif
  } else {
	// stops source recording 
	pg_path_recording_stop(indPath);
	sprintf(AuxString, "/path_record_%d 0", indPath);
	pg_send_message_udp((char *)"i", AuxString, (char *)"udp_TouchOSC_send");
  }
}
#endif

#if defined(var_path_replay_trackNo_1) || defined(var_path_record_1)
void pg_path_replay_trackNo_onOff(int indPath, int trackNo) {
	bool ispath_record = false;
	switch (indPath) {
	case 1:
		ispath_record = path_record_1;
		break;
#if defined(var_path_record_2) 
	case 2:
		ispath_record = path_record_2;
		break;
#endif
#if defined(var_path_record_3) 
	case 3:
		ispath_record = path_record_3;
		break;
#endif
#if defined(var_path_record_4) 
	case 4:
		ispath_record = path_record_4;
		break;
#endif
#if defined(var_path_record_5) 
	case 5:
		ispath_record = path_record_5;
		break;
#endif
#if defined(var_path_record_6) 
	case 6:
		ispath_record = path_record_6;
		break;
#endif
#if defined(var_path_record_7) 
	case 7:
		ispath_record = path_record_7;
		break;
#endif
#if defined(var_path_record_8) 
	case 8:
		ispath_record = path_record_8;
		break;
#endif
#if defined(var_path_record_9) 
	case 9:
		ispath_record = path_record_9;
		break;
#endif
#if defined(var_path_record_10) 
	case 10:
		ispath_record = path_record_10;
		break;
#endif
#if defined(var_path_record_11) 
	case 11:
		ispath_record = path_record_11;
		break;
#endif
	}

  // is not currently reading and positive or null track -> starts reading 
  if(!is_path_replay[indPath] && trackNo >= 0) {
	//printf( "start_read_path #%d on track %d\n", indPath, trackNo);

	// is recording source -> has to stop recording source 
	if( ispath_record ) {
	  pg_path_recording_stop(indPath);
	}

	// start reading 
	pg_path_replay_trackNo_start(indPath, trackNo);
  } 
  // is currently reading && negative track -> stops reading 
  else if (is_path_replay[indPath] && trackNo < 0) {
	  // printf("stop_read_path #%d (track No negative)\n", indPath);

	// stops reading 
	pg_path_replay_trackNo_stop(indPath);

	switch (indPath) {
#if defined(var_path_replay_trackNo_1) 
	case 1:
		*((int *)ScenarioVarPointers[_path_replay_trackNo_1]) = -1;
		break;
#endif
#if defined(var_path_replay_trackNo_2) 
	case 2:
		*((int *)ScenarioVarPointers[_path_replay_trackNo_2]) = -1;
		break;
#endif
#if defined(var_path_replay_trackNo_3) 
	case 3:
		*((int *)ScenarioVarPointers[_path_replay_trackNo_3]) = -1;
		break;
#endif
#if defined(var_path_replay_trackNo_4) 
	case 4:
		*((int*)ScenarioVarPointers[_path_replay_trackNo_4]) = -1;
		break;
#endif
#if defined(var_path_replay_trackNo_5) 
	case 5:
		*((int*)ScenarioVarPointers[_path_replay_trackNo_5]) = -1;
		break;
#endif
#if defined(var_path_replay_trackNo_6) 
	case 6:
		*((int*)ScenarioVarPointers[_path_replay_trackNo_6]) = -1;
		break;
#endif
#if defined(var_path_replay_trackNo_7) 
	case 7:
		*((int*)ScenarioVarPointers[_path_replay_trackNo_7]) = -1;
		break;
#endif
#if defined(var_path_replay_trackNo_8) 
	case 8:
		*((int*)ScenarioVarPointers[_path_replay_trackNo_8]) = -1;
		break;
#endif
#if defined(var_path_replay_trackNo_9) 
	case 9:
		*((int*)ScenarioVarPointers[_path_replay_trackNo_9]) = -1;
		break;
#endif
#if defined(var_path_replay_trackNo_10) 
	case 10:
		*((int*)ScenarioVarPointers[_path_replay_trackNo_10]) = -1;
		break;
#endif
#if defined(var_path_replay_trackNo_11) 
	case 11:
		*((int*)ScenarioVarPointers[_path_replay_trackNo_11]) = -1;
		break;
#endif
	}

  }
}
#endif

#if defined(var_path_record_1) 
void pg_path_recording_start(int indPath) {
	switch (indPath) {
	case 1:
		*((bool *)ScenarioVarPointers[_path_record_1]) = true;
		break;
#if defined(var_path_record_2) 
	case 2:
		*((bool *)ScenarioVarPointers[_path_record_2]) = true;
		break;
#endif
#if defined(var_path_record_3) 
	case 3:
		*((bool *)ScenarioVarPointers[_path_record_3]) = true;
		break;
#endif
#if defined(var_path_record_4) 
	case 4:
		*((bool*)ScenarioVarPointers[_path_record_4]) = true;
		break;
#endif
#if defined(var_path_record_5) 
	case 5:
		*((bool*)ScenarioVarPointers[_path_record_5]) = true;
		break;
#endif
#if defined(var_path_record_6) 
	case 6:
		*((bool*)ScenarioVarPointers[_path_record_6]) = true;
		break;
#endif
#if defined(var_path_record_7) 
	case 7:
		*((bool*)ScenarioVarPointers[_path_record_7]) = true;
		break;
#endif
#if defined(var_path_record_8) 
	case 8:
		*((bool*)ScenarioVarPointers[_path_record_8]) = true;
		break;
#endif
#if defined(var_path_record_9) 
	case 9:
		*((bool*)ScenarioVarPointers[_path_record_9]) = true;
		break;
#endif
#if defined(var_path_record_10) 
	case 10:
		*((bool*)ScenarioVarPointers[_path_record_10]) = true;
		break;
#endif
#if defined(var_path_record_11) 
	case 11:
		*((bool*)ScenarioVarPointers[_path_record_11]) = true;
		break;
#endif
	}
	if (indPath >= 1 && indPath <= PG_NB_PATHS) {
		pg_Path_Status[indPath].isActiveRecording = true;
		pg_Path_Status[indPath].path_nbRecordedFrames = 0;
		pg_Path_Status[indPath].readSpeedScale = 1.0f;
		// printf("start recording track %d\n",indPath);
	}
}
#endif

#if defined(var_path_record_1) 
void pg_path_recording_stop(int indPath) {
	switch (indPath) {
	case 1:
		*((bool *)ScenarioVarPointers[_path_record_1]) = false;
		break;
#if defined(var_path_record_2) 
	case 2:
		*((bool *)ScenarioVarPointers[_path_record_2]) = false;
		break;
#endif
#if defined(var_path_record_3) 
	case 3:
		*((bool *)ScenarioVarPointers[_path_record_3]) = false;
		break;
#endif
#if defined(var_path_record_4) 
	case 4:
		*((bool*)ScenarioVarPointers[_path_record_4]) = false;
		break;
#endif
#if defined(var_path_record_5) 
	case 5:
		*((bool*)ScenarioVarPointers[_path_record_5]) = false;
		break;
#endif
#if defined(var_path_record_6) 
	case 6:
		*((bool*)ScenarioVarPointers[_path_record_6]) = false;
		break;
#endif
#if defined(var_path_record_7) 
	case 7:
		*((bool*)ScenarioVarPointers[_path_record_7]) = false;
		break;
#endif
#if defined(var_path_record_8) 
	case 8:
		*((bool*)ScenarioVarPointers[_path_record_8]) = false;
		break;
#endif
#if defined(var_path_record_9) 
	case 9:
		*((bool*)ScenarioVarPointers[_path_record_9]) = false;
		break;
#endif
#if defined(var_path_record_10) 
	case 10:
		*((bool*)ScenarioVarPointers[_path_record_10]) = false;
		break;
#endif
#if defined(var_path_record_11) 
	case 11:
		*((bool*)ScenarioVarPointers[_path_record_11]) = false;
		break;
#endif
	}
	if (indPath >= 1 && indPath <= PG_NB_PATHS
		&& pg_Path_Status[indPath].isActiveRecording == true) {
		pg_Path_Status[indPath].isActiveRecording = false;
		sprintf(AuxString, "/path_record_%d 0", indPath);
		pg_send_message_udp((char *)"i", AuxString, (char *)"udp_TouchOSC_send");
	}
}
#endif

#if defined(var_path_replay_trackNo_1) || defined(var_path_record_1)
void pg_path_replay_trackNo_start(int indPath, int trackNo) {
	//printf("replay path %d starts on track %d replayed %d nb frames %d\n", indPath, trackNo, is_path_replay[indPath], pg_Path_Status[indPath].nbRecordedFrames);
	if (indPath >= 1 && indPath <= PG_NB_PATHS
		&& !is_path_replay[indPath]
		&& pg_Path_Status[indPath].path_nbRecordedFrames > 0) {
		is_path_replay[indPath] = true;
		//printf("replay path No %d on track %d with %d frames (replay %d)\n", indPath, trackNo, pg_Path_Status[indPath].path_nbRecordedFrames, is_path_replay[indPath]);
		switch (indPath) {
		case 1:
			*((int *)ScenarioVarPointers[_path_replay_trackNo_1]) = trackNo;
			break;
#if defined(var_path_replay_trackNo_2) 
		case 2:
			*((int *)ScenarioVarPointers[_path_replay_trackNo_2]) = trackNo;
			break;
#endif
#if defined(var_path_replay_trackNo_3) 
		case 3:
			*((int *)ScenarioVarPointers[_path_replay_trackNo_3]) = trackNo;
			break;
#endif
#if defined(var_path_replay_trackNo_4) 
		case 4:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_4]) = trackNo;
			break;
#endif
#if defined(var_path_replay_trackNo_5) 
		case 5:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_5]) = trackNo;
			break;
#endif
#if defined(var_path_replay_trackNo_6) 
		case 6:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_6]) = trackNo;
			break;
#endif
#if defined(var_path_replay_trackNo_7) 
		case 7:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_7]) = trackNo;
			break;
#endif
#if defined(var_path_replay_trackNo_8) 
		case 8:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_8]) = trackNo;
			break;
#endif
#if defined(var_path_replay_trackNo_9) 
		case 9:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_9]) = trackNo;
			break;
#endif
#if defined(var_path_replay_trackNo_10) 
		case 10:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_10]) = trackNo;
			break;
#endif
#if defined(var_path_replay_trackNo_11) 
		case 11:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_11]) = trackNo;
			break;
#endif
		}
		// first time reading: starts from beginning
		// otherwise starts from where it is
		//if (pg_Path_Status[indPath].indReading < 0) {
			// restarts from beginning, not from where it was
			pg_Path_Status[indPath].indReading = 0;
		//}
		pg_Path_Status[indPath].isFirstFrame = true;
		//printf("-> start_read_path %d\n", indPath);
		//printf("ind reading %d\n", pg_Path_Status[indPath].indReading);
	}
}
#endif

#if defined(var_path_replay_trackNo_1) || defined(var_path_record_1)
void pg_path_replay_trackNo_stop(int indPath) {
	if (indPath >= 1 && indPath <= PG_NB_PATHS
		&& is_path_replay[indPath]) {
		is_path_replay[indPath] = false;
		paths_x[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_y[indPath] = PG_OUT_OF_SCREEN_CURSOR;
#ifdef PG_BEZIER_PATHS
		paths_xL[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_yL[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_xR[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_yR[indPath] = PG_OUT_OF_SCREEN_CURSOR;
#endif
		paths_x_prev[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		paths_y_prev[indPath] = PG_OUT_OF_SCREEN_CURSOR;
		isBegin[indPath] = false;
		isEnd[indPath] = false;
		paths_Color_r[indPath] = 0.0F;
		paths_Color_g[indPath] = 0.0F;
		paths_Color_b[indPath] = 0.0F;
		paths_Color_a[indPath] = 1.0F;
		paths_RadiusX[indPath] = 0.0F;
		paths_RadiusY[indPath] = 0.0F;
		// printf( "-> start_read_path\n"  );
		switch (indPath) {
		case 1:
			*((int *)ScenarioVarPointers[_path_replay_trackNo_1]) = -1;
			break;
#if defined(var_path_replay_trackNo_2) 
		case 2:
			*((int *)ScenarioVarPointers[_path_replay_trackNo_2]) = -1;
			break;
#endif
#if defined(var_path_replay_trackNo_3) 
		case 3:
			*((int *)ScenarioVarPointers[_path_replay_trackNo_3]) = -1;
			break;
#endif
#if defined(var_path_replay_trackNo_4) 
		case 4:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_4]) = -1;
			break;
#endif
#if defined(var_path_replay_trackNo_5) 
		case 5:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_5]) = -1;
			break;
#endif
#if defined(var_path_replay_trackNo_6) 
		case 6:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_6]) = -1;
			break;
#endif
#if defined(var_path_replay_trackNo_7) 
		case 7:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_7]) = -1;
			break;
#endif
#if defined(var_path_replay_trackNo_8) 
		case 8:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_8]) = -1;
			break;
#endif
#if defined(var_path_replay_trackNo_9) 
		case 9:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_9]) = -1;
			break;
#endif
#if defined(var_path_replay_trackNo_10) 
		case 10:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_10]) = -1;
			break;
#endif
#if defined(var_path_replay_trackNo_11) 
		case 11:
			*((int*)ScenarioVarPointers[_path_replay_trackNo_11]) = -1;
			break;
#endif
		}
		//sprintf(AuxString, "/path_replay_trackNo_%d 0", indPath);
		//pg_send_message_udp((char *)"i", AuxString, (char *)"udp_TouchOSC_send");
	}
}
#endif


//////////////////////////////////////////////////////////////
// MISC LIB FUNCTIONS
//////////////////////////////////////////////////////////////

void pg_writeMessageOnScreen( string text ) {
  ScreenMessage = text; 
  double newtime = RealTime(); 
  messageTransparency = 1.0; 
  LastScreenMessageDecayTime = newtime; 
  NewScreenMessage = true;
}

void pg_snapshot( char * type ) {
  if( strcmp( type , "svg" ) == 0 ) {
	pg_draw_scene( _Svg, true );
  }
  else if( strcmp( type , "png" ) == 0 ) {
	pg_draw_scene( _Png, true);
  }
  else if( strcmp( type , "jpg" ) == 0 ) {
	pg_draw_scene( _Jpg, true);
  }
  else {
	sprintf( ErrorStr , "Incorrect screenshot type (%s): expected svg or png or jpg!" , type ); ReportError( ErrorStr );
  }
}


